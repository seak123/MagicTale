/// <reference lib="dom" />
declare module "global" {
  let g: Global;
  export default g;
}
declare module "engine/type" {
  /** Alias type for value that can be null */
  export type Nullable<T> = T | null;
  /**
   * Alias type for number that are floats
   * @ignorenaming
   */
  export type float = number;
  /**
   * Alias type for number that are doubles.
   * @ignorenaming
   */
  export type double = number;
  /**
   * Alias type for number that are integer
   * @ignorenaming
   */
  export type int = number;
  /** Alias type for number array or Float32Array */
  export type FloatArray = number[] | Float32Array;
  /** Alias type for number array or Float32Array or Int32Array or Uint32Array or Uint16Array */
  export type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;
  /**
   * Alias for types that can be used by a Buffer or VertexBuffer.
   */
  export type DataArray = number[] | ArrayBuffer | ArrayBufferView;
  type Primitive = undefined | null | boolean | string | number | ((...args: any[]) => any);
  /**
   * Type modifier to make all the properties of an object Readonly
   */
  export type Immutable<T> = T extends Primitive ? T : T extends Array<infer U> ? ReadonlyArray<U> : DeepImmutable<T>;
  /**
   * Type modifier to make all the properties of an object Readonly recursively
   */
  export type DeepImmutable<T> = T extends Primitive ? T : T extends Array<infer U> ? DeepImmutableArray<U> : DeepImmutableObject<T>;
  /** @hidden */
  export interface DeepImmutableArray<T> extends ReadonlyArray<DeepImmutable<T>> {}
  /** @hidden */
  /** @hidden */
  export type DeepImmutableObject<T> = {
    readonly [K in keyof T]: DeepImmutable<T[K]>;
  };
  export type Never = never | undefined;
  interface CastDeepMutableArray<T> extends Array<CastDeepMutable<T>> {}
  type CastDeepMutableObject<T> = {
    [K in keyof T]: CastDeepMutable<T[K]>;
  };
  export type CastDeepMutable<T> = T extends Primitive ? T : T extends ReadonlyArray<infer U> ? CastDeepMutableArray<U> : CastDeepMutableObject<T>;
  export {};
}
declare module "engine/misc/observable" {
  import { Nullable } from "engine/type";
  /**
   * A class serves as a medium between the observable and its observers
   */
  export class EventState {
    /**
     * An Observer can set this property to true to prevent subsequent observers of being notified
     */
    skipNextObservers: boolean;
    /**
     * Get the mask value that were used to trigger the event corresponding to this EventState object
     */
    mask: number;
    /**
     * The object that originally notified the event
     */
    target?: any;
    /**
     * The current object in the bubbling phase
     */
    currentTarget?: any;
    /**
     * This will be populated with the return value of the last function that was executed.
     * If it is the first function in the callback chain it will be the event data.
     */
    lastReturnValue?: any;
    /**
     * Create a new EventState
     * @param mask defines the mask associated with this state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     */
    constructor(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any);
    /**
     * Initialize the current event state
     * @param mask defines the mask associated with this state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @returns the current event state
     */
    initalize(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any): EventState;
  }
  /**
   * Represent an Observer registered to a given Observable object.
   */
  export class Observer<T> {
    /**
     * Defines the callback to call when the observer is notified
     */
    callback: (eventData: T, eventState: EventState) => void;
    /**
     * Defines the mask of the observer (used to filter notifications)
     */
    mask: number;
    /**
     * Defines the current scope used to restore the JS context
     */
    scope: any;
    /**
     * Gets or sets a property defining that the observer as to be unregistered after the next notification
     */
    unregisterOnNextCall: boolean;
    /**
     * Creates a new observer
     * @param callback defines the callback to call when the observer is notified
     * @param mask defines the mask of the observer (used to filter notifications)
     * @param scope defines the current scope used to restore the JS context
     */
    constructor(
      /**
       * Defines the callback to call when the observer is notified
       */
      callback: (eventData: T, eventState: EventState) => void,
      /**
       * Defines the mask of the observer (used to filter notifications)
       */
      mask?: number,
      /**
       * Defines the current scope used to restore the JS context
       */
      scope?: any,
    );
  }
  /**
   * The Observable class is a simple implementation of the Observable pattern.
   *
   * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
   * This enable a more fine grained execution without having to rely on multiple different Observable objects.
   * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
   * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
   */
  export class Observable<T> {
    /**
     * Gets the list of observers
     */
    get observers(): Array<Observer<T>>;
    /**
     * Creates a new observable
     * @param onObserverAdded defines a callback to call when a new observer is added
     */
    constructor(onObserverAdded?: (observer: Observer<T>) => void);
    /**
     * Create a new Observer with the specified callback
     * @param callback the callback that will be executed for that Observer
     * @param mask the mask used to filter observers
     * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
     * @param scope optional scope for the callback to be called from
     * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
     * @returns the new observer created for the callback
     */
    add(callback: (eventData: T, eventState: EventState) => void, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Observer<T>;
    addObserver(observer: Observer<T>, insertFirst?: boolean): void;
    /**
     * Create a new Observer with the specified callback and unregisters after the next notification
     * @param callback the callback that will be executed for that Observer
     * @returns the new observer created for the callback
     */
    addOnce(callback: (eventData: T, eventState: EventState) => void): Nullable<Observer<T>>;
    /**
     * Remove an Observer from the Observable object
     * @param observer the instance of the Observer to remove
     * @returns false if it doesn't belong to this Observable
     */
    remove(observer?: Observer<T>): boolean;
    /**
     * Remove a callback from the Observable object
     * @param callback the callback to remove
     * @param scope optional scope. If used only the callbacks with this scope will be removed
     * @returns false if it doesn't belong to this Observable
     */
    removeCallback(callback: (eventData: T, eventState: EventState) => void, scope?: any): boolean;
    /**
     * Moves the observable to the top of the observer list making it get called first when notified
     * @param observer the observer to move
     */
    makeObserverTopPriority(observer: Observer<T>): void;
    /**
     * Moves the observable to the bottom of the observer list making it get called last when notified
     * @param observer the observer to move
     */
    makeObserverBottomPriority(observer: Observer<T>): void;
    /**
     * Notify all Observers by calling their respective callback with the given data
     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
     * @param eventData defines the data to send to all observers
     * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
     */
    notifyObservers(eventData: T, mask?: number, target?: any, currentTarget?: any): boolean;
    /**
     * Calling this will execute each callback, expecting it to be a promise or return a value.
     * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
     * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
     * and it is crucial that all callbacks will be executed.
     * The order of the callbacks is kept, callbacks are not executed parallel.
     *
     * @param eventData The data to be sent to each callback
     * @param mask is used to filter observers defaults to -1
     * @param target defines the callback target (see EventState)
     * @param currentTarget defines he current object in the bubbling phase
     * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
     */
    notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any): Promise<T>;
    /**
     * Notify a specific observer
     * @param observer defines the observer to notify
     * @param eventData defines the data to be sent to each callback
     * @param mask is used to filter observers defaults to -1
     */
    notifyObserver(observer: Observer<T>, eventData: T, mask?: number): void;
    /**
     * Gets a boolean indicating if the observable has at least one observer
     * @returns true is the Observable has at least one Observer registered
     */
    hasObservers(): boolean;
    /**
     * Clear the list of observers
     */
    clear(): void;
    /**
     * Clone the current observable
     * @returns a new observable
     */
    clone(): Observable<T>;
    /**
     * Does this observable handles observer registered with a given mask
     * @param mask defines the mask to be tested
     * @return whether or not one observer registered with the given mask is handeled
     */
    hasSpecificMask(mask?: number): boolean;
  }
}
declare module "engine/misc/array" {
  import { Nullable } from "engine/type";
  import { Observable } from "engine/misc/observable";
  /**
   * Defines an array and its length.
   * It can be helpfull to group result from both Arrays and smart arrays in one structure.
   */
  export interface ISmartArrayLike<T> {
    /**
     * The data of the array.
     */
    data: T[];
    /**
     * The active length of the array.
     */
    length: number;
  }
  /**
   * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
   */
  export class SmartArray<T> implements ISmartArrayLike<T> {
    /**
     * The full set of data from the array.
     */
    data: T[];
    /**
     * The active length of the array.
     */
    length: number;
    /**
     * Instantiates a Smart Array.
     * @param capacity defines the default capacity of the array.
     */
    constructor(capacity: number, scaleFactor?: number, releaseOnReset?: boolean);
    /**
     * Pushes a value at the end of the active data.
     * @param value defines the object to push in the array.
     */
    push(value: T): void;
    /**
     * Pops a value at the end of the active data.
     * @return defines the object to pop in the array.
     */
    pop(): T;
    remove(idx: number): void;
    /**
     * Iterates over the active data and apply the lambda to them.
     * @param func defines the action to apply on each value.
     */
    forEach(func: (content: T) => void): void;
    /**
     * Sorts the full sets of data.
     * @param compareFn defines the comparison function to apply.
     */
    sort(compareFn: (a: T, b: T) => number): void;
    /**
     * Resets the active data to an empty array.
     */
    reset(): void;
    /**
     * Releases all the data from the array as well as the array.
     */
    dispose(): void;
    /**
     * Concats the active data with a given array.
     * @param array defines the data to concatenate with.
     */
    concat(array: any): void;
    /**
     * Returns the position of a value in the active data.
     * @param value defines the value to find the index for
     * @returns the index if found in the active data otherwise -1
     */
    indexOf(value: T): number;
    /**
     * Returns whether an element is part of the active data.
     * @param value defines the value to look for
     * @returns true if found in the active data otherwise false
     */
    contains(value: T): boolean;
  }
  /**
   * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
   * The data in this array can only be present once
   */
  export class SmartArrayNoDuplicate<T> extends SmartArray<T> {
    /**
     * Pushes a value at the end of the active data.
     * THIS DOES NOT PREVENT DUPPLICATE DATA
     * @param value defines the object to push in the array.
     */
    push(value: T): void;
    pop(): T;
    remove(idx: number): void;
    /**
     * Pushes a value at the end of the active data.
     * If the data is already present, it won t be added again
     * @param value defines the object to push in the array.
     * @returns true if added false if it was already present
     */
    pushNoDuplicate(value: T): boolean;
    /**
     * Resets the active data to an empty array.
     */
    reset(): void;
    /**
     * Concats the active data with a given array.
     * This ensures no dupplicate will be present in the result.
     * @param array defines the data to concatenate with.
     */
    concatWithNoDuplicate(array: any): void;
  }
  export class ObservableArray<T> {
    get data(): T[];
    get length(): number;
    get onAddObservable(): Observable<T>;
    get onRemoveObservable(): Observable<T>;
    constructor(source: T[], getter?: (item: T) => T, setter?: (item: T) => T);
    push(value: T): void;
    pop(): T | undefined;
    remove(idx: number): void;
    forEach(func: (content: T) => void): void;
    setAtIndex(index: number, value: T): boolean;
    getAtIndex(index: number): Nullable<T>;
    sort(compareFn: (a: T, b: T) => number): void;
    clear(): void;
    indexOf(value: T): number;
    contains(value: T): boolean;
  }
}
declare module "engine/misc/emitter" {
  class Pair<S, T> {
    first: S;
    second: T;
    constructor(first: S, second: T);
  }
  class Node<T> {
    static readonly Undefined: Node<any>;
    static readonly Invalid: Node<any>;
    element: T;
    next: Node<T>;
    prev: Node<T>;
    constructor(element: T);
  }
  class List<T> {
    first: Node<T>;
    last: Node<T>;
    size: number;
    isEmpty(): boolean;
    clear(cb?: (node: T) => void): void;
    unshift(arg: T): Node<T>;
    push(arg: T): Node<T>;
    remove(node: Node<T>): void;
    shift(): T | undefined;
    pop(): T | undefined;
    iterator(func: (Arg: T) => void, reverse?: boolean): void;
  }
  export interface EmitterOptions<S, T> {
    onFirstListenerAdd?: (emitter: Emitter<S, T>) => any;
    onFirstListenerDidAdd?: (emitter: Emitter<S, T>) => any;
    onListenerDidAdd?: (emitter: Emitter<S, T>, listener: EventListener<S, T>, thisArgs: any) => any;
    onLastListenerRemove?: (emitter: Emitter<S, T>) => any;
  }
  export interface IDisposable {
    dispose(): void;
  }
  type EventListener<S, T> = (target: S, arg: T) => void;
  interface IEvent<S, T> {
    add: (listener: EventListener<S, T>, thisArgs?: any) => Node<Pair<EventListener<S, T>, any>> | undefined;
    remove: (node?: Node<Pair<EventListener<S, T>, any>>) => void;
  }
  export type Listener<S, T = void> = Node<Pair<EventListener<S, T>, any>>;
  export class Emitter<S, T = void> implements IEvent<S, T>, IDisposable {
    constructor(options?: EmitterOptions<S, T>);
    add(listener: EventListener<S, T>, thisArgs?: any): Listener<S, T> | undefined;
    remove(node?: Listener<S, T>): void;
    fire(first: S, second: T): void;
    fireStable(first: S, second: T): void;
    dispose(): void;
    isEmpty(): boolean;
  }
  export {};
}
declare module "engine/event" {
  import { Emitter } from "engine/misc/emitter";
  export enum MaterialEventType {
    RenderQueueChange = 0,
    RenderStateChange = 1,
    DefinationChange = 2,
    TextureChange = 3,
  }
  export enum MeshEventType {
    SubMeshModified = 0,
    SubMeshCountChanged = 1,
    BoundBallChanged = 2,
    BoundBoxChanged = 3,
  }
  export enum BoundsChangeEventType {
    SizeChange = 0,
    AnchorChange = 1,
  }
  export enum ChildChangeEventType {
    Add = 0,
    Remove = 1,
  }
  export enum DirectionalLightEventType {
    Added = 0,
    Removed = 1,
  }
  export enum Renderable2DEventType {
    Added = 0,
    Removed = 1,
    Moved = 2,
    Modified = 3,
    VertexChange = 4,
    MaterialChange = 5,
  }
  export enum UILayerChangeType {
    Added = 0,
    Removed = 1,
    Modified = 2,
  }
  export enum MeshRendererEventType {
    Added = 0,
    Removed = 1,
    Modified = 2,
    SubMeshModified = 3,
    CastShadowModified = 4,
  }
  export enum PipeLineEventType {
    ClearAllCache = 0,
  }
  export const RenderSizeChangeEvent: Emitter<number, number>;
}
declare module "wgfx/def" {
  export enum EnumFeature {
    INSTANCING = 0,
    TEXTURE_COMPRESSION_DXT = 1,
    TEXTURE_COMPRESSION_PVRTC = 2,
    TEXTURE_COMPRESSION_ATC = 3,
    TEXTURE_COMPRESSION_ETC2 = 4,
    TEXTURE_FLOAT = 5,
    TEXTURE_HALF_FLOAT = 6,
    ORIGIN_BOTTOM_LEFT = 7,
    ORIGIN_TOP_LEFT = 8,
    MSAA_RENDER_TARGETS = 9,
    PACKED_VERTEX_FORMAT_10_2 = 10,
    MULTIPLE_RENDER_TARGET = 11,
    IMAGETYPE_3D = 12,
    IMAGETYPE_ARRAY = 13,
    TEXTURE_COMPRESSION_ETC1 = 14,
    TEXTURE_COMPRESSION_ASTC_8x8 = 15,
  }
  export enum EnumUsage {
    IMMUTABLE = 1,
    DYNAMIC = 2,
    STREAM = 3,
  }
  export enum EnumBufferType {
    VERTEXBUFFER = 1,
    INDEXBUFFER = 2,
  }
  export enum EnumIndexType {
    NONE = 1,
    UINT16 = 2,
    UINT32 = 3,
  }
  export enum EnumImageType {
    IMAGETYPE_2D = 1,
    IMAGETYPE_CUBE = 2,
    IMAGETYPE_3D = 3,
    IMAGETYPE_ARRAY = 4,
  }
  export enum EnumCubeFace {
    POS_X = 0,
    NEG_X = 1,
    POS_Y = 2,
    NEG_Y = 3,
    POS_Z = 4,
    NEG_Z = 5,
    NUM = 6,
  }
  export enum EnumShaderStage {
    VS = 0,
    FS = 1,
  }
  export enum EnumPixelFormat {
    NONE = 1,
    RGBA8 = 2,
    RGB8 = 3,
    RGBA4 = 4,
    R5G6B5 = 5,
    R5G5B5A1 = 6,
    R10G10B10A2 = 7,
    RGBA32F = 8,
    RGBA16F = 9,
    R32F = 10,
    R16F = 11,
    L8 = 12,
    DXT1 = 13,
    DXT3 = 14,
    DXT5 = 15,
    DEPTH = 16,
    DEPTHSTENCIL = 17,
    PVRTC2_RGB = 18,
    PVRTC4_RGB = 19,
    PVRTC2_RGBA = 20,
    PVRTC4_RGBA = 21,
    ETC2_RGB8 = 22,
    ETC2_SRGB8 = 23,
    ETC1_RGB8 = 24,
    PIXELFORMAT_PVR_CCZ = 25,
    PIXELFORMAT_PVR_GZ = 26,
    PIXELFORMAT_ETC2_RGBA8 = 27,
    ASTC = 28,
  }
  export enum EnumPrimitiveType {
    POINTS = 1,
    LINES = 2,
    LINE_STRIP = 3,
    TRIANGLES = 4,
    TRIANGLE_STRIP = 5,
  }
  export enum EnumFilter {
    NEAREST = 1,
    LINEAR = 2,
    NEAREST_MIPMAP_NEAREST = 3,
    NEAREST_MIPMAP_LINEAR = 4,
    LINEAR_MIPMAP_NEAREST = 5,
    LINEAR_MIPMAP_LINEAR = 6,
  }
  export enum EnumWrap {
    REPEAT = 1,
    CLAMP_TO_EDGE = 2,
    MIRRORED_REPEAT = 3,
  }
  export enum EnumVertexFormat {
    INVALID = 0,
    FLOAT = 1,
    FLOAT2 = 2,
    FLOAT3 = 3,
    FLOAT4 = 4,
    BYTE4 = 5,
    BYTE4N = 6,
    UBYTE4 = 7,
    UBYTE4N = 8,
    SHORT2 = 9,
    SHORT2N = 10,
    SHORT4 = 11,
    SHORT4N = 12,
    UINT10_N2 = 13,
  }
  export enum EnumVertexStep {
    PER_VERTEX = 1,
    PER_INSTANCE = 2,
  }
  export enum EnumUniformType {
    INVALID = 0,
    FLOAT = 1,
    FLOAT2 = 2,
    FLOAT3 = 3,
    FLOAT4 = 4,
    MAT4 = 5,
  }
  export enum EnumCullMode {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
  }
  export enum EnumFaceWinding {
    CCW = 1,
    CW = 2,
  }
  export enum EnumCompareFunc {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
  }
  export enum EnumStencilOp {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_CLAMP = 4,
    DECR_CLAMP = 5,
    INVERT = 6,
    INCR_WRAP = 7,
    DECR_WRAP = 8,
  }
  export enum EnumBlendFactor {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    ONE_MINUS_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    ONE_MINUS_SRC_ALPHA = 6,
    DST_COLOR = 7,
    ONE_MINUS_DST_COLOR = 8,
    DST_ALPHA = 9,
    ONE_MINUS_DST_ALPHA = 10,
    SRC_ALPHA_SATURATED = 11,
    BLEND_COLOR = 12,
    ONE_MINUS_BLEND_COLOR = 13,
    BLEND_ALPHA = 14,
    ONE_MINUS_BLEND_ALPHA = 15,
  }
  export enum EnumBlendOp {
    ADD = 1,
    SUBTRACT = 2,
    REVERSE_SUBTRACT = 3,
  }
  export enum EnumColorMask {
    NONE = 16,
    R = 1,
    G = 2,
    B = 4,
    A = 8,
    RGB = 7,
    RGBA = 15,
  }
  export enum EnumAction {
    CLEAR = 1,
    LOAD = 2,
    DONTCARE = 3,
  }
  export enum EnumPixelType {
    UNSIGNED_BYTE = 5121,
    FLOAT = 5126,
    UNSIGNED_SHORT_5_6_5 = 33635,
    UNSIGNED_SHORT_4_4_4_4 = 32819,
    UNSIGNED_SHORT_5_5_5_1 = 32820,
  }
  export enum EnumResourceState {
    INITIAL = 0,
    ALLOC = 1,
    VALID = 2,
    FAILED = 3,
    INVALID = 4,
  }
}
declare module "wgfx" {
  export {};
}
declare module "lib/utils/nativeBuffer" {
  export class NativeBufferReader {
    byteOffset: number;
    f32View: Float32Array;
    constructor(buffer: ArrayBuffer, startOffset?: number);
    align4(): void;
    startSegment(): void;
    endSegment(): void;
    checkSegmentCanRead(): boolean;
    clear(): void;
    readUint32(): number;
    readUint16(): number;
    readUint8(): number;
    readInt32(): number;
    readFloat32(): number;
  }
  export class NativeBufferWriter {
    constructor(buffer: ArrayBuffer, startOffset?: number);
    clear(): void;
    align4(): void;
    pushSegment(): void;
    popSegment(): void;
    writeUint32(value: number): void;
    writeUint8(value: number): void;
    writeFloat32(value: number): void;
  }
}
declare module "engine/debug/logger" {
  const entrance: LoggerEntrance;
  export default entrance;
  type LoggerTagger = (tag: string) => LoggerInstance;
  export interface LoggerInstance extends LoggerTagger {
    /**
     * 打印点东西
     * 用法和 console.log 一样
     * @param args
     */
    log(...args: any[]): void;
    /**
     * 打印点东西
     * 和console.log不一样的是，这里可以支持只传一个返回数组的函数参数，这个数组才会是log的内容
     * 这个函数在log标签和log等级都命中的时候才会执行
     * 用于节省日常情况的计算量
     * @param lazyArgs
     */
    log(lazyArgs: () => any[]): void;
    info(...args: any[]): void;
    info(lazyArgs: () => any[]): void;
    warn(...args: any[]): void;
    warn(lazyArgs: () => any[]): void;
    error(...args: any[]): void;
    error(lazyArgs: () => any[]): void;
  }
  /**
   * 日志输出模块
   *
   * import Logger from '../debug/logger'
   *
   * 创建tag为'loader'的logger对象
   * 该logger对象打出的日志会带有'loader'这个tag
   * const logger = Logger('loader');
   *
   * logger.log('xxx')
   * logger.info('yyy')
   * logger.warn('zzz')
   * logger.error('www')
   *
   * 上述logger对象可以继续链式创建下一个logger对象
   * 这样会打出的日志会带有'context'和'loader'两个tag
   * const contextLogger = logger('context')
   * contextLogger.log('aaa')
   * contextLogger.log('bbb')
   *
   *
   * 可以设置全局日志过滤器，这样仅带有某些tag的日志会输出到控制台
   * Logger.filter = 'loader';
   *
   * 还可以设置全局日志级别过滤，这样仅高于该级别的日志会输出到控制台
   * 其中打印方法对应的日志级别是：.log = 0; .info = 1; .warn = 2; .error = 3
   * Logger.level = 0;
   * @export
   */
  interface LoggerEntrance extends LoggerInstance {
    /**
     * 日志全局设置
     * 级别
     * 高于该级别的日志才会在vconsole出现
     *
     * @static
     * @type {number}
     * @memberof Logger
     */
    level: number;
    /**
     * 过滤器
     * tag满足这个过滤器的日志才会输出到控制台
     *
     * @static
     * @type {number}
     * @memberof Logger
     */
    filter: {
      add(tag: string): void;
      remove(tag: string): void;
    };
    /**
     * 输出器
     * 设定了这个值之后，日志会在这个函数被丢出来，然后外部可以拿到日志内容用作上传
     *
     *
     */
    output: (texts: string[]) => void;
  }
}
declare module "engine/misc/type" {
  export function IsFunction(obj: any): obj is Function;
  export function IsObject(obj: any): obj is object;
  export function IsString(obj: any): obj is string;
  export function IsNumber(obj: any): obj is number;
  export function IsBoolean(obj: any): obj is boolean;
  export function IsUndefined(obj: any): obj is undefined;
  export function hasOwnProperty(target: any, key: string): boolean;
  export function isPrimitiveValue(target: any): boolean;
}
declare module "engine/globalContext" {
  interface IContextType {
    GFX: wgfx.RenderingContext;
    GARD: wxGA.Renderer;
    GAL: wxGA.LogicAccelerator;
  }
  const gctx: IContextType;
  export function initGlobalContextByCanvas(canvas: HTMLCanvasElement, antialias: boolean, ignore_assert: boolean, disable_log: boolean): void;
  export default gctx;
}
declare module "engine/math/utils" {
  export function arcTanAngle(x: number, y: number): number;
  export function isPowOf2(num: number): boolean;
  export function nearEqual(a: number, b: number): boolean;
  export function mathClamp(val: number, min: number, max: number): number;
  export const mathHelper: {
    arcTanAngle: typeof arcTanAngle;
    isPowOf2: typeof isPowOf2;
    nearEqual: typeof nearEqual;
    mathClamp: typeof mathClamp;
  };
  export const v2Helper: {
    equal: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => boolean;
    add: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    sub: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    length: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => number;
    normalize: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, dst: Float32Array, dsto: number) => void;
    scale: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, f: number, dst: Float32Array, dsto: number) => void;
    lerp: (
      a: import("engine/type").DeepImmutableObject<Float32Array>,
      ao: number,
      b: import("engine/type").DeepImmutableObject<Float32Array>,
      bo: number,
      f: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    dot: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => number;
    isZero: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => boolean;
    getAngle: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => number;
    distance: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => number;
    copy(v: import("engine/type").DeepImmutableObject<Float32Array>, vo: number, dst: Float32Array, dsto: number): void;
  };
  export const v3Helper: {
    equal: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => boolean;
    add: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    sub: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    length: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => number;
    normalize: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, dst: Float32Array, dsto: number) => void;
    scale: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, f: number, dst: Float32Array, dsto: number) => void;
    lerp: (
      a: import("engine/type").DeepImmutableObject<Float32Array>,
      ao: number,
      b: import("engine/type").DeepImmutableObject<Float32Array>,
      bo: number,
      f: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    dot: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => number;
    isZero: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => boolean;
    cross: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    distance: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => number;
    angleTo: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    copy(v: import("engine/type").DeepImmutableObject<Float32Array>, vo: number, dst: Float32Array, dsto: number): void;
  };
  export const v4Helper: {
    equal: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => boolean;
    add: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    sub: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number, dst: Float32Array, dsto: number) => void;
    scale: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, f: number, dst: Float32Array, dsto: number) => void;
    lerp: (
      a: import("engine/type").DeepImmutableObject<Float32Array>,
      ao: number,
      b: import("engine/type").DeepImmutableObject<Float32Array>,
      bo: number,
      f: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    dot: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, b: import("engine/type").DeepImmutableObject<Float32Array>, bo: number) => number;
    isZero: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number) => boolean;
    copy(v: import("engine/type").DeepImmutableObject<Float32Array>, vo: number, dst: Float32Array, dsto: number): void;
  };
  export const quatHelper: {
    multiply: (l: import("engine/type").DeepImmutableObject<Float32Array>, lo: number, r: import("engine/type").DeepImmutableObject<Float32Array>, ro: number, dst: Float32Array, dsto: number) => void;
    invert: (a: import("engine/type").DeepImmutableObject<Float32Array>, ao: number, dst: Float32Array, dsto: number) => void;
    toMatrix4: (quat: import("engine/type").DeepImmutableObject<Float32Array>, quato: number, dst: Float32Array, dsto: number) => void;
    fromMatrix4: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number) => void;
    fromEulerAngles: (v: import("engine/type").DeepImmutableObject<Float32Array>, vo: number, dst: Float32Array, dsto: number) => void;
    fromYawRawPitch: (yaw: number, pitch: number, roll: number, dst: Float32Array, dsto: number) => void;
    toEulerAngles: (quat: Float32Array, quato: number, dst: Float32Array, dsto: number) => void;
    toYawRawPitch: (quat: import("engine/type").DeepImmutableObject<Float32Array>, quato: number, dst: Float32Array, dsto: number) => void;
    slerp: (
      l: import("engine/type").DeepImmutableObject<Float32Array>,
      lo: number,
      r: import("engine/type").DeepImmutableObject<Float32Array>,
      ro: number,
      t: number,
      dst: Float32Array,
      dsto: number,
    ) => Float32Array;
    transformDirection: (
      quat: import("engine/type").DeepImmutableObject<Float32Array>,
      quato: number,
      v: import("engine/type").DeepImmutableObject<Float32Array>,
      vo: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
  };
  export const m3Helper: {
    translate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, tx: number, ty: number, dst: Float32Array, dsto: number) => void;
    scale: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, sx: number, sy: number, dst: Float32Array, dsto: number) => void;
    rotate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, rz: number, dst: Float32Array, dsto: number) => void;
    inverse(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
    multiply: (
      mA: import("engine/type").DeepImmutableObject<Float32Array>,
      mAo: number,
      mB: import("engine/type").DeepImmutableObject<Float32Array>,
      mBo: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    transformPoint(
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      v: import("engine/type").DeepImmutableObject<Float32Array>,
      vo: number,
      dst: Float32Array,
      dsto: number,
    ): void;
    decomposeScale(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
    copy(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
  };
  export const m4Helper: {
    lookAt: (
      position: import("engine/type").DeepImmutableObject<Float32Array>,
      positionOffset: number,
      target: import("engine/type").DeepImmutableObject<Float32Array>,
      targetOffset: number,
      up: import("engine/type").DeepImmutableObject<Float32Array>,
      upOffset: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    perspective: (fieldOfViewRadians: number, aspect: number, near: number, far: number, dst: Float32Array, dsto: number) => void;
    orthographic: (left: number, right: number, bottom: number, top: number, near: number, far: number, dst: Float32Array, dsto: number) => void;
    xRotation(rad: number, dst: Float32Array, dsto: number): void;
    yRotation(rad: number, dst: Float32Array, dsto: number): void;
    zRotation(rad: number, dst: Float32Array, dsto: number): void;
    axisRotation(axis: import("engine/type").DeepImmutableObject<Float32Array>, axiso: number, angleInRadians: number, dst: Float32Array, dsto: number): Float32Array;
    composeTRS: (
      trans: import("engine/type").DeepImmutableObject<Float32Array>,
      transo: number,
      rot: import("engine/type").DeepImmutableObject<Float32Array>,
      roto: number,
      scale: import("engine/type").DeepImmutableObject<Float32Array>,
      scaleo: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    composeTQS: (
      trans: import("engine/type").DeepImmutableObject<Float32Array>,
      transo: number,
      quat: import("engine/type").DeepImmutableObject<Float32Array>,
      quato: number,
      scale: import("engine/type").DeepImmutableObject<Float32Array>,
      scaleo: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    translate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, tx: number, ty: number, tz: number, dst: Float32Array, dsto: number) => void;
    scale: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, sx: number, sy: number, sz: number, dst: Float32Array, dsto: number) => void;
    xRotate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, rx: number, dst: Float32Array, dsto: number) => void;
    yRotate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, ry: number, dst: Float32Array, dsto: number) => void;
    zRotate: (m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, rz: number, dst: Float32Array, dsto: number) => void;
    axisRotate: (
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      axis: import("engine/type").DeepImmutableObject<Float32Array>,
      axiso: number,
      angleInRadians: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    multiply: (
      mA: import("engine/type").DeepImmutableObject<Float32Array>,
      mAo: number,
      mB: import("engine/type").DeepImmutableObject<Float32Array>,
      mBo: number,
      dst: Float32Array,
      dsto: number,
    ) => void;
    transformVector(
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      v: import("engine/type").DeepImmutableObject<Float32Array>,
      vo: number,
      dst: Float32Array,
      dsto: number,
    ): void;
    transformDirection(
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      v: import("engine/type").DeepImmutableObject<Float32Array>,
      vo: number,
      dst: Float32Array,
      dsto: number,
    ): void;
    transformPoint(
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      v: import("engine/type").DeepImmutableObject<Float32Array>,
      vo: number,
      dst: Float32Array,
      dsto: number,
    ): void;
    decomposeTransRotMatScale(
      m: import("engine/type").DeepImmutableObject<Float32Array>,
      mo: number,
      trans: Float32Array,
      transo: number,
      rot: Float32Array,
      roto: number,
      scale: Float32Array,
      scaleo: number,
    ): boolean;
    inverse(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
    transpose(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
    composeRST3toRST4(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
    copy(m: import("engine/type").DeepImmutableObject<Float32Array>, mo: number, dst: Float32Array, dsto: number): void;
  };
}
declare module "engine/math/color" {
  export enum BlendType {
    Alpha = 0,
    RGB = 1,
    RGBA = 2,
    None = 3,
  }
  /**
   * @public
   */
  export default class Color {
    get r(): number;
    set r(val: number);
    get g(): number;
    set g(val: number);
    get b(): number;
    set b(val: number);
    get a(): number;
    set a(val: number);
    static BlendType: typeof BlendType;
    static get WHITE(): Color;
    static get BLACK(): Color;
    constructor(r?: number, g?: number, b?: number, a?: number);
    static blendColorHex(colorHexA: number, colorHexB: number, type?: BlendType): number;
    static getValue32FromRGBA(r: number, g: number, b: number, a: number): number;
    static randomMix(colorHexA: number, colorHexB: number): number;
    static fromHex(hex: number): Color;
    static fromFloatArray(arr: number[]): Color;
    clone(): Color;
    equals(target: Color): boolean;
    set(val: Color): void;
    setRGBA(r: number, g: number, b: number, a: number): void;
    setValue32(v32: number): void;
    toNormalizedArray(): number[];
    toRGBAString(): string;
    mix(color: Color, dst?: Color): Color;
  }
}
declare module "engine/math/vector2" {
  import { V2ReadOnly } from "engine/math/types";
  /**
   * @public
   */
  export default class Vector2 {
    /**
     * x值
     *
     * @type {number}
     * @memberof Vector2
     */
    get x(): number;
    set x(val: number);
    /**
     * y值
     *
     * @type {number}
     * @memberof Vector2
     */
    get y(): number;
    set y(val: number);
    /**
     * 零向量，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ZERO: V2ReadOnly;
    /**
     * 一向量，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ONE: V2ReadOnly;
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 使用数值创建
     * 推荐使用这种方式代替new Vector2
     *
     * @static
     * @param {number} x x
     * @param {number} y y
     * @returns {Vector2} 创建出来的向量
     * @memberof Vector2
     */
    static createFromNumber(x: number, y: number): Vector2;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为2，否则会抛出异常
     * @returns {Vector2} 创建出来的向量
     * @memberof Vector2
     */
    static createFromArray(array: number[]): Vector2;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Vector2} 创建出来的向量
     * @memberof Vector2
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Vector2;
    /**
     * 返回向量数据
     *
     * @returns {number[]} 矩阵数据，以JSArray返回
     * @memberof Vector2
     */
    toArray(): number[];
    /**
     * 判断与目标向量的值是否相等
     *
     * @param {V2ReadOnly} v 目标向量
     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
     * @memberof Vector2
     */
    equal(v: V2ReadOnly): boolean;
    /**
     * 拷贝目标向量的值到该向量
     *
     * @param {V2ReadOnly} val 目标向量
     * @returns {Vector2} 自身
     * @memberof Vector2
     */
    set(val: V2ReadOnly): Vector2;
    /**
     * 设置向量的值
     *
     * @param {number} x x值
     * @param {number} y y值
     * @returns {Vector2} 自身
     * @memberof Vector2
     */
    setValue(x: number, y: number): Vector2;
    /**
     * 向量加法
     *
     * @param {V2ReadOnly} v 目标向量
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Vector2
     */
    add(v: V2ReadOnly, dst?: Vector2): Vector2;
    /**
     * 向量减法
     *
     * @param {V2ReadOnly} v 目标向量
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Vector2
     */
    sub(v: V2ReadOnly, dst?: Vector2): Vector2;
    /**
     * 向量归一化，如该向量为零向量，则结果依然为零向量
     *
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Vector2
     */
    normalize(dst?: Vector2): Vector2;
    /**
     * 向量缩放
     *
     * @param {number} f 缩放比
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Vector2
     */
    scale(f: number, dst?: Vector2): Vector2;
    /**
     * 在该向量与目标向量之间计算插值
     *
     * @param {V2ReadOnly} v 目标向量
     * @param {number} f 插值系数
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Vector2
     */
    lerp(v: V2ReadOnly, f: number, dst?: Vector2): Vector2;
    /**
     * 向量点乘
     *
     * @param {V2ReadOnly} v 目标向量
     * @returns {number} 计算结果
     * @memberof Vector2
     */
    dot(v: V2ReadOnly): number;
    /**
     * 向量的模
     *
     * @returns {number} 计算结果
     * @memberof Vector2
     */
    length(): number;
    /**
     * 拷贝该向量
     *
     * @returns {Vector2} 拷贝出来的对象
     * @memberof Vector2
     */
    clone(): Vector2;
    /**
     * 是否为零向量
     *
     * @returns {boolean}
     * @memberof Vector2
     */
    isZero(): boolean;
    /**
     * 获取向量旋转角，以角度表示
     *
     * @returns {number} 旋转角，以角度表示
     * @memberof Vector2
     */
    getAngle(): number;
  }
}
declare module "engine/math/vector4" {
  import { V4ReadOnly } from "engine/math/types";
  export default class Vector4 {
    /**
     * x值
     *
     * @type {number}
     * @memberof Vector4
     */
    get x(): number;
    set x(val: number);
    /**
     * y值
     *
     * @type {number}
     * @memberof Vector4
     */
    get y(): number;
    set y(val: number);
    /**
     * z值
     *
     * @type {number}
     * @memberof Vector4
     */
    get z(): number;
    set z(val: number);
    /**
     * w值
     *
     * @type {number}
     * @memberof Vector4
     */
    get w(): number;
    set w(val: number);
    /**
     * 零向量，不要对该对象进行修改
     *
     * @static
     * @readonly
     * @type {V4ReadOnly}
     * @memberof Vector4
     */
    static readonly ZERO: V4ReadOnly;
    /**
     * 一向量，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ONE: V4ReadOnly;
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 使用数值创建
     * 推荐使用这种方式代替new Vector4
     *
     * @static
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4} 创建出来的向量
     * @memberof Vector4
     */
    static createFromNumber(x: number, y: number, z: number, w: number): Vector4;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为4，否则会抛出异常
     * @returns {Vector4} 创建出来的向量
     * @memberof Vector4
     */
    static createFromArray(array: number[]): Vector4;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Vector4}
     * @memberof Vector4
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Vector4;
    /**
     * 返回向量数据
     *
     * @returns {number[]} 矩阵数据，以JSArray返回
     * @memberof Vector4
     */
    toArray(): number[];
    /**
     * 判断与目标向量的值是否相等
     *
     * @param {V4ReadOnly} v 目标向量
     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
     * @memberof Vector4
     */
    equal(v: V4ReadOnly): boolean;
    /**
     * 拷贝目标向量的值到该向量
     *
     * @param {V4ReadOnly} val 目标向量
     * @returns {Vector4} 自身
     * @memberof Vector4
     */
    set(v: V4ReadOnly): Vector4;
    /**
     * 设置向量的值
     *
     * @param {number} x x值
     * @param {number} y y值
     * @param {number} z z值
     * @param {number} w w值
     * @returns {Vector4} 自身
     * @memberof Vector4
     */
    setValue(x: number, y: number, z: number, w: number): Vector4;
    /**
     * 向量加法
     *
     * @param {V4ReadOnly} v 目标向量
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 计算结果
     * @memberof Vector4
     */
    add(v: V4ReadOnly, dst?: Vector4): Vector4;
    /**
     * 向量减法
     *
     * @param {V4ReadOnly} v 目标向量
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 计算结果
     * @memberof Vector4
     */
    sub(v: V4ReadOnly, dst?: Vector4): Vector4;
    /**
     * 向量缩放
     *
     * @param {number} f 缩放比
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 计算结果
     * @memberof Vector4
     */
    scale(f: number, dst?: Vector4): Vector4;
    /**
     * 在该向量与目标向量之间计算插值
     *
     * @param {V4ReadOnly} v 目标向量
     * @param {number} f 插值系数
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 计算结果
     * @memberof Vector4
     */
    lerp(v: V4ReadOnly, f: number, dst?: Vector4): Vector4;
    /**
     * 向量点乘
     *
     * @param {V4ReadOnly} v 目标向量
     * @returns {number} 计算结果
     * @memberof Vector4
     */
    dot(v: V4ReadOnly): number;
    /**
     * 是否为零向量
     *
     * @returns {boolean}
     * @memberof Vector4
     */
    isZero(): boolean;
    /**
     * 拷贝该向量
     *
     * @returns {Vector4} 拷贝出来的对象
     * @memberof Vector4
     */
    clone(): Vector4;
  }
}
declare module "engine/math/matrix3" {
  import Vector2 from "engine/math/vector2";
  import { M3ReadOnly, V2ReadOnly } from "engine/math/types";
  export default class Matrix3 {
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 单位矩阵
     *
     * @readonly
     * @static
     * @returns {Matrix3} 单位矩阵，每次返回都会创建新的对象
     * @memberof Matrix3
     */
    static get IDENTITY(): Matrix3;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为9，否则会抛出异常
     * @returns {Matrix3} 创建出来的矩阵
     * @memberof Matrix3
     */
    static createFromArray(array: number[]): Matrix3;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Matrix3} 创建出来的矩阵
     * @memberof Matrix3
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Matrix3;
    /**
     * 返回矩阵数据
     *
     * @returns {number[]} 矩阵数据，以JSArray返回
     * @memberof Matrix3
     */
    toArray(): number[];
    /**
     * 将该矩阵进行位移变换
     *
     * @param {number} tx x轴位移
     * @param {number} ty y轴位移
     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix3} 计算结果
     * @memberof Matrix3
     */
    translate(tx: number, ty: number, dst?: Matrix3): Matrix3;
    /**
     * 将该矩阵进行缩放变换
     *
     * @param {number} sx x轴缩放
     * @param {number} sy y轴缩放
     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix3} 计算结果
     * @memberof Matrix3
     */
    scale(sx: number, sy: number, dst?: Matrix3): Matrix3;
    /**
     * 将该矩阵进行旋转变换
     *
     * @param {number} radians 旋转幅度，用弧度表示
     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix3} 计算结果
     * @memberof Matrix3
     */
    rotate(radians: number, dst?: Matrix3): Matrix3;
    /**
     * 求该矩阵的逆
     *
     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix3} 计算结果
     * @memberof Matrix3
     */
    inverse(dst?: Matrix3): Matrix3;
    /**
     * 将该矩阵与另一个矩阵相乘
     *
     * @param {Matrix3} m 右乘矩阵
     * @param {Matrix3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix3} 计算结果
     * @memberof Matrix3
     */
    multiply(m: M3ReadOnly, dst?: Matrix3): Matrix3;
    /**
     * 矩阵变换作用于点
     *
     * @param {Vector2} v 点
     * @param {Vector2} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector2} 计算结果
     * @memberof Matrix3
     */
    transformPoint(v: V2ReadOnly, dst?: Vector2): Vector2;
  }
}
declare module "engine/math/boundBall" {
  import Vector3 from "engine/math/vector3";
  import { V3ReadOnly } from "engine/math/types";
  export default class BoundBall {
    static readonly OFFSETS: Readonly<{
      center: number;
      radius: number;
    }>;
    /**
     * 包围球中心
     *
     * @type {V3ReadOnly}
     * @memberof BoundBall
     */
    get center(): V3ReadOnly;
    set center(val: V3ReadOnly);
    /**
     * 包围球半径
     *
     * @type {number}
     * @memberof BoundBall
     */
    get radius(): number;
    set radius(val: number);
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 使用中心和半径创建包围球
     *
     * @static
     * @param {V3ReadOnly} center
     * @param {number} radius
     * @returns {BoundBall}
     * @memberof BoundBall
     */
    static createFromCenterAndRadius(center: V3ReadOnly, radius: number): BoundBall;
    /**
     * 设置值
     *
     * @param {V3ReadOnly} center
     * @param {number} radius
     * @returns {BoundBall}
     * @memberof BoundBall
     */
    setValue(center: V3ReadOnly, radius: number): BoundBall;
    /**
     * 使用一系列点初始化
     *
     * @param {V3ReadOnly[]} points
     * @returns {BoundBall} 自身
     * @memberof BoundBall
     */
    initByPoints(points: V3ReadOnly[]): BoundBall;
  }
}
declare module "engine/math/boundBox" {
  import Vector3 from "engine/math/vector3";
  import { V3ReadOnly } from "engine/math/types";
  export default class BoundBox {
    static readonly OFFSETS: Readonly<{
      center: number;
      size: number;
    }>;
    /**
     * 包围盒中心
     *
     * @type {Vector3}
     * @memberof BoundBox
     */
    get center(): V3ReadOnly;
    set center(val: V3ReadOnly);
    /**
     * 包围盒尺寸
     *
     * @memberof BoundBox
     */
    get size(): V3ReadOnly;
    set size(val: V3ReadOnly);
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 使用中心和尺寸创建包围球
     *
     * @static
     * @param {V3ReadOnly} center 中心
     * @param {V3ReadOnly} size 尺寸
     * @returns {BoundBall}
     * @memberof BoundBall
     */
    static createFromCenterAndSize(center: V3ReadOnly, size: V3ReadOnly): BoundBox;
    /**
     * 设置值
     *
     * @param {V3ReadOnly} center
     * @param {V3ReadOnly} size
     * @returns {BoundBox}
     * @memberof BoundBox
     */
    setValue(center: V3ReadOnly, size: V3ReadOnly): BoundBox;
    initByPoints(points: Vector3[], length?: number): void;
  }
}
declare module "engine/math/types" {
  import { DeepImmutable } from "engine/type";
  type Vector2 = import("engine/math/vector2").default;
  type Vector3 = import("engine/math/vector3").default;
  type Vector4 = import("engine/math/vector4").default;
  type Quaternion = import("engine/math/quaternion").default;
  type Matrix3 = import("engine/math/matrix3").default;
  type Matrix4 = import("engine/math/matrix4").default;
  type BoundBall = import("engine/math/boundBall").default;
  type BoundBox = import("engine/math/boundBox").default;
  export type V2ReadOnly = DeepImmutable<Vector2>;
  export type V3ReadOnly = DeepImmutable<Vector3>;
  export type V4ReadOnly = DeepImmutable<Vector4>;
  export type QuatReadOnly = DeepImmutable<Quaternion>;
  export type M3ReadOnly = DeepImmutable<Matrix3>;
  export type M4ReadOnly = DeepImmutable<Matrix4>;
  export type BoundBallReadOnly = DeepImmutable<BoundBall>;
  export type BoundBoxReadOnly = DeepImmutable<BoundBox>;
  export {};
}
declare module "engine/math/vector3" {
  import { V3ReadOnly, QuatReadOnly } from "engine/math/types";
  export default class Vector3 {
    /**
     * x值
     *
     * @type {number}
     * @memberof Vector3
     */
    get x(): number;
    set x(val: number);
    /**
     * y值
     *
     * @type {number}
     * @memberof Vector3
     */
    get y(): number;
    set y(val: number);
    /**
     * z值
     *
     * @type {number}
     * @memberof Vector3
     */
    get z(): number;
    set z(val: number);
    /**
     * 零向量，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ZERO: V3ReadOnly;
    /**
     * 一向量，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ONE: V3ReadOnly;
    /**
     * 上方向，不要对该对象进行修改
     *
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly Up: V3ReadOnly;
    /**
     * 前方向，基于左手坐标系，不要对该对象进行修改
     *
     * @static
     * @type {V3ReadOnly}
     * @memberof Vector3
     */
    static readonly ForwardLH: V3ReadOnly;
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 使用数值创建
     * 推荐使用这种方式代替new Vector3
     *
     * @static
     * @param {number} x x
     * @param {number} y y
     * @param {number} z z
     * @returns {Vector3} 创建出来的向量
     * @memberof Vector3
     */
    static createFromNumber(x: number, y: number, z: number): Vector3;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为3，否则会抛出异常
     * @returns {Vector3} 创建出来的向量
     * @memberof Vector3
     */
    static createFromArray(array: number[]): Vector3;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Vector3}
     * @memberof Vector3
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Vector3;
    /**
     * 使用四元数进行向量旋转
     *
     * @static
     * @param {V3ReadOnly} source 源向量
     * @param {QuatReadOnly} rotation 用于旋转的四元数
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    static transformQuat(source: V3ReadOnly, rotation: QuatReadOnly, dst?: Vector3): Vector3;
    /**
     * 返回向量数据
     *
     * @returns {number[]} 矩阵数据，以JSArray返回
     * @memberof Vector3
     */
    toArray(): number[];
    /**
     * 判断与目标向量的值是否相等
     *
     * @param {V3ReadOnly} v 目标向量
     * @returns {boolean} 是否相等，这里误差小于10^-6视为相等
     * @memberof Vector3
     */
    equal(v: V3ReadOnly): boolean;
    /**
     * 拷贝目标向量的值到该向量
     *
     * @param {V3ReadOnly} val 目标向量
     * @returns {Vector3} 自身
     * @memberof Vector3
     */
    set(v: V3ReadOnly): Vector3;
    /**
     * 设置向量的值
     *
     * @param {number} x x
     * @param {number} y y
     * @param {number} z z
     * @returns {Vector3} 自身
     * @memberof Vector3
     */
    setValue(x: number, y: number, z: number): Vector3;
    /**
     * 向量加法
     *
     * @param {V3ReadOnly} v 目标向量
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    add(v: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 向量减法
     *
     * @param {V3ReadOnly} v 目标向量
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    sub(v: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 向量叉乘
     *
     * @param {V3ReadOnly} v 目标向量
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    cross(v: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 向量归一化
     *
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    normalize(dst?: Vector3): Vector3;
    /**
     * 向量缩放
     *
     * @param {number} f 缩放比
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    scale(f: number, dst?: Vector3): Vector3;
    /**
     * 向量缩放
     *
     * @param {number} x x缩放比
     * @param {number} y y缩放比
     * @param {number} z z缩放比
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    scaleXYZ(x: number, y: number, z: number, dst?: Vector3): Vector3;
    /**
     * 在该向量与目标向量之间计算插值
     *
     * @param {V3ReadOnly} v 目标向量
     * @param {number} f 插值系数
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Vector3
     */
    lerp(v: V3ReadOnly, f: number, dst?: Vector3): Vector3;
    /**
     * 向量点乘
     *
     * @param {V3ReadOnly} v 目标向量
     * @returns {number} 计算结果
     * @memberof Vector3
     */
    dot(v: V3ReadOnly): number;
    /**
     * 向量的模
     *
     * @returns {number} 计算结果
     * @memberof Vector3
     */
    length(): number;
    /**
     * 拷贝该向量
     *
     * @returns {Vector3} 拷贝出来的对象
     * @memberof Vector3
     */
    clone(): Vector3;
    /**
     * 是否为零向量
     *
     * @returns {boolean}
     * @memberof Vector3
     */
    isZero(): boolean;
    /**
     * 获取到目标点的距离
     *
     * @param {V3ReadOnly} p 目标点
     * @returns {number} 计算结果
     * @memberof Vector3
     */
    distanceTo(p: V3ReadOnly): number;
    /**
     * 获取到目标点的角度
     *
     * @param {V3ReadOnly} location 目标点
     * @returns {number} 计算结果
     * @memberof Vector3
     */
    angleTo(location: V3ReadOnly, dst?: Vector3): Vector3;
  }
}
declare module "engine/math/matrix4" {
  import Vector3 from "engine/math/vector3";
  import Vector4 from "engine/math/vector4";
  import { V3ReadOnly, V4ReadOnly, QuatReadOnly, M3ReadOnly, M4ReadOnly } from "engine/math/types";
  /**
   * @public
   */
  export default class Matrix4 {
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 单位矩阵
     *
     * @readonly
     * @static
     * @returns {Matrix4} 单位矩阵，每次返回都会创建新的对象
     * @memberof Matrix4
     */
    static get IDENTITY(): Matrix4;
    /**
     * 构造相机矩阵
     *
     * @static
     * @param {Vector3} position 相机位置
     * @param {Vector3} target 相机目标位置
     * @param {Vector3} up 上方向
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static lookAt(position: V3ReadOnly, target: V3ReadOnly, up: V3ReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 构造透视投影矩阵
     *
     * @static
     * @param {number} fieldOfViewRadians 视野大小，用弧度表示
     * @param {number} aspect 宽高比
     * @param {number} near 近平面
     * @param {number} far 远平面
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static perspective(fieldOfViewRadians: number, aspect: number, near: number, far: number, dst?: Matrix4): Matrix4;
    /**
     * 构造正交投影矩阵
     *
     * @static
     * @param {number} left 左平面
     * @param {number} right 右平面
     * @param {number} bottom 上平面
     * @param {number} top 下平面
     * @param {number} near 近平面
     * @param {number} far 远平面
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static orthographic(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: Matrix4): Matrix4;
    /**
     * 将四元数转换为旋转矩阵
     *
     * @static
     * @param {Quaternion} quat 四元数
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static fromQuaternion(quat: QuatReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为16，否则会抛出异常
     * @returns {Matrix4} 创建出来的矩阵
     * @memberof Matrix4
     */
    static createFromArray(array: number[]): Matrix4;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Matrix4} 创建出来的矩阵
     * @memberof Matrix4
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Matrix4;
    /**
     * 创建绕X轴旋转的矩阵
     *
     * @static
     * @param {number} rad 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static createRotationX(rad: number, dst?: Matrix4): Matrix4;
    /**
     * 创建绕Y轴旋转的矩阵
     *
     * @static
     * @param {number} rad 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static createRotationY(rad: number, dst?: Matrix4): Matrix4;
    /**
     * 创建绕Z轴旋转的矩阵
     *
     * @static
     * @param {number} rad 旋转轴
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static createRotationZ(rad: number, dst?: Matrix4): Matrix4;
    /**
     * 创建绕指定轴旋转的矩阵
     *
     * @static
     * @param {Vector3} axis 旋转轴
     * @param {number} angleInRadians 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static createRotationAxis(axis: V3ReadOnly, angleInRadians: number, dst?: Matrix4): Matrix4;
    /**
     * 将位移旋转缩放合成一个RST矩阵，旋转用矩阵表示
     *
     * @static
     * @param {V3ReadOnly} translation 位移向量
     * @param {M4ReadOnly} rotation 旋转矩阵
     * @param {V3ReadOnly} scale 缩放向量
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static composeTRS(translation: V3ReadOnly, rotation: M4ReadOnly, scale: V3ReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 将位移旋转缩放合成一个RST矩阵，旋转用四元数表示
     *
     * @static
     * @param {V3ReadOnly} translation 位移向量
     * @param {QuatReadOnly} rotation 旋转四元数
     * @param {V3ReadOnly} scale 缩放向量
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static composeTQS(translation: V3ReadOnly, rotation: QuatReadOnly, scale: V3ReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 从二维RST矩阵扩展到三维RST矩阵
     *
     * @static
     * @param {Matrix3} m3 二维RST矩阵
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    static composeFromRST3(m3: M3ReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 返回矩阵数据
     *
     * @returns {number[]} 矩阵数据，以JSArray返回
     * @memberof Matrix4
     */
    toArray(): number[];
    /**
     * 将该矩阵进行位移变换
     *
     * @param {number} tx x轴位移
     * @param {number} ty y轴位移
     * @param {number} tz z轴位移
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    translate(tx: number, ty: number, tz: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵进行缩放变换
     *
     * @param {number} sx x轴缩放
     * @param {number} sy y轴缩放
     * @param {number} sz z轴缩放
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    scale(sx: number, sy: number, sz: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵绕x轴旋转
     *
     * @param {number} rx 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    xRotate(rx: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵绕y轴旋转
     *
     * @param {number} ry 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    yRotate(ry: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵绕z轴旋转
     *
     * @param {number} rz 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    zRotate(rz: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵绕指定轴旋转
     *
     * @param {Vector3} axis 轴向量
     * @param {number} angleInRadians 旋转幅度，用弧度表示
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    axisRotate(axis: V3ReadOnly, angleInRadians: number, dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵使用指定四元数旋转
     *
     * @param {Quaternion} quaternion 四元数
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    rotateByQuaternion(quaternion: QuatReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 求该矩阵的逆
     *
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    inverse(dst?: Matrix4): Matrix4;
    /**
     * 求该矩阵的转置
     *
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    transpose(dst?: Matrix4): Matrix4;
    /**
     * 将该矩阵与另一个矩阵相乘
     *
     * @param {Matrix4} m 右乘矩阵
     * @param {Matrix4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Matrix4} 计算结果
     * @memberof Matrix4
     */
    multiply(m: M4ReadOnly, dst?: Matrix4): Matrix4;
    /**
     * 矩阵变换作用于向量
     *
     * @param {Vector4} v 向量
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 计算结果
     * @memberof Matrix4
     */
    transformVector(v: V4ReadOnly, dst?: Vector4): Vector4;
    /**
     * 矩阵变换作用于方向
     *
     * @param {Vector3} dir 方向
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Matrix4
     */
    transformDirection(dir: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 矩阵变换作用于点
     *
     * @param {Vector3} p 点
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Matrix4
     */
    transformPoint(p: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 拷贝目标矩阵的值到该矩阵
     *
     * @param {M4ReadOnly} val 目标
     * @returns {Matrix4} 自身
     * @memberof Matrix4
     */
    set(val: M4ReadOnly): Matrix4;
    /**
     * 拷贝该矩阵
     *
     * @returns {Matrix4} 拷贝出来的对象
     * @memberof Matrix4
     */
    clone(): Matrix4;
    /**
     * 分解RTS矩阵为位移、旋转、缩放向量，返回是否成功
     *
     * @param {Vector3} dstTranslation 目标位移向量
     * @param {Matrix4} dstRotationMatrix 目标旋转矩阵
     * @param {Vector3} dstScale 目标缩放分量
     * @returns {boolean} 分解是否成功，如不成功，可能是缩放分量为0
     * @memberof Matrix4
     */
    decomposeTransRotMatScale(dstTranslation: Vector3, dstRotationMatrix: Matrix4, dstScale: Vector3): boolean;
    /**
     * 设置该矩阵某行某列的值
     *
     * @param {number} value 值
     * @param {number} column 列数
     * @param {number} row 行数
     * @returns {Matrix4} 自身
     * @memberof Matrix4
     */
    setValue(value: number, column: number, row: number): Matrix4;
    /**
     * 获取矩阵某行某列的值
     *
     *
     * @param {number} column 列数
     * @param {number} row 行数
     * @returns {number} 自身
     * @memberof Matrix4
     */
    getValue(column: number, row: number): number;
    /**
     * 设置矩阵某列
     *
     * @param {V4ReadOnly} vec 列向量
     * @param {number} column 列数
     * @returns {Matrix4} 自身
     * @memberof Matrix4
     */
    setColumn(vec: V4ReadOnly, column: number): Matrix4;
    /**
     * 获取矩阵某列
     *
     * @param {number} column 列数
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 该列数据
     * @memberof Matrix4
     */
    getColumn(column: number, dst?: Vector4): Vector4;
    /**
     * 设置矩阵某行
     *
     * @param {V4ReadOnly} vec 行向量
     * @param {number} row 行数
     * @returns {Matrix4} 自身
     * @memberof Matrix4
     */
    setRow(vec: V4ReadOnly, row: number): Matrix4;
    /**
     * 获取矩阵某行
     *
     * @param {number} row 行数
     * @param {Vector4} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector4} 该行数据
     * @memberof Matrix4
     */
    getRow(row: number, dst?: Vector4): Vector4;
  }
}
declare module "engine/math/quaternion" {
  import Vector3 from "engine/math/vector3";
  import { V3ReadOnly, QuatReadOnly, M4ReadOnly } from "engine/math/types";
  /**
   * @public
   */
  export default class Quaternion {
    /**
     * x值
     *
     * @type {number}
     * @memberof Quaternion
     */
    get x(): number;
    set x(val: number);
    /**
     * y值
     *
     * @type {number}
     * @memberof Quaternion
     */
    get y(): number;
    set y(val: number);
    /**
     * z值
     *
     * @type {number}
     * @memberof Quaternion
     */
    get z(): number;
    set z(val: number);
    /**
     * w值
     *
     * @type {number}
     * @memberof Quaternion
     */
    get w(): number;
    set w(val: number);
    /**
     * 默认四元数，不要对该对象进行修改
     *
     * @readonly
     * @static
     * @type {QuatReadOnly}
     * @memberof Quaternion
     */
    static readonly DEFAULT: QuatReadOnly;
    constructor(raw?: Float32Array, offset?: number);
    /**
     * 从欧拉角创建四元数
     *
     * @static
     * @param {Vector3} euler 欧拉角，x代表pitch，y代表yaw，z代表roll
     * @param {Quaternion} [dst]
     * @returns {Quaternion}
     * @memberof Quaternion
     */
    static fromEulerAngles(euler: V3ReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 从旋转矩阵创建
     *
     * @static
     * @param {Matrix4} mat
     * @param {Quaternion} [dst]
     * @returns {Quaternion}
     * @memberof Quaternion
     */
    static createFromMatrix4(mat: M4ReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 从轴向旋转创建
     *
     * @static
     * @param {V3ReadOnly} axis 旋转轴
     * @param {number} rad 旋转幅度
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    static createFromAxisAngle(axis: V3ReadOnly, rad: number, dst?: Quaternion): Quaternion;
    /**
     * 由视角方向创建四元数
     *
     * @static
     * @param {V3ReadOnly} forward 前方向
     * @param {V3ReadOnly} up 上方向
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    static lookRotation(forward: V3ReadOnly, up: V3ReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 使用数值创建
     *
     * @static
     * @param {number} x x
     * @param {number} y y
     * @param {number} z z
     * @param {number} w w
     * @returns {Quaternion} 创建出来的四元数
     * @memberof Quaternion
     */
    static createFromNumber(x: number, y: number, z: number, w: number): Quaternion;
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array 数据源，长度必须为4，否则会抛出异常
     * @returns {Quaternion}
     * @memberof Quaternion
     */
    static createFromArray(array: number[]): Quaternion;
    /**
     * 使用某个已有的typedArray创建
     * 此操作不会拷贝数据，而是在原来的内存区域上操作
     *
     * @static
     * @param {Float32Array} array 数据源
     * @param {number} [offset=0] 数据源中的偏移
     * @returns {Quaternion}
     * @memberof Quaternion
     */
    static createFromTypedArray(array: Float32Array, offset?: number): Quaternion;
    /**
     * 拷贝目标四元数的值到自身
     *
     * @param {Quaternion} quat 目标四元数
     * @returns {Quaternion} 自身
     * @memberof Quaternion
     */
    set(quat: Quaternion): Quaternion;
    /**
     * 设置四元数的值
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Quaternion} 自身
     * @memberof Quaternion
     */
    setValue(x: number, y: number, z: number, w: number): Quaternion;
    /**
     * 球面插值
     *
     * @param {Quaternion} right 目标四元数
     * @param {number} t 插值系数，越接近 1 则结果越接近目标
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    slerp(right: QuatReadOnly, t: number, dst?: Quaternion): Quaternion;
    /**
     * 四元数反转
     *
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    invert(dst?: Quaternion): Quaternion;
    /**
     * 四元数相加
     *
     * @param {Quaternion} quat 目标四元数
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    add(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 四元数相减
     *
     * @param {Quaternion} quat 目标四元数
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    sub(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 四元数相乘
     *
     * @param {Quaternion} quat 目标四元数
     * @param {Quaternion} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Quaternion} 计算结果
     * @memberof Quaternion
     */
    multiply(quat: QuatReadOnly, dst?: Quaternion): Quaternion;
    /**
     * 拷贝四元数
     *
     * @returns {Quaternion} 拷贝后的对象
     * @memberof Quaternion
     */
    clone(): Quaternion;
    /**
     * 四元数是否为默认四元数（表示零旋转）
     *
     * @returns {boolean}
     * @memberof Quaternion
     */
    isDefault(): boolean;
    /**
     * 将该四元数转换成欧拉角，x代表Pitch,y代表Yaw,z代表Roll
     * 旋转的顺序为YXZ
     *
     * @param {Vector3} [dst] 计算结果输出到的目标对象，如不传则新建一个
     * @returns {Vector3} 计算结果
     * @memberof Quaternion
     */
    toEulerAngles(dst?: Vector3): Vector3;
    /**
     * 判断与目标四元数的值是否相等
     *
     * @param {QuatReadOnly} quat 目标四元数
     * @returns {boolean}
     * @memberof Quaternion
     */
    equal(quat: QuatReadOnly): boolean;
  }
}
declare module "engine/math/helper" {
  import Color from "engine/math/color";
  import Quaternion from "engine/math/quaternion";
  import Vector2 from "engine/math/vector2";
  import Vector3 from "engine/math/vector3";
  import Vector4 from "engine/math/vector4";
  import BoundBall from "engine/math/boundBall";
  import { V3ReadOnly } from "engine/math/types";
  export type DirtyCallback = () => void;
  export class Color_N extends Color {
    get r(): number;
    set r(val: number);
    get g(): number;
    set g(val: number);
    get b(): number;
    set b(val: number);
    get a(): number;
    set a(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, value?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Color
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {Color}
     * @memberof Color_N
     */
    static createWithDirtyCallback(value: number, dirtyCb: DirtyCallback, target: any): Color_N;
    set(v: Color): void;
    setValue32(v32: number): void;
  }
  export class Quaternion_N extends Quaternion {
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
    get w(): number;
    set w(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, array?: Float32Array, offset?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Quaternion
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {Quaternion}
     * @memberof Quaternion_N
     */
    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Quaternion_N;
    set(v: Quaternion): this;
    setValue(x: number, y: number, z: number, w: number): this;
  }
  export class Vector4_N extends Vector4 {
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
    get w(): number;
    set w(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, array?: Float32Array, offset?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Vector
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {Vector4}
     * @memberof Vector4_N
     */
    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector4_N;
    set(v: Vector4): this;
    setValue(x: number, y: number, z: number, w: number): this;
  }
  export class Vector3_N extends Vector3 {
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    get z(): number;
    set z(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, array?: Float32Array, offset?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Vector
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {Vector3}
     * @memberof Vector3_N
     */
    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector3_N;
    set(v: Vector3): this;
    setValue(x: number, y: number, z: number): this;
  }
  export class Vector2_N extends Vector2 {
    get x(): number;
    set x(val: number);
    get y(): number;
    set y(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, array?: Float32Array, offset?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Vector
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {Vector2}
     * @memberof Vector2_N
     */
    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): Vector2_N;
    set(v: Vector2): this;
    setValue(x: number, y: number): this;
  }
  export class BoundBall_N extends BoundBall {
    get center(): V3ReadOnly;
    set center(val: V3ReadOnly);
    get radius(): number;
    set radius(val: number);
    constructor(dirtyCb?: DirtyCallback, dirtyCbTarget?: any, array?: Float32Array, offset?: number);
    /**
     * 仅引擎内部使用，创建一个带脏标记的Vector
     *
     * @static
     * @param {Float32Array} array
     * @param {DirtyCallback} dirtyCb
     * @param {Object} target
     * @returns {BoundBall}
     * @memberof BoundBall_N
     */
    static createWithDirtyCallback(array: Float32Array, dirtyCb: DirtyCallback, target: any, offset?: number): BoundBall_N;
    setValue(center: Vector3, radius: number): this;
  }
}
declare module "engine/math/rect" {
  import Vector2 from "engine/math/vector2";
  export default class Rect {
    get xMin(): number;
    set xMin(val: number);
    get yMin(): number;
    set yMin(val: number);
    get width(): number;
    set width(val: number);
    get height(): number;
    set height(val: number);
    get xMax(): number;
    get yMax(): number;
    constructor(xMin?: number, yMin?: number, width?: number, height?: number);
    /**
     * 使用一个数组创建
     * 此操作会拷贝一份数组
     *
     * @static
     * @param {number[]} array
     * @returns {Rect}
     * @memberof Rect
     */
    static createFromArray(array: number[]): Rect;
    getCenter(): Vector2;
    set(rect: Rect): void;
    transformByPositionScale(position: Vector2, scale: Vector2): void;
  }
}
declare module "lib/utils/promise" {
  type ResolveTransfer<T> = (value?: T | PromiseLike<T>) => void;
  type RejectTransfer = (reason?: any) => void;
  type Callback<PromiseT, ThenT> = ((value: PromiseT) => ThenT | PromiseLike<ThenT>) | undefined | null;
  type Executor<T> = (resolve: ResolveTransfer<T>, reject: RejectTransfer) => void;
  enum State {
    Pending = 0,
    Resolved = 1,
    Rejected = 2,
  }
  export default class LitePromise<T> {
    static resolve<T>(value?: T): LitePromise<T>;
    static reject<T = never>(value?: any): LitePromise<T>;
    static race<T>(array: LitePromise<T>[]): LitePromise<T>;
    static all<T>(array: LitePromise<T>[]): LitePromise<T[]>;
    get state(): State;
    resolve: ResolveTransfer<T>;
    reject: RejectTransfer;
    reset: () => void;
    constructor(executor?: Executor<T>);
    then<T1 = T, T2 = never>(onResolved?: Callback<T, T1>, onRejected?: Callback<any, T2>): LitePromise<T1 | T2>;
    catch<T2 = never>(onRejected: Callback<any, T2>): LitePromise<T | T2>;
  }
  export {};
}
declare module "engine/assets/load-contexts/status/enum" {
  export enum ContextAction {
    Load = 0,
    Preload = 1,
    Stop = 2,
  }
  export enum ContextStatus {
    Expired = 0,
    Unloaded = 1,
    ManifestDownloading = 2,
    ManifestDownloaded = 3,
    ManifestReading = 4,
    Manifested = 5,
    FileDownloading = 6,
    FileDownloaded = 7,
    FileReading = 8,
    Loaded = 9,
    Weakening = 10,
    Weak = 11,
  }
}
declare module "engine/error" {
  import { ContextStatus, ContextAction } from "engine/assets/load-contexts/status/enum";
  export enum ErrorCode {
    OK = 0,
    Unexpected = 1,
    LoadFile_Unexpected = 101,
    LoadFile_PathUndefined = 102,
    LoadFile_LoadFontFailed = 103,
    LoadFile_LoadImageFailed = 104,
    LoadFile_JSONParseFailed = 105,
    LoadFile_NotExist = 106,
    LoadFile_UnexpectedData = 107,
    DownloadFile_Unexpected = 201,
    DownloadFile_UnexpectedStatusCode = 202,
    DownloadFile_Aborted = 203,
    DownloadFile_EmptyData = 202,
    LoadContext_Unexpected = 301,
    LoadContext_DownloadManifestFailed = 302,
    LoadContext_ReadManifestFailed = 303,
    LoadContext_DownloadFileFailed = 304,
    LoadContext_ReadFileFailed = 305,
    LoadTask_Aborted = 402,
    LoadTask_LoadDependenciesFailed = 403,
    GetAsset_AssetIDNotRegistered = 502,
    GetAsset_LoadContextNotCreated = 503,
    GetAsset_NotLoaded = 504,
    GetFile_NotLoaded = 510,
    Deserialize_InvalidResource = 522,
    Register_InvalidGroupURL = 602,
    Register_Failed = 603,
    Load_AssetNotRegistered = 613,
    Load_GroupNotRegistered = 614,
    Load_InvalidURL = 615,
    Load_UnexpectedEditorMode = 616,
    Cache_Unexpected = 701,
    Cache_InitFailed = 702,
    Cache_UnexpectedFile = 703,
    Cache_NoEnoughSpace = 704,
    Cache_ReleaseSizeInvalid = 705,
    Cache_EliminateEmpty = 706,
    Cache_RemoveFailed = 707,
    Cache_MaximumSizeExceeded = 710,
  }
  type ErrorDetail = {
    [key: string]: any;
  } | null;
  export class EngineError extends Error {
    code: ErrorCode;
    detail: ErrorDetail;
    constructor(code: ErrorCode, detail: ErrorDetail);
  }
  interface ILoadFileErrorDetail {
    path: string;
    type: string;
    data?: any;
    error?: any;
  }
  interface ILoadContextErrorDetail {
    groupID: string;
    groupIDHash: string;
    url: string;
    error: Error;
  }
  interface ILoadContext_UnexpectedErrorDetail extends ILoadContextErrorDetail {
    status: ContextStatus;
  }
  export class LoadFile_UnexpectedError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_PathUndefinedError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_LoadFontFailedError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_LoadImageFailedError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_JSONParseFailedError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_NotExistError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class LoadFile_UnexpectedDataError extends EngineError {
    constructor(detail: ILoadFileErrorDetail);
  }
  export class DownloadFile_UnexpectedError extends EngineError {
    constructor(detail: { url: string; error: any });
  }
  export class DownloadFile_UnexpectedStatusCodeError extends EngineError {
    constructor(detail: {
      url: string;
      statusCode: number;
      dataLength: number;
      header: {
        [key: string]: string;
      };
    });
  }
  export class DownloadFile_EmptyDataError extends EngineError {
    constructor(detail: {
      url: string;
      statusCode: number;
      dataLength: number;
      header: {
        [key: string]: string;
      };
    });
  }
  export class DownloadFile_AbortedError extends EngineError {
    constructor(detail: { url: string });
  }
  export class LoadContext_DownloadManifestFailedError extends EngineError {
    constructor(detail: ILoadContextErrorDetail);
  }
  export class LoadContext_ReadManifestFailedError extends EngineError {
    constructor(detail: ILoadContextErrorDetail);
  }
  export class LoadContext_DownloadFileFailedError extends EngineError {
    constructor(detail: ILoadContextErrorDetail);
  }
  export class LoadContext_ReadFileFailedError extends EngineError {
    constructor(detail: ILoadContextErrorDetail);
  }
  export class LoadContext_UnexpectedError extends EngineError {
    constructor(detail: ILoadContext_UnexpectedErrorDetail);
  }
  export class LoadTask_AbortedError extends EngineError {
    constructor(detail: { assetID: string; groupID: string });
  }
  export class LoadTask_LoadDependenciesFailedError extends EngineError {
    constructor(detail: { assetID: string; groupID: string; failedDependencies: string[] });
  }
  export class GetAsset_AssetIDNotRegisteredError extends EngineError {
    constructor(detail: { assetID: string });
  }
  export class GetAsset_LoadContextNotCreatedError extends EngineError {
    constructor(detail: { assetID: string; groupID?: string });
  }
  export class GetAsset_NotLoadedError extends EngineError {
    constructor(detail: { assetID: string; groupID?: string; groupIDHash?: string; url?: string; status?: ContextStatus; action?: ContextAction; error?: Error | null });
  }
  export class GetFile_NotLoadedError extends EngineError {
    constructor(detail: { fileID: string; groupID: string; groupIDHash: string; url: string; status: ContextStatus; action: ContextAction; error: Error | null });
  }
  export class Deserialize_InvalidResourceError extends EngineError {
    constructor(detail: { type: string });
  }
  export class Register_InvalidGroupURLError extends EngineError {
    constructor(detail: { groupID: string; url: string });
  }
  export class Register_Failed extends EngineError {
    constructor(detail: { url: string; error: any });
  }
  export class Load_AssetNotRegisteredError extends EngineError {
    constructor(detail: { assetID: string });
  }
  export class Load_GroupNotRegisteredError extends EngineError {
    constructor(detail: { groupID: string });
  }
  export class Load_InvalidURLError extends EngineError {
    constructor(detail: { url: string });
  }
  export class Load_UnexpectedEditorModeError extends EngineError {
    constructor();
  }
  export class Cache_UnexpectedError extends EngineError {
    constructor(detail: { error: any });
  }
  export class Cache_UnexpectedFileError extends EngineError {
    constructor(detail: { path: string });
  }
  export class Cache_InitFailedError extends EngineError {
    constructor(detail: { error: any });
  }
  export class Cache_NoEnoughSpaceError extends EngineError {
    constructor(detail: { currentSize: number; cacheCount: number });
  }
  export class Cache_ReleaseSizeInvalidError extends EngineError {
    constructor(detail: { releaseSize: any });
  }
  export class Cache_EliminateEmptyError extends EngineError {
    constructor(detail: { currentSize: number; cacheCount: number });
  }
  export class Cache_RemoveFailedError extends EngineError {
    constructor(detail: { path: string });
  }
  export class Cache_MaximumSizeExceededError extends EngineError {
    constructor(detail: { currentSize: number; cacheCount: number });
  }
  export {};
}
declare module "engine/misc/delegate" {
  type DelegateHandler<S, E> = (sender: S, eventArgs: E) => any;
  export class Delegate<S, E> {
    add(handler: DelegateHandler<S, E>, clearable?: boolean): void;
    remove(handler: DelegateHandler<S, E>): void;
    invoke(context: S, eventArgs: E): void;
    clear(): void;
    dispose(): void;
  }
  export {};
}
declare module "engine/graphicResource/ResourceCreator" {
  export default class ResourceCreator {
    static createCanvas(): HTMLCanvasElement;
    static createImage(): engineWX.Image;
  }
}
declare module "engine/assets/lib/util" {
  export interface ILoaderOptions {
    useFrameSystem?: boolean;
    preload?: boolean;
    cacheable?: boolean;
    httpRetryCount?: number;
    httpPriority?: number;
  }
  export interface ILoaderFileOptions {
    filetype?: "text" | "json" | "arraybuffer" | "image" | "script" | "font";
    httpRetryCount?: number;
    priority?: number;
    onProgress?: (arg: { done: number; total: number }) => void;
  }
  /**
   * 所有资源的type字段定义
   */
  export enum ResourceType {
    EFFECT = "effect",
    MATERIAL = "material",
    MESH = "mesh",
    PREFAB = "prefab",
    SCENE = "scene",
    TEXTURE2D = "texture2d",
    TEXTURECUBE = "texturecube",
    AVATAR = "avatar",
    ANIMATIONCLIP = "animationclip",
    ANIMATIONCONTROLLER = "animationcontroller",
    SPRITEFRAME = "spriteframe",
    SCRIPT = "script",
    TEXT = "text",
    IMAGE = "image",
    FONT = "font",
  }
  /**
   * 所有资源的文件格式
   * TODO 后续需要兼容一个资源使用多个文件或者无文件的情况，因此需要修改
   */
  export const ResourceFileType: {
    effect: string;
    material: string;
    mesh: string;
    prefab: string;
    scene: string;
    texture2d: string;
    texturecube: string;
    avatar: string;
    animationclip: string;
    animatorcontroller: string;
    resource: string;
    spriteframe: string;
    text: string;
    image: string;
    font: string;
    script: string;
  };
  /**
   * 两个字符串合并并确认中间有/分割
   * @param str1
   * @param str2
   */
  export function joinWithBar(str1: string, str2: string): string;
  export function isAbsoluteURL(url: string): boolean;
  /**
	 required int32 headerlength
	 required int32 filecount
	 repeated
	    int32 start
	    int32 end
	    int32 type  0 json 1 text 2 arraybuffer
	*/
  export function decodeCombinedArrayBufferFile(arrayBuffer: ArrayBuffer, index: number): any;
  export function loadFont(path: string): string | null;
  export function arrayRemove(array: Array<any>, value: any): any[] | null;
  class JSONMap {
    has(key: string): boolean;
  }
  export class ComplexJSONMap<T> extends JSONMap {
    constructor(isString?: boolean);
    add(key: string, data: T): void;
    get(key: string): null | T;
  }
  export class NumberJSONMap extends JSONMap {
    constructor(schema: string[], size?: number);
    set(
      key: string,
      data: {
        [key: string]: number;
      },
    ): void;
    get(
      key: string,
    ): {
      [key: string]: number;
    } | null;
    setProperty(key: string, schemaKey: string, value: number): void;
    getProperty(key: string, schemaKey: string): number | null;
  }
  export {};
}
declare module "engine/assets/lib/load-from-filesystem" {
  import LitePromise from "lib/utils/promise";
  /**
   * 加载本地资源
   *
   * @private
   * @template T
   * @param {string} schema
   * @param {ILoaderOptions} [options={}]
   * @returns
   * @memberof Loader
   */
  export default function loadFromFileSystem(path: string, filetype?: string): LitePromise<any>;
}
declare module "engine/assets/cache" {
  import LitePromise from "lib/utils/promise";
  import { EngineError } from "engine/error";
  import { Delegate } from "engine/misc/delegate";
  type Stats = {
    size: number;
    files: {
      path: string;
      size: number;
    }[];
    unexpectedFiles: {
      path: string;
      size: number;
    }[];
  };
  type Cache = {
    size: number;
    loadTimes: number;
    useTimes: number;
    lastLoadTime: number;
    lastUseTime: number;
  };
  type compareFunction = (a: Cache, b: Cache) => number;
  class CacheManager {
    /**
     *
     *
     * @type {number}
     * @memberof CacheManager
     */
    /**
     *
     *
     * @type {number}
     * @memberof CacheManager
     */
    sizeLimit: number;
    /**
     * 当前缓存文件大小总和，单位 B 字节。
     *
     * @type {number}
     * @memberof CacheManager
     */
    currentSize: number;
    /**
     * 缓存空间不足的警告阈值，单位 B 字节。当 sizeLimit - currentSize <= freeSpaceThreshold 时，将执行 onNeedRelease() 回调函数。
     * 如果 onNeedRelease() 返回非 -1 的正整数，如 40*1024*1024，则释放 40 MB 缓存空间。
     * 如果 freeSpaceThreshold < 1，则以 sizeLimit * freeSpaceThreshold 作为阈值。
     *
     * @type {number}
     * @memberof CacheManager
     */
    freeSpaceThreshold: number;
    /**
     * 当剩余缓存空间小于警告阈值时。
     *
     * @memberof CacheManager
     */
    onNeedRelease: (res: { currentSize: number; sizeLimit: number; status: number; cacheSize: number }) => number;
    /**
     * 缓存淘汰策略函数，用法同传入 Array.prototype.sort 的函数。
     * 当淘汰缓存时，会对已有缓存进行排序，然后依次淘汰在排序结果中靠前的缓存直到满足所需释放的缓存空间大小。
     * 如果 compare 不为 null，则根据 compare 返回的结果进行排序，否则按照最近最少使用的策略进行排序。
     *
     * @type {(compareFunction | null)}
     * @memberof CacheManager
     */
    compare: compareFunction | null;
    onWarn: Delegate<CacheManager, EngineError>;
    onError: Delegate<CacheManager, any>;
    hasRegister(filename: string): LitePromise<boolean | null>;
    /**
     * 获取缓存目录下的文件信息。这是一次消耗性能的文件操作，不应频繁调用。
     *
     * @returns {LitePromise<Stats>}
     * @memberof CacheManager
     */
    stat(): LitePromise<Stats>;
    /**
     * 初始化缓存模块，从文件系统中获取缓存列表并删除缓存目录下路径不符合格式的非法文件。
     *
     * @returns {LitePromise<void[]>}
     * @memberof CacheManager
     */
    init(): LitePromise<void>;
    /**
     * 清空缓存空间，删除所有的缓存文件。
     *
     * @returns {LitePromise<void>}
     * @memberof CacheManager
     */
    clear(): LitePromise<void>;
    /**
     * 释放指定大小的缓存空间。CacheManager 会根据传入的 size 去删除文件，以腾出缓存空间。
     *
     * @param {number} size 要释放的缓存空间的大小，单位 B 字节。
     * @returns {LitePromise<void[]>}
     * @memberof CacheManager
     */
    release(size: number): LitePromise<void[]>;
  }
  const _default: CacheManager;
  export default _default;
  export { CacheManager };
}
declare module "engine/assets/lib/priority-download/task-manager" {
  import LitePromise from "lib/utils/promise";
  export type TaskFunc<T> = () => LitePromise<T>;
  export class Task<T> {
    func: TaskFunc<T>;
    promise: LitePromise<T>;
    constructor(func: TaskFunc<T>);
  }
  export class TaskManager<T> {
    constructor(runningLimit?: number);
  }
}
declare module "engine/debug/memorycache-inspector" {
  import { BaseResource } from "engine/engine";
  export default class MemoryCacheInspector {
    static getGfxCacheCount(): {
      [gfxObjType: string]: number;
    };
    static addAdditionalResource(asset: BaseResource): void;
    static getAssetCacheCount(): {
      [assetType: string]: {
        count: number;
        everCount: number;
        totalSize: number;
      };
    };
    static getLoaderStringCount(): number;
    static getAssetCacheDetailByType(
      type: string,
    ): {
      key: string;
      size: number;
    }[];
    static getGraphicResource(): {
      canvasSize: any;
      imageSize: any;
      imageSrc: any;
    };
  }
}
declare module "engine/debug/debug-plugin" {
  class DebugPlugin {
    constructor();
    initRemoteDebug: () => void;
    handleDebugMessage: (msg: {
      command: string;
      data?: any;
    }) => {
      command: string;
      data: string;
    };
  }
  const _default: DebugPlugin;
  export default _default;
}
declare module "engine/debug" {
  import LoadInspector from "engine/debug/load-inspector";
  import Logger, { LoggerInstance } from "engine/debug/logger";
  import MemoryCacheInspector from "engine/debug/memorycache-inspector";
  import DebugPlugin from "engine/debug/debug-plugin";
  export { Logger, LoggerInstance, MemoryCacheInspector, MemoryCacheInspector as CacheInspector, LoadInspector, DebugPlugin };
}
declare module "engine/assets/lib/priority-download/download" {
  import LitePromise from "lib/utils/promise";
  import { DownloadSession } from "engine/assets/lib/priority-download/session";
  export type DownloadResponse = {
    filePath: string;
    dataLength: number;
  };
  export const _download: (
    url: string,
    savePath?: string,
  ) => {
    task: engineWX.DownloadTask;
    promise: LitePromise<DownloadResponse>;
  };
  export const download: (session: DownloadSession, url: string, savePath: string, retry?: number) => LitePromise<DownloadResponse>;
}
declare module "engine/assets/lib/priority-download/session" {
  import { Task, TaskFunc } from "engine/assets/lib/priority-download/task-manager";
  import { DownloadResponse } from "engine/assets/lib/priority-download/download";
  export enum DownloadSessionStatus {
    QUEUEING = 0,
    DOWNLOADING = 1,
    DONE = 2,
    ABORTED = 3,
  }
  export class DownloadSession extends Task<DownloadResponse> {
    get wxDownloadTask(): engineWX.DownloadTask | null;
    set wxDownloadTask(task: engineWX.DownloadTask | null);
    downloadURL: string;
    downloadedSize: number;
    downloadTotal: number;
    queueing: boolean;
    status: DownloadSessionStatus;
    timeStart: number;
    timeQueued: number;
    timeEnd: number;
    constructor(
      func: TaskFunc<{
        filePath: string;
        dataLength: number;
      }>,
      onAbort: () => void,
    );
    abort(): void;
  }
}
declare module "engine/game/gameUtil" {
  export function requestID(): number;
}
declare module "engine/assets/classes/baseResource" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export default class BaseResource {
    /**
     * 运行时的唯一资源id。
     * @private
     * @type {number}
     * @memberof BaseResource
     */
    readonly id: number;
    /**
     * 编辑器中使用的资源id。
     * @type {string}
     * @memberof BaseResource
     */
    resourceID?: string;
    groupIDHash?: string;
    /**
     * 资源的基类，弱引用逻辑。
     * @memberof BaseResource
     */
    constructor();
    /**
     * 资源的反序列化方法。
     * @static
     * @param {*} resourceDefinition 资源描述文件。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {BaseResource}
     * @memberof BaseResource
     */
    static DeserializeResource(resourceDefinition: any, loadContext: BaseLoadContext, dependencies: string[]): BaseResource;
  }
}
declare module "engine/assets/deserialize/compiled.game" {
  export const DeserializeFailFlag: any;
  export default function Deserialize(json: any, result: any, context: any, builtContext: any): any;
}
declare module "engine/assets/deserialize/deserialize" {
  import { Nullable } from "engine/type";
  import BaseResource from "engine/assets/classes/baseResource";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { SerializableCtor } from "engine/assets/deserialize/decorators";
  import { SmartArray } from "engine/misc/array";
  export function GetClass(className: string): Nullable<SerializableCtor>;
  export interface ISerializedObject {
    type: string;
    data: any;
  }
  export class SerializeHelper {
    static Context: Nullable<{
      [key: string]: any[];
    }>;
    static ContextMap: Nullable<{
      [key: string]: string;
    }>;
    static BuiltContext: Nullable<{
      [key: string]: SmartArray<any>;
    }>;
    /**
     * 实例化一个资源
     * @param type 资源类型
     * @param resourceDescription 主描述文件
     * @param loadContext
     */
    static DeserializeResource(type: string, resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[]): BaseResource;
    static EnterContext(context: any, contextMap: any): void;
    static LeaveContext(): void;
    /**
     * 反序列化一个对象。
     * @param {any} fileData 被序列化的对象的数据
     * @optional @param {any} target 是否已经有反序列化的实例对象，某些情况比如Component需要首先调用Entity.protoptype.addComponent的方法产生实例后才能给这个实例的每个属性赋值，这时候就用的到这个参数。
     */
    static Deserialize(fileData: any, target?: any): any;
  }
}
declare module "engine/assets/load-contexts/weak-asset" {
  export default class WeakAsset {
    type: string;
    private set value(value);
    constructor(value: any, type: string);
    get(): any;
    changeToWeak(): void;
    changeToStrong(value?: any): void;
  }
}
declare module "engine/assets/lib/priority-download" {
  import { TaskManager } from "engine/assets/lib/priority-download/task-manager";
  import { DownloadSession } from "engine/assets/lib/priority-download/session";
  import { DownloadResponse } from "engine/assets/lib/priority-download/download";
  /**
   * 对wxDownloadFile的一个封装，允许带优先级的任务执行
   *
   * @export
   * @class WXPriorityDownload
   */
  export class PriorityDownload extends TaskManager<DownloadResponse> {
    constructor(runningLimit?: number);
    /**
     * 对外暴露的入下载队函数
     *
     * @param {number} priority 优先级
     * @param {(download: (url) => void) => void} getDownloadParam 拍好队之后的回调函数，download即启动下载
     * @returns
     */
    queue(url: string, savePath?: string, retry?: number, priority?: number): DownloadSession;
  }
  const _default: PriorityDownload;
  export default _default;
}
declare module "engine/assets/load-contexts/status/manifest-downloading/_" {
  import LitePromise from "lib/utils/promise";
  import { DownloadResponse } from "engine/assets/lib/priority-download/download";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export default function(this: LoadContext): LitePromise<DownloadResponse>;
}
declare module "engine/assets/load-contexts/status/manifest-downloading" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  export function manifestDownloading(this: LoadContext, statusVersion: number): LitePromise<S.Expired | S.ManifestDownloaded | S.Unloaded>;
  export function abortManifestDownloading(this: LoadContext): LitePromise<S.Unloaded>;
}
declare module "engine/assets/load-contexts/status/manifest-reading/_" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export default function(this: LoadContext): LitePromise<any>;
}
declare module "engine/assets/load-contexts/status/util" {
  export const tryDownload: (error: any) => boolean;
}
declare module "engine/assets/load-contexts/status/manifest-reading" {
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export function manifestReading(this: LoadContext, statusVersion: number): LitePromise<S.Expired | S.Manifested | S.Unloaded | S.ManifestDownloading>;
  export function abortManifestReading(this: LoadContext): LitePromise<S.Unloaded | S.ManifestDownloaded>;
}
declare module "engine/assets/load-contexts/status/file-downloading/_" {
  import { DownloadResponse } from "engine/assets/lib/priority-download/download";
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export default function(this: LoadContext, statusVersion: number): LitePromise<DownloadResponse[]>;
}
declare module "engine/assets/load-contexts/status/file-downloading" {
  import LoadContext from "engine/assets/load-contexts/load-context";
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  import LitePromise from "lib/utils/promise";
  export function fileDownloading(this: LoadContext, statusVersion: number): LitePromise<S.Expired | S.FileDownloaded | S.Manifested>;
  export function abortFileDownloading(this: LoadContext): LitePromise<S.Manifested>;
}
declare module "engine/assets/load-contexts/status/file-reading/_" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export default function(this: LoadContext, statusVersion: number): LitePromise<void[]>;
}
declare module "engine/assets/load-contexts/status/file-reading" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  export function fileReading(this: LoadContext, statusVersion: number): LitePromise<S.Expired | S.Loaded | S.FileDownloading | S.Unloaded>;
  export function abortFileReading(this: LoadContext): LitePromise<S.Manifested>;
}
declare module "engine/assets/load-contexts/status/weakening/_" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export default function(this: LoadContext): LitePromise<void>;
}
declare module "engine/assets/load-contexts/status/weakening" {
  import LitePromise from "lib/utils/promise";
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  import LoadContext from "engine/assets/load-contexts/load-context";
  export function weakening(this: LoadContext, statusVersion: number): LitePromise<S.Expired | S.Weak>;
  export function abortWeakening(this: LoadContext): LitePromise<S.Loaded>;
}
declare module "engine/assets/load-contexts/status/manifested" {
  import LoadContext from "engine/assets/load-contexts/load-context";
  export function manifested(this: LoadContext): void;
}
declare module "engine/assets/load-contexts/status/loaded" {
  import LoadContext from "engine/assets/load-contexts/load-context";
  export function loaded(this: LoadContext): void;
}
declare module "engine/assets/load-contexts/status/weak" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  import { ContextStatus as S } from "engine/assets/load-contexts/status/enum";
  export function weak(this: LoadContext): void;
  export function strong(this: LoadContext): LitePromise<S.Loaded | S.FileReading>;
  export function allExisted(this: LoadContext): boolean;
}
declare module "engine/assets/load-contexts/status" {
  import LitePromise from "lib/utils/promise";
  import LoadContext from "engine/assets/load-contexts/load-context";
  /**
   * 进行context状态的转换
   * @param this context实例，记载着context当前的status和action
   *
   * 进入该函数之后，会根据当前的status和action调用对应的 状态handler。
   * 状态handler 是一个异步函数，并且它一定会返回要扭转的下一个状态。
   *
   * 状态枚举值里的一个特殊是Expired，它代表的含义是context的状态已经被其它外力所转变，所以这一个状态扭转结果需要被废弃。
   */
  export function transfer(this: LoadContext): LitePromise<void>;
}
declare module "engine/render/uniformBlockValue" {
  export default class UniformBlockValue {
    constructor(rawDesc: wgfx.ShaderUniformBlockDesc);
    static getDefaultValue(): UniformBlockValue;
    static getDefaultDesc(): wgfx.ShaderUniformBlockDesc;
    static composeUniformBuffer(
      ub: UniformBlockValue,
      kvArray: Array<{
        key: string;
        value: ArrayLike<number>;
      }>,
      dst?: Float32Array,
    ): Float32Array;
    static createShaderUniformDescByConfig(
      uniforms: Array<{
        name: string;
        type: string;
        array_count?: number;
      }>,
    ): wgfx.ShaderUniformBlockDesc;
    /**
     * 是否有key
     *
     * @param {string} key
     * @returns {boolean} 结果
     * @memberof UniformBlockValue
     */
    hasKey(key: string): boolean;
    /**
     * 往指定key的偏移处设置数据
     *
     * @param {string} key
     * @param {ArrayLike<number>} value
     * @returns {boolean} 是否成功
     * @memberof UniformBlockValue
     */
    setArray(key: string, value: ArrayLike<number>): boolean;
    /**
     * 清除全部数据
     *
     * @memberof UniformBlockValue
     */
    clearData(): void;
    /**
     * 拷贝自身
     * 注意：uniformBlockDesc和offsetMap只拷贝引用
     *
     * @returns {UniformBlockValue}
     * @memberof UniformBlockValue
     */
    clone(): UniformBlockValue;
    setAllData(data: Float32Array): void;
  }
}
declare module "engine/assets/resource" {
  import { DeepImmutable, Nullable } from "engine/type";
  interface IAvatarAsset {
    exposedPaths?: number[];
    paths: string[];
    hashes: number[];
    buffer: string;
    pose: string;
    optimized: boolean;
  }
  export type AvatarAsset = DeepImmutable<IAvatarAsset>;
  /**
   * 动画片段的播放模式，适用于genetic animation组件。
   * @export
   * @enum {number}
   */
  export enum WrapMode {
    /**
     * 同Once。
     */
    Default = 0,
    /**
     * 当动画片段播放到尾部时，动画片段会自动停止，并把时间重置回动画片段的起始时间。
     */
    Once = 1,
    /**
     * 当动画片段播放到尾部时，动画片段会重置回动画片段的起始时间然后继续播放。
     */
    Loop = 2,
    /**
     * 当动画片段播放到尾部时，动画片段会从动画片段的终止时间反向继续播放，当再次回到动画片段的起始时间时又会继续正向播放，如此不断循环。
     */
    PingPong = 4,
    /**
     * 当动画片段播放到尾部时，动画片段会一直停留在动画片段的终止时间（动画并不会停止）。
     */
    ClampForever = 8,
  }
  export enum AnimatorLayerBlendingMode {
    Override = 0,
    Additive = 1,
  }
  export enum TransitionInterruptionSource {
    None = 0,
    Source = 1,
    Destination = 2,
    SourceThenDestination = 3,
    DestinationThenSource = 4,
  }
  export enum ConditionMode {
    kConditionModeIf = 1,
    kConditionModeIfNot = 2,
    kConditionModeGreater = 3,
    kConditionModeLess = 4,
    kConditionModeExitTime = 5,
    kConditionModeEquals = 6,
    kConditionModeNotEqual = 7,
    kConditionModeCount = 8,
  }
  export enum BlendTreeType {
    Simple1D = 0,
    SimpleDirectional2D = 1,
    FreeformDirectional2D = 2,
    FreeformCartesian2D = 3,
    Direct = 4,
  }
  export enum AnimatorControllerParameterType {
    Float = 1,
    Int = 3,
    Bool = 4,
    Trigger = 9,
  }
  interface IAnimationResourceClipConfig {
    file: {
      src: string;
    };
    data?: {
      paths?: string[];
      props?: Array<[number, string]>;
      wrapMode?: WrapMode;
      startTime?: number;
      stopTime?: number;
      loopTime?: boolean;
      cycleOffset?: number;
    };
    resourceid?: string;
  }
  export type AnimationClipResourceConfig = DeepImmutable<IAnimationResourceClipConfig>;
  interface IAnimatorControllerDescription {
    name?: string;
    layers: Array<{
      name: string;
      stateMachine: number;
      blending: AnimatorLayerBlendingMode;
      IKPass: boolean;
      /**
       * Avatar mask
       */
      mask?: string;
      weight: number;
    }>;
    stateMachines: Array<{
      name: string;
      states: number[];
      defaultState: Nullable<number>;
      anyStateTransitions: number[];
    }>;
    states: Array<{
      name: string;
      motion: Nullable<
        | {
            type: "AnimationClip";
            id: string;
          }
        | {
            type: "BlendTree";
            id: number;
          }
      >;
      speed: number;
      transitions: number[];
    }>;
    transitions: Array<{
      conditions: Array<{
        name: string;
        operator: ConditionMode;
        value: number;
      }>;
      fixedDuration: boolean;
      duration: number;
      offset: number;
      interruption: TransitionInterruptionSource;
      exitTime: number;
      hasExitTime: boolean;
      destState: Nullable<{
        type: "State" | "StateMachine";
        id: number;
      }>;
    }>;
    blendTrees: Array<{
      name: string;
      children: Array<{
        motion:
          | {
              type: "BlendTree";
              id: number;
            }
          | {
              type: "AnimationClip";
              id: string;
            };
        threshold: number;
        timeScale: number;
      }>;
      minThreshold: number;
      maxThreshold: number;
      blendParameter: number[];
      blendType: BlendTreeType;
    }>;
    parameters: Array<{
      name: string;
      type: AnimatorControllerParameterType;
      default?: any;
    }>;
  }
  export type AnimatorControllerDescription = DeepImmutable<IAnimatorControllerDescription>;
  interface IES100Reflection {
    attributes: Array<{
      key: number;
      type: wgfx.EnumVertexFormat;
      count?: number;
    }>;
    uniforms: Array<{
      key: number;
      type: wgfx.EnumUniformType;
      count?: number;
    }>;
    images: Array<{
      key: number;
      type: wgfx.EnumImageType;
      count?: number;
    }>;
  }
  export enum EnumPipelineType {
    ForwardBase = 0,
    ShadowCaster = 1,
    PostProcess = 2,
  }
  export type PipelineTypeString = Exclude<keyof typeof EnumPipelineType, number>;
  interface IEffectAsset {
    name: string;
    properties?: Array<
      | {
          key: number;
          type: wgfx.EnumUniformType;
          default: [number];
        }
      | {
          key: number;
          type: wgfx.EnumUniformType;
          default: [number, number];
        }
      | {
          key: number;
          type: wgfx.EnumUniformType;
          default: [number, number, number];
        }
      | {
          key: number;
          type: wgfx.EnumUniformType;
          default: [number, number, number, number];
        }
    >;
    images?: Array<{
      key: number;
      type: wgfx.EnumImageType;
      default: string;
    }>;
    defaultRenderQueue: number;
    passes: Array<{
      lightMode: PipelineTypeString;
      macros: {
        [key: string]: number;
      };
      variants: {
        [key: number]: number;
      };
      useMaterialRenderStates: boolean;
      renderStates?: {
        blendOn?: boolean;
        blendSrc?: wgfx.EnumBlendFactor;
        blendDst?: wgfx.EnumBlendFactor;
        blendFunc?: wgfx.EnumBlendOp;
        cullOn?: boolean;
        cullFace?: wgfx.EnumCullMode;
        depthWrite?: boolean;
        depthTestOn?: boolean;
        depthTestComp?: wgfx.EnumCompareFunc;
        stencilWriteMask?: number;
        stencilTestOn?: boolean;
        stencilRef?: number;
        stencilReadMask?: number;
        stencilComp?: wgfx.EnumCompareFunc;
        stencilPass?: wgfx.EnumStencilOp;
        stencilFail?: wgfx.EnumStencilOp;
        stencilZFail?: wgfx.EnumStencilOp;
        primitiveType?: wgfx.EnumPrimitiveType;
      };
    }>;
    variants: Array<{
      shaders: number[];
      reflection: IES100Reflection;
    }>;
    shaders: string[];
    strings: string[];
    resourceid?: string;
  }
  export type EffectAsset = DeepImmutable<IEffectAsset>;
  interface IVariantResourceDescription {
    file: {
      src: {
        es20: [string, string];
        vulkan?: [string, string];
        metal?: [string, string];
      };
    };
  }
  export type VariantResourceDescription = DeepImmutable<IVariantResourceDescription>;
  interface IFontResourceDescription {
    file: {
      src: string;
    };
  }
  export type FontResourceDescription = DeepImmutable<IFontResourceDescription>;
  interface IRawResourceDescription {
    file: {
      src: string;
    };
  }
  export type RawResourceDescription = DeepImmutable<IRawResourceDescription>;
  interface ISpriteframeResourceDescription {
    texture: string;
    rect: [number, number, number, number];
    trim?: [number, number, number, number];
    slicedRect?: [number, number, number, number];
    resourceid?: string;
  }
  export type SpriteframeResourceDescription = DeepImmutable<ISpriteframeResourceDescription>;
  interface IBitmapFontResourceDescription {
    lineHeight: number;
    fontSize: number;
    width: number;
    height: number;
    texture: string;
    frames: {
      [charCode: string]: {
        x: number;
        y: number;
        offsetX: number;
        offsetY: number;
        width: number;
        height: number;
      };
    };
  }
  export type BitmapFontResourceDescription = DeepImmutable<IBitmapFontResourceDescription>;
  interface ITextureResourceDescription {
    data: {
      width: number;
      height: number;
      useMipmap: boolean;
      mipmap: number;
      minLod?: number;
      maxLod?: number;
      sRGB: boolean;
      wrapU: number;
      wrapV: number;
      filterMode: number;
      pixelFormat: number;
      anisoLevel: number;
    };
    file?: {
      src: string;
    };
    resourceid?: string;
  }
  export type TextureResourceDescription = DeepImmutable<ITextureResourceDescription>;
  interface ITextureCubeResourceDescription {
    desc: {
      width: number;
      height: number;
      useMipmap: boolean;
      mipmap: number;
      sRGB: number;
      wrapU: number;
      wrapV: number;
      wrapW: number;
      magFilter: number;
      minFilter: number;
      pixelFormat: number;
      anisoLevel: number;
      needPremultiplyAlpha: true;
      rgb_etc1?: number;
      rgb_pvrtc?: number;
      rgba_pvrtc?: number;
      ktx_dataOffset?: number;
      pvr_dataOffset?: number;
    };
    files: {
      right: string;
      left: string;
      top: string;
      bottom: string;
      back: string;
      front: string;
    };
    resourceid?: string;
  }
  export type TextureCubeResourceDescription = DeepImmutable<ITextureCubeResourceDescription>;
  export enum MeshIndiceFormat {
    BIT16 = 1,
    BIT32 = 2,
  }
  interface IMeshResourceDescription {
    data: {
      vertexLayout: string;
      vertexStart: number;
      vertexLength: number;
      indiceStart: number;
      indiceLength: number;
      indiceFormat: MeshIndiceFormat;
      capsule: {
        x: number;
        y: number;
        z: number;
        radius: number;
      };
      subMeshs: Array<{
        start: number;
        length: number;
      }>;
      boundBox: {
        center: number[];
        size: number[];
      };
      releaseRawBuffer?: boolean;
      rootBone?: string;
      bones?: string[];
      bonePoseStart?: number;
      bonePoseLength?: number;
    };
    file: {
      src: string;
    };
    resourceid?: string;
  }
  export type MeshResourceDescription = DeepImmutable<IMeshResourceDescription>;
  export interface IMaterialRenderStates {
    blendOn?: boolean;
    blendSrc?: wgfx.EnumBlendFactor;
    blendDst?: wgfx.EnumBlendFactor;
    blendFunc?: wgfx.EnumBlendOp;
    cullOn?: boolean;
    cullFace?: wgfx.EnumCullMode;
    depthWrite?: boolean;
    depthTestOn?: boolean;
    depthTestComp?: wgfx.EnumCompareFunc;
    stencilWriteMask?: number;
    stencilTestOn?: boolean;
    stencilRef?: number;
    stencilReadMask?: number;
    stencilComp?: wgfx.EnumCompareFunc;
    stencilPass?: wgfx.EnumStencilOp;
    stencilFail?: wgfx.EnumStencilOp;
    stencilZFail?: wgfx.EnumStencilOp;
    primitiveType?: wgfx.EnumPrimitiveType;
  }
  interface IMaterialResourceDescription {
    effect: string;
    textures?: {
      [key: string]: string;
    };
    shaderParams?: {
      [key: string]: number[];
    };
    renderStates?: IMaterialRenderStates;
    renderQueue?: number;
    shaderDefinations?: {
      [key: string]: boolean;
    };
  }
  export type MaterialResourceDescription = DeepImmutable<IMaterialResourceDescription>;
  interface IPrefabResourceDescription {
    meta: {
      name: string;
      type: "2D" | "3D";
    };
    gameObjectList: Array<{
      name: string;
      components: number[];
      children: number[];
      data: {
        active: boolean;
      };
    }>;
    componentList: Array<{
      type: string;
      data: any;
    }>;
    bufferDataUUIDList?: string[];
  }
  export type PrefabResourceDescription = DeepImmutable<IPrefabResourceDescription>;
  export enum FogMode {
    None = 0,
    Linear = 1,
    Exponential = 2,
    ExponentialSquared = 3,
  }
  export enum AmbientMode {
    Skybox = 0,
    Gradient = 1,
    Color = 2,
  }
  export enum LightMapType {
    Subtractive = 0,
    ShadowMask = 1,
  }
  export interface LightMapsDescription {
    color: string;
    shadowMask?: string;
  }
  export enum UIAdaptationType {
    FitHeight = 0,
    FitWidth = 1,
    Contain = 2,
    Custom = 3,
  }
  export interface IScene2DMeta {
    type: "2D";
    name: string;
    config: {
      resolution: {
        width: number;
        height: number;
      };
      adaptationType?: UIAdaptationType;
    };
  }
  export interface IScene3DMeta {
    type: "3D";
    name: string;
    config: {
      light: {
        ambientMode?: AmbientMode;
        ambientColor?: [number, number, number, number];
        ambientIntensity?: number;
        ambientSkyColor?: [number, number, number, number];
        ambientEquatorColor?: [number, number, number, number];
        ambientGroundColor?: [number, number, number, number];
        reflectionIntensity?: number;
        reflectionResolution?: number;
        fogMode?: FogMode;
        fogColor?: [number, number, number];
        fogStart?: number;
        fogRange?: number;
        fogDensity?: number;
        skybox?: string;
        subtractiveShadowColor?: [number, number, number, number];
        lightMapDatas?: LightMapsDescription[];
        lightMapType?: LightMapType;
      };
    };
  }
  export interface ISceneResourceDescription extends IPrefabResourceDescription {
    meta: IScene2DMeta | IScene3DMeta;
  }
  export type SceneResourceDescription = DeepImmutable<ISceneResourceDescription>;
  export {};
}
declare module "engine/materials/buildinShaderDesc" {
  import { PipelineTypeString } from "engine/assets/resource";
  export enum EnumRendererType {
    Mesh = 0,
    SkinnedMesh16 = 1,
    SkinnedMesh32 = 2,
    SkinnedMesh48 = 3,
    SkinnedMesh64 = 4,
    SkinnedMesh80 = 5,
    SkinnedMesh96 = 6,
    Particle = 7,
    Trail = 8,
    UI = 9,
    PostProcess = 10,
  }
  export function getUniformBlockDescByRendererType(type: EnumRendererType): wgfx.ShaderUniformBlockDesc;
  export function getUniformBlockDescByLightMode(mode: PipelineTypeString): wgfx.ShaderUniformBlockDesc;
  export function getImageDescByLightMode(
    mode: PipelineTypeString,
  ): Array<{
    name: string;
    type: wgfx.EnumImageType;
  }>;
}
declare module "engine/assets/classes/animatorController" {
  import { AnimatorController as RuntimeAnimatorController } from "engine/game/3D/animator/classes";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import BaseResource from "engine/assets/classes/baseResource";
  import { AnimatorControllerDescription } from "engine/assets/resource";
  /**
   * 动画状态机资源。
   * @export
   * @class AnimatorController
   * @extends {BaseResource}
   */
  export default class AnimatorController extends BaseResource {
    readonly description: AnimatorControllerDescription;
    /**
     * 通过资源描述文件创建动画状态机资源。
     * @param {AnimatorControllerDescription} description 资源描述。
     * @memberof AnimatorController
     */
    constructor(description: AnimatorControllerDescription);
    /**
     * 动画状态机资源的反序列化方法。
     * @static
     * @param {AnimatorControllerDescription} description 资源描述。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {AnimatorController} 动画状态机资源。
     * @memberof AnimatorController
     */
    static DeserializeResource(description: AnimatorControllerDescription, loadContext: BaseLoadContext, dependencies: string[]): AnimatorController;
    /**
     * 实例化动画状态机。
     * @returns {RuntimeAnimatorController}
     * @memberof AnimatorController
     * @returns {RuntimeAnimatorController} 动画状态机实例。
     */
    instantiate(): RuntimeAnimatorController;
  }
}
declare module "engine/assets/classes/avatar" {
  import { DeepImmutable, Nullable } from "engine/type";
  import { AvatarAsset } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  /**
   * 模型骨骼资源。
   * @export
   * @class Avatar
   * @extends {BaseResource}
   */
  export default class Avatar extends BaseResource {
    /**
     * 是否是优化过的模型。
     * @type {boolean}
     * @memberof Avatar
     */
    optimized: boolean;
    /**
     * 暴露的挂点信息。
     * @type {DeepImmutable<number[]>}
     * @memberof Avatar
     */
    exposedPaths: DeepImmutable<number[]>;
    buffer: ArrayBuffer;
    paths: DeepImmutable<string[]>;
    hashes: DeepImmutable<number[]>;
    /**
     * 模型骨骼资源的反序列化方法。
     * @static
     * @param {AvatarAsset} resourceDescription
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {Avatar}
     * @memberof Avatar
     */
    static DeserializeResource(resourceDescription: AvatarAsset, loadContext: BaseLoadContext, dependencies: string[]): Avatar;
  }
}
declare module "engine/misc/decorator" {
  export const typing: {
    guard: <T extends new (...args: any[]) => {}>(constructor: T, name?: string | undefined) => any;
    readonly: PropertyDecorator & ParameterDecorator;
    autobind: MethodDecorator;
  };
}
declare module "engine/misc/enum" {
  export function GenerateEnumObjectFromTypescript<T>(this: void, object: T): T;
}
declare module "engine/game/2D/input/KeyboardInputComponent" {
  import { Delegate } from "engine/misc/delegate";
  import Component from "engine/game/component";
  enum KeyboardEventNames {
    KEYBOARD_INPUT = "onKeyboardInput",
    KEYBOARD_CONFIRM = "onKeyboardConfirm",
    KEYBOARD_COMPLETE = "onKeyboardComplete",
  }
  /**
   * 键盘输入组件。
   * @export
   * @class KeyboardInputComponent
   * @extends {Component}
   */
  export default class KeyboardInputComponent extends Component {
    /**
     * 键盘事件类型。
     * @static
     * @type {typeof KeyboardEventNames}
     * @memberof KeyboardInputComponent
     */
    static KEYBOARD_EVENTS: typeof KeyboardEventNames;
    onKeyboardShow: Delegate<KeyboardInputComponent, {}>;
    onKeyboardInput: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
    onKeyboardConfirm: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
    onKeyboardComplete: Delegate<KeyboardInputComponent, engineWX.KeyboardEvent>;
    showKeyboard(config: engineWX.ShowKeyboardArgument): void;
    updateKeyboard(config: engineWX.UpdateKeyboardArgument): void;
    hideKeyboard(config?: engineWX.HideKeyboardArgument): void;
    invokeKeyboardShow(): void;
    invokeKeyboardInput(res: engineWX.KeyboardEvent): void;
    invokeKeyboardConfirm(res: engineWX.KeyboardEvent): void;
    invokeKeyboardComplete(res: engineWX.KeyboardEvent): void;
  }
  export {};
}
declare module "engine/input/keyboard" {
  type KeyboardInputComponent = import("engine/game/2D/input/KeyboardInputComponent").default;
  export default class KeyboardManager {
    constructor();
    showKeyboard(keyboardInput: KeyboardInputComponent, config: engineWX.ShowKeyboardArgument): void;
    hideKeyboard(keyboardInput: KeyboardInputComponent, config?: engineWX.HideKeyboardArgument): void;
    updateKeyboard(keyboardInput: KeyboardInputComponent, config: engineWX.UpdateKeyboardArgument): void;
  }
  export {};
}
declare module "engine/platform/touch" {
  export enum RawTouchEvents {
    TouchStart = "touchstart",
    TouchEnd = "touchend",
    TouchMove = "touchmove",
    TouchCancel = "touchcancel",
  }
  export function SetupTouchListeners(): void;
}
declare module "engine/game/transformBase" {
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import { Emitter } from "engine/misc/emitter";
  import { ChildChangeEventType } from "engine/event";
  export default abstract class TransformBase extends Component {
    /**
     * 组件本身是否active
     *
     * @type {boolean}
     * @overload
     * @memberof Component
     */
    get active(): boolean;
    set active(value: boolean);
    /**
     * 父节点
     *
     * @readonly
     * @memberof TransformBase
     */
    get parent(): Nullable<TransformBase>;
    /**
     * 子节点数量
     *
     * @readonly
     * @memberof TransformBase
     */
    get childrenCount(): number;
    get children(): TransformBase[];
    /**
     * 世界矩阵变更事件监听器
     *
     * @type {Emitter<TransformBase>}
     * @memberof TransformBase
     */
    get worldMatrixDirtyEvent(): Emitter<void>;
    /**
     * active状态变更事件监听器
     *
     * @type {Emitter<TransformBase>}
     * @memberof TransformBase
     */
    get activeInHierarchyChangedEvent(): Emitter<void>;
    /**
     * 增删节点事件监听器
     *
     * @type {Emitter<TransformBase, ChildChangeEventType>}
     * @memberof TransformBase
     */
    get childChangeEvent(): Emitter<ChildChangeEventType, TransformBase>;
    /**
     * 找子节点
     * create by clairli
     * @param {childName} 子节点名称
     */
    findChildByName(childName: string): Nullable<TransformBase>;
    /**
     * 获取同级索引
     *
     * @returns {number}
     * @memberof TransformBase
     */
    getSiblingIndex(): number;
    /**
     * 设置同级索引
     *
     * @param {number} index 同级索引序号
     * @returns
     * @memberof TransformBase
     */
    setSiblingIndex(index: number): void;
    /**
     * 遍历子节点
     *
     * @param {(child: TransformBase) => any} cb 回调函数
     * @returns
     * @memberof TransformBase
     */
    travelChild(cb: (child: TransformBase) => any): void;
    destroy(): void;
  }
}
declare module "engine/system/node" {
  import { IGameSystem } from "engine/game/game";
  import TransformBase from "engine/game/transformBase";
  import { SmartArray } from "engine/misc/array";
  import { Nullable } from "engine/type";
  type Game = import("engine/game/game").default;
  type Component = import("engine/game/component").default;
  type Entity = import("engine/scene/entity").default;
  enum ComponentState {
    Entry = 0,
    ToActivate = 1,
    Activating = 2,
    Activated = 3,
    ToEnable = 4,
    Enabling = 5,
    Enabled = 6,
    ToStart = 7,
    Starting = 8,
    Started = 9,
    Update = 10,
    ToDeactivate = 11,
    Deactivating = 12,
    Deactivated = 13,
    StateCount = 14,
  }
  class PriorityArrayBase<T extends object> {
    constructor(getPriorityFunc: (item: T) => number);
    add(item: T): void;
    remove(item: T): void;
    has(item: T): boolean;
    forEach(fn: (item: T) => void): void;
    clear(): void;
  }
  class PriorityArray<T extends object> {
    constructor(getPriorityFunc: (item: T) => number);
    has(item: T): boolean;
    add(item: T): void;
    remove(item: T): void;
    forEach(fn: (item: T) => void, once?: boolean, cycle?: boolean): void;
  }
  enum ComponentAction {
    Activate = 0,
    Deactivate = 1,
    Enable = 2,
    Disable = 3,
  }
  class InvokeComponentPersist<T extends Component> extends PriorityArray<T> {
    invokeFunc: (comp: T, dt: number) => void;
    constructor(invokeFunc: (comp: T, dt: number) => void);
    invoke(dt: number): void;
  }
  class InvokeComponentOnce<T extends Component> extends PriorityArray<T> {
    invokeFunc: (comp: T) => void;
    constructor(invokeFunc: (comp: T) => void);
    invoke(cycle?: boolean): void;
  }
  class ComponentSystem {
    activatingEntity: Nullable<Entity>;
    lateDeactivate: WeakSet<Component>;
    latePreRemoveTasks: SmartArray<() => void>;
    activateInvoker: InvokeComponentOnce<Component>;
    deactivateInvoker: InvokeComponentOnce<Component>;
    removeInvoker: InvokeComponentOnce<TransformBase>;
    lateRemoveInvoker: InvokeComponentOnce<TransformBase>;
    componentStateMap: WeakMap<Component, number>;
    getState(comp: Component): ComponentState;
    setState(comp: Component, newState: ComponentState): void;
    getActive(comp: Component): boolean;
    setActive(comp: Component, active: boolean): void;
    update(dt: number): void;
    lateUpdate(dt: number): void;
    onActiveInHierarchyChange(comp: Component): void;
    activate(comp: Component): void;
    deactivate(comp: Component): void;
  }
  enum EntityState {
    Entry = 0,
    Activated = 1,
    Deactivated = 2,
    StateCount = 3,
  }
  enum EntityAction {
    Activate = 0,
    Deactivate = 1,
    Enable = 2,
    Disable = 3,
  }
  export default class NodeSystem implements IGameSystem {
    readonly game: Game;
    entityStateMap: WeakMap<Entity, EntityState>;
    componentSystem: ComponentSystem;
    constructor(game: Game);
    onComponentActiveInHierarchyChange(component: Component): void;
    activateComponent(component: Component): void;
    deactivateComponent(component: Component): void;
    onActiveInHierarchyChange(entity: Entity): void;
    deactivate(entity: Entity): void;
    deactivateImmediate(entity: Entity): void;
    update(deltaTime: number): void;
    lateUpdate(deltaTime: number): void;
    dispose(): void;
  }
  export {};
}
declare module "engine/game/3D/directionalLight" {
  import Vector3 from "engine/math/vector3";
  import Component from "engine/game/component";
  import { Entity3D } from "engine/scene/scene";
  /**
   * @public
   */
  export default class DirectionalLight extends Component {
    readonly entity: Entity3D;
    /**
     * 平行光亮度值
     *
     * @type {number}
     * @memberof DirectionalLight
     */
    get intensity(): number;
    set intensity(val: number);
    /**
     * 平行光颜色
     *
     * @type {Vector3}
     * @memberof DirectionalLight
     */
    get color(): Vector3;
    set color(val: Vector3);
    /**
     * 阴影强度
     *
     * @type {number}
     * @memberof DirectionalLight
     */
    shadowStrength: number;
    /**
     * 平行光方向，只读，修改无效
     *
     * @readonly
     * @type {Vector3}
     * @memberof DirectionalLight
     */
    get direction(): Vector3;
    constructor(entity: Entity3D);
  }
}
declare module "engine/render/screen" {
  import { RenderTexture } from "engine/engine";
  import Color from "engine/math/color";
  import { Emitter } from "engine/misc/emitter";
  export default class Screen {
    /**
     * 屏幕分辨率变更事件监听器
     *
     * @type {Observable<Screen>}
     * @memberof Screen
     */
    readonly resolutionChangeEvent: Emitter<void>;
    get clearColor(): Color;
    set clearColor(val: Color);
    constructor(width: number, height: number);
    /**
     * 设置分辨率
     * 该接口一般不会由开发者手动调用
     *
     * @param {number} width
     * @param {number} height
     * @returns
     * @memberof Screen
     */
    setResolution(width: number, height: number): void;
    get resolutionHeight(): number;
    get resolutionWidth(): number;
    /**
     * 清屏，现在默认颜色全黑，深度模板全清
     * todo:增加可配置的clearAction，颜色深度等
     *
     * @memberof Screen
     */
    clearScreen(): void;
    makeRenderTexture(desc?: wgfx.ImageDesc): RenderTexture;
  }
}
declare module "engine/graphicResource/dynamicImage" {
  export default class DynamicImage implements IImage {
    constructor(width: number, height: number, desc: wgfx.ImageDesc);
    /**
     * 更新贴图，支持局部更新
     *
     * @param {TextureSource[][]} images
     * @param {number} [x] 必须是整数，不能小数
     * @param {number} [y] 必须是整数，不能小数
     * @param {number} [width]
     * @param {number} [height]
     * @memberof DynamicImage
     */
    uploadImage(images: TextureSource[][], x?: number, y?: number, width?: number, height?: number, unpack_premultiply_alpha?: boolean): void;
    destroy(): void;
  }
}
declare module "engine/graphicResource/immutableImage" {
  export default class ImmutableImage implements IImage {
    constructor(images: TextureSource[][], width: number, height: number, desc: wgfx.ImageDesc);
  }
}
declare module "engine/assets/classes/texture" {
  import BaseResource from "engine/assets/classes/baseResource";
  import { Nullable } from "engine/type";
  export enum TextureWrapMode {
    CLAMP_TO_EDGE = 2,
    REPEAT = 1,
    MIRRORED_REPEAT = 3,
  }
  export enum TexturePixelFormat {
    L8 = 12,
    ETC1_RGB8 = 24,
    RGBA8 = 2,
    PVRTC2_RGB = 18,
    PVRTC2_RGBA = 20,
    PVRTC4_RGB = 19,
    PVRTC4_RGBA = 21,
    ETC2_RGB8 = 22,
    ETC2_SRGB8 = 23,
    PIXELFORMAT_ETC2_RGBA8 = 27,
    ASTC = 28,
  }
  export enum TextureFilterMode {
    POINT = 0,
    BILINEAR = 1,
    TRILINEAR = 2,
  }
  /**
   * 贴图资源。
   * @export
   * @class Texture
   * @extends {BaseResource}
   */
  export default class Texture extends BaseResource {}
}
declare module "engine/assets/buildin-asset/buildin-texture" {
  import Texture2D from "engine/assets/classes/texture2D";
  /**
   * 内置纯色贴图资源，避免不必要的getAsset调用。
   * @export
   */
  export const BuildInTextures: {
    Transparent: Texture2D;
    White: Texture2D;
    Black: Texture2D;
    Red: Texture2D;
    Green: Texture2D;
    Blue: Texture2D;
    Yellow: Texture2D;
    Bump: Texture2D;
  };
}
declare module "engine/assets/classes/texture2D" {
  import Texture, { TextureFilterMode, TexturePixelFormat, TextureWrapMode } from "engine/assets/classes/texture";
  type TextureSource = HTMLImageElement | HTMLCanvasElement | ArrayBufferView;
  export interface Texture2DDesc {
    filterMode?: TextureFilterMode;
    wrapU?: TextureWrapMode;
    wrapV?: TextureWrapMode;
    anisoLevel?: number;
  }
  /**
   * 2D贴图资源。
   * @export
   * @class Texture2D
   * @extends {Texture}
   */
  export default class Texture2D extends Texture {
    /**
     * 贴图的填充模式。
     * @type {TextureFilterMode}
     * @memberof Texture2D
     */
    get filterMode(): TextureFilterMode;
    /**
     * 各向异性参数，有效值为1-16。
     * @type {number}
     * @memberof Texture2D
     */
    get anisoLevel(): number;
    /**
     * 像素格式。
     * @readonly
     * @type {TexturePixelFormat}
     * @memberof Texture2D
     */
    get pixelFormat(): TexturePixelFormat;
    /**
     * 横向采样包围模式。
     * @type {TextureWrapMode}
     * @memberof Texture2D
     */
    get wrapU(): TextureWrapMode;
    /**
     * 纵向采样包围模式。
     * @type {TextureWrapMode}
     * @memberof Texture2D
     */
    get wrapV(): TextureWrapMode;
    /**
     * 是否使用mipmap。
     * @type {boolean}
     * @memberof Texture2D
     */
    get useMipmap(): boolean;
    /**
     * 是否使用需要做预乘处理。
     * @type {boolean}
     * @memberof Texture2D
     */
    get needUnpackPremultiplyAlpha(): boolean;
    /**
     * 贴图高。
     * @readonly
     * @type {number}
     * @memberof Texture2D
     */
    get height(): number;
    /**
     * 贴图宽。
     * @readonly
     * @type {number}
     * @memberof Texture2D
     */
    get width(): number;
    /**
     * 是否可动态写入。
     * @readonly
     * @type {boolean}
     * @memberof Texture2D
     */
    get writeable(): boolean;
    constructor(desc?: Texture2DDesc);
    /**
     * 初始化为动态贴图，格式为RGBA8
     * 注意：动态贴图必须先设置好filter/wrap/anisolevel属性，否则会导致原有贴图丢失。
     * @param {number} width
     * @param {number} height
     * @returns {void}
     * @memberof Texture2D
     */
    initDynamicTexture(width: number, height: number): void;
    /**
     * 上传局部纹理。
     * 仅在动态贴图的模式下有效。
     * @param {TextureSource} source
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @param {boolean} [needUnpackPremultiplyAlpha=false] 上传贴图时是否进行反预乘
     * @returns {void}
     * @memberof Texture2D
     */
    updateSubTexture(source: TextureSource, x: number, y: number, width: number, height: number, needUnpackPremultiplyAlpha?: boolean): void;
    /**
     * HTMLImage或wxImage来初始化
     *
     * @param {HTMLCanvasElement} image HTMLImage或wxImage
     * @param {boolean} [generateMipmap=false] 是否生成mipmap
     * @param {boolean} [needUnpackPremultiplyAlpha=false] 上传贴图时是否进行反预乘
     * @returns {boolean} 是否初始化成功
     * @memberof Texture2D
     */
    initWithImage(image: HTMLImageElement, generateMipmap?: boolean, needUnpackPremultiplyAlpha?: boolean): boolean;
    /**
     * 使用HTMLCanvas或wxCanvas来初始化
     *
     * @param {HTMLCanvasElement} canvas HTMLCanvas或wxCanvas
     * @param {boolean} [generateMipmap=false] 是否生成mipmap
     * @param {boolean} [needUnpackPremultiplyAlpha=false] 上传贴图时是否进行反预乘
     * @returns {boolean} 是否初始化成功
     * @memberof Texture2D
     */
    initWithCanvas(canvas: HTMLCanvasElement, generateMipmap?: boolean, needUnpackPremultiplyAlpha?: boolean): boolean;
    /**
     * 使用原始RGBA buffer进行初始化
     *
     * @param {ArrayBuffer} arraybuffer 贴图的ArrayBuffer
     * @param {number} width 贴图的宽
     * @param {number} height 贴图的高
     * @param {boolean} [generateMipmap=false] 是否生成mipmap
     * @param {boolean} [needUnpackPremultiplyAlpha=false] 上传贴图时是否进行反预乘
     * @returns {boolean} 是否初始化成功
     * @memberof Texture2D
     */
    initWithRGBABuffer(arraybuffer: ArrayBufferView, width: number, height: number, generateMipmap?: boolean, needUnpackPremultiplyAlpha?: boolean): boolean;
    /**
     * 使用压缩纹理初始化
     * 目前支持 PVR/ASTC (IOS) , ETC1/ETC2 (Android)
     *
     * @param {TexturePixelFormat} pixelFormat 纹理格式
     * @param {ArrayBuffer} bufferSrc 原始buffer,如有mipmap，则逐级连接
     * @param {number} width
     * @param {number} height
     * @param {number} [mipmapLevel=1]
     * @returns {boolean}
     * @memberof Texture2D
     */
    initWithCompressTexture(pixelFormat: TexturePixelFormat, bufferSrc: ArrayBuffer, width: number, height: number, mipmapLevel?: number): boolean;
  }
  export {};
}
declare module "engine/platform/device" {
  export enum Environment {
    Unknown = "Unknown",
    Browser = "Browser",
    Devtool = "Devtool",
    Mobile = "Mobile",
  }
  export enum Platform {
    Unknown = "Unknown",
    Android = "Android",
    IOS = "IOS",
  }
  export enum GroupPlatform {
    ETC2 = "etc2",
    ETC1 = "etc1",
    PVR = "ios",
    IOS = "ios",
    ASTC = "astc",
    DEFAULT = "",
  }
  export default class Device {
    readonly screenHeight: number;
    readonly screenWidth: number;
    readonly pixelHeight: number;
    readonly pixelWidth: number;
    readonly pixelRatio: number;
    readonly environment: Environment;
    readonly platform: Platform;
    constructor();
    getGroupPlatform(): GroupPlatform;
    isDevtool(): boolean;
  }
}
declare module "engine/assets/classes/renderTexture" {
  import Color from "engine/math/color";
  import Texture2D from "engine/assets/classes/texture2D";
  /**
   * RenderTexture。
   * @export
   * @class RenderTexture
   * @extends {Texture2D}
   */
  export default class RenderTexture extends Texture2D {
    /**
     * 创建RenderTexture实例。
     * @param {number} width 宽度。
     * @param {number} height 高度。
     * @param {number} needSampleCount 期望的采样数，实际是否支持需要根据硬件
     * @param {wgfx.ImageDesc} [imageDesc={}] 贴图配置。
     * @memberof RenderTexture
     */
    constructor(width: number, height: number, needSampleCount?: number, imageDesc?: wgfx.ImageDesc);
    /**
     * 清空RenderTexture。
     * @param {boolean} isClearColor 是否清除颜色。
     * @param {boolean} isClearDepth 是否清除深度。
     * @param {Color} [clearColor=Color.WHITE] 清除颜色。
     * @param {number} [clearDepth=1] 清除深度。
     * @memberof RenderTexture
     * @returns {void}
     */
    clear(isClearColor: boolean, isClearDepth: boolean, clearColor?: Color, clearDepth?: number): void;
    /**
     * 销毁RenderTexture。
     * @memberof RenderTexture
     */
    destroy(): void;
  }
}
declare module "engine/game/baseCamera" {
  import RenderTexture from "engine/assets/classes/renderTexture";
  import Color from "engine/math/color";
  import Matrix4 from "engine/math/matrix4";
  import Rect from "engine/math/rect";
  import Vector3 from "engine/math/vector3";
  import { Delegate } from "engine/misc/delegate";
  import BaseCameraRenderProcess from "engine/render/process/baseCameraRenderProcess";
  import Screen from "engine/render/screen";
  import Entity from "engine/scene/entity";
  import RenderSystem from "engine/system/render";
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import { M4ReadOnly, V3ReadOnly } from "engine/math/types";
  interface ICameraCullResult {
    hash: number;
    len?: number;
    objectIdx?: number;
    distanceIdx?: number;
    objects?: Uint32Array;
    distances?: Float32Array;
    u32View?: Uint32Array;
    f32View?: Float32Array;
  }
  export enum CameraProjectionType {
    /**
     * 透视
     */
    Perspective = 0,
    /**
     * 正交
     */
    Orthographic = 1,
  }
  export enum CameraAspectType {
    /**
     * 根据屏幕宽高自动适配
     */
    Auto = 0,
    /**
     * 根据相机中的设置
     */
    Custom = 1,
    /**
     * 等同于Custom
     */
    Setable = 1,
  }
  export enum ClearFlag {
    Color = 1,
    Depth = 2,
    Stencil = 4,
  }
  export default abstract class BaseCamera extends Component {
    /**
     * 宽高比模式
     *
     * @static
     * @memberof BaseCamera
     */
    static readonly AspectType: Readonly<typeof CameraAspectType>;
    /**
     * 投影类型
     *
     * @static
     * @memberof BaseCamera
     */
    static readonly ProjectionType: Readonly<typeof CameraProjectionType>;
    /**
     * 渲染目标纹理
     * 为空时表示相机直接渲染到主屏幕
     *
     * @type {Nullable<RenderTexture>}
     * @memberof BaseCamera
     */
    get targetTexture(): Nullable<RenderTexture>;
    set targetTexture(val: Nullable<RenderTexture>);
    /**
     * 相机深度，决定了相机的渲染顺序，深度小的先被渲染
     *
     * @readonly
     * @type {number}
     * @memberof BaseCamera
     */
    get depth(): number;
    set depth(val: number);
    /**
     * 剔除掩码，有效值：0~0x00ffffff。
     * 剔除时将使用该值与MeshRenderer的cullingMask做按位与，有值时才渲染
     *
     * @type {number}
     * @memberof BaseCamera
     */
    get cullingMask(): number;
    set cullingMask(cullingMask: number);
    get clearFlag(): number;
    /**
     * 清除颜色缓冲的值
     * 暂不支持clearColor.r = 255 这种写法
     *
     * @type {Color}
     * @memberof BaseCamera
     */
    get clearColor(): Color;
    set clearColor(val: Color);
    /**
     * 清除深度缓冲的值，范围0-1
     *
     * @type {number}
     * @memberof BaseCamera
     */
    get clearDepth(): number;
    set clearDepth(val: number);
    /**
     * 清除模板缓冲的值，范围0-255
     *
     * @type {number}
     * @memberof BaseCamera
     */
    get clearStencil(): number;
    set clearStencil(val: number);
    get isClearColor(): boolean;
    set isClearColor(val: boolean);
    /**
     *是否清除深度缓冲
     *
     * @type {boolean}
     * @memberof BaseCamera
     */
    get isClearDepth(): boolean;
    set isClearDepth(val: boolean);
    /**
     * 是否清除模板缓冲
     *
     * @type {boolean}
     * @memberof BaseCamera
     */
    get isClearStencil(): boolean;
    set isClearStencil(val: boolean);
    /**
     * 视野大小，用角度表示，透视模式专用
     */
    get fieldOfView(): number;
    set fieldOfView(val: number);
    /**
     * 视野大小，用弧度表示，透视模式专用
     */
    get fieldOfViewRadians(): number;
    set fieldOfViewRadians(val: number);
    /**
     * 正交相机视野高的一半
     */
    get orthographicSize(): number;
    set orthographicSize(val: number);
    /**
     * 相机宽高比模式
     *
     * @type {CameraAspectType}
     * @memberof BaseCamera
     */
    get aspectType(): CameraAspectType;
    set aspectType(val: CameraAspectType);
    /**
     * 相机宽高比
     * 仅当CameraAspectType = Custom 时可设置
     *
     * @type {CameraAspectType}
     * @memberof BaseCamera
     */
    get aspect(): number;
    set aspect(val: number);
    /**
     * 投影类型
     *
     * @type {CameraProjectionType}
     * @memberof BaseCamera
     */
    get projectionType(): CameraProjectionType;
    set projectionType(val: CameraProjectionType);
    /**
     * 相机近剪裁面
     *
     * @type {number}
     * @memberof BaseCamera
     */
    get nearClipPlane(): number;
    set nearClipPlane(val: number);
    /**
     * 相机远剪裁面
     *
     * @type {number}
     * @memberof BaseCamera
     */
    get farClipPlane(): number;
    set farClipPlane(val: number);
    /**
     * 投影矩阵
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof BaseCamera
     */
    get projectionMatrix(): M4ReadOnly;
    /**
     * 观察矩阵
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof BaseCamera
     */
    get viewMatrix(): M4ReadOnly;
    /**
     * 观察矩阵的逆
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof BaseCamera
     */
    get viewMatrixInverse(): M4ReadOnly;
    constructor(entity: Entity);
    /**
     * 将世界坐标系位置转换到齐次裁剪空间
     *
     * @param {V3ReadOnly} worldPos 世界空间坐标
     * @param {Vector3} [dst] 若传入，则输出计算结果到该向量
     * @returns {Vector3} 转换后的坐标
     * @memberof BaseCamera
     */
    convertWorldPositionToClip(worldPos: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 将齐次裁剪空间转换到世界坐标系位置
     *
     * @param {V3ReadOnly} worldPos 齐次裁剪空间坐标
     * @param {Vector3} [dst] 若传入，则输出计算结果到该向量
     * @returns {Vector3} 转换后的坐标
     * @memberof BaseCamera
     */
    convertClipPositionToWorld(clipPos: V3ReadOnly, dst?: Vector3): Vector3;
  }
  export {};
}
declare module "engine/render/process/renderProcess" {
  import MeshRenderer from "engine/game/3D/meshRenderer";
  export default abstract class RenderProcess {
    execProcess(process: RenderProcess): void;
    drawRenderDraws(renderDraws: wxGA.RenderDraw[]): void;
    abstract clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    abstract resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    abstract clearAllObjectsRenderCache(): void;
  }
}
declare module "engine/render/process/baseCameraRenderProcess" {
  import BaseCamera from "engine/game/baseCamera";
  import RenderSystem from "engine/system/render";
  import { Nullable } from "engine/type";
  import Screen from "engine/render/screen";
  import RenderProcess from "engine/render/process/renderProcess";
  export default abstract class BaseCameraRenderProcess extends RenderProcess {
    constructor(camera: BaseCamera, scene: RenderSystem, mainScreen: Screen);
    setIsMainScreen(isMainScreen: boolean): void;
    setRenderViewDirty(): void;
    update(): void;
    destroy(): void;
  }
}
declare module "engine/materials/shaderDefination" {
  export default class ShaderDefination {
    toggleMap?: {
      [key: string]: boolean;
    };
    valueMap?: {
      [key: string]: number;
    };
    toggleDefine(key: string, on: boolean): void;
    getToggle(key: string): boolean | undefined;
    setDefineValue(key: string, value: number): void;
    clone(): ShaderDefination;
  }
}
declare module "lib/utils/internalGetter" {
  export default class InternalGetter<T_KEY extends object, T_VAL extends object> {
    constructor(defaultFactory: (key: T_KEY) => T_VAL);
    get(key: T_KEY): T_VAL;
    setInternalFactory(key: T_KEY, factory: () => T_VAL): void;
    delete(key: T_KEY): void;
  }
}
declare module "engine/graphicResource/dynamicBuffer" {
  export default class DynamicBuffer implements IBuffer {
    get arrayBuffer(): ArrayBuffer;
    get byteSize(): number;
    constructor(isIndice: boolean, data: ArrayBuffer);
    /**
     * 上传数据至Gfx
     *
     * @param {number} offset
     * @param {number} length
     * @returns
     * @memberof DynamicBuffer
     */
    uploadData(offset: number, length: number): void;
    /**
     * 销毁
     *
     * @memberof DynamicBuffer
     */
    destroy(): void;
  }
}
declare module "engine/graphicResource/immutableBuffer" {
  export default class ImmutableBuffer {
    get byteSize(): number;
    constructor(isIndice: boolean, data: ArrayBuffer | ArrayBufferView);
    destroy(): void;
  }
}
declare module "engine/render/vertexLayout" {
  import InternalGetter from "lib/utils/internalGetter";
  export enum EnumVertexLayoutUsage {
    CUSTOM = 0,
    POSITION = 1,
    NORMAL = 2,
    TANGENT = 3,
    UV0 = 4,
    UV1 = 5,
    UV2 = 6,
    COLOR = 7,
    BONEINDEX = 8,
    BONEWEIGHT = 9,
  }
  export interface IVertexLayoutConfigItem {
    name: string;
    format: wgfx.EnumVertexFormat;
    offset: number;
    bufferIndex: number;
    usage: EnumVertexLayoutUsage;
  }
  export interface IVertexLayoutRawConfigItem {
    name: string;
    format: string;
    usage: EnumVertexLayoutUsage;
  }
  export const FormatInfo: {
    [format: string]: {
      size: number;
      format: wgfx.EnumVertexFormat;
    };
  };
  export default class VertexLayout {
    static createByRawConfig(rawConfig: IVertexLayoutRawConfigItem[]): VertexLayout;
    constructor(config: IVertexLayoutConfigItem[], stride: number);
    get stride(): number;
    /**
     * 根据usage获取该顶点布局配置Item的配置
     *
     * @param {EnumVertexLayoutUsage} usage
     * @returns {IVertexLayoutConfigItem}
     * @memberof VertexLayout
     */
    getConfigByUsage(usage: EnumVertexLayoutUsage): IVertexLayoutConfigItem;
    /**
     * 根据name获取该顶点布局配置Item的配置
     *
     * @param {EnumVertexLayoutUsage} usage
     * @returns {IVertexLayoutConfigItem}
     * @memberof VertexLayout
     */
    getConfigByName(name: string): IVertexLayoutConfigItem;
    getConfigs(): IVertexLayoutConfigItem[];
    /**
     * 获取该顶点布局需要多少VertexBuffer
     *
     * @returns {number}
     * @memberof VertexLayout
     */
    getBufferNeededCount(): number;
  }
  export const vertexLayout2State: InternalGetter<VertexLayout, wxGA.VertexLayout>;
}
declare module "engine/render/buildinVertexLayout" {
  import VertexLayout, { EnumVertexLayoutUsage } from "engine/render/vertexLayout";
  interface IVertexLayoutRawItem {
    name: string;
    byteSize: number;
    format: wgfx.EnumVertexFormat;
    bufferIndex: number;
    usage: EnumVertexLayoutUsage;
  }
  interface IVertexLayoutRawItemMap {
    [key: string]: IVertexLayoutRawItem;
  }
  class BuildInVertexLayoutFactory {
    constructor(rawItemMap: IVertexLayoutRawItemMap);
    /**
     * 通过一个key得到vertexLayout
     *
     * @param {string} key 顶点格式，用逗号分割，例如 POSITION,NORMAL,UV
     * @returns {VertexLayout}
     * @memberof BuildInVertexLayoutFactory
     */
    getVertexLayout(key: string): VertexLayout;
    /**
     * 给定一个VertexLayout，返回其扩充过UV1的版本
     * @param vl
     * @returns {VertexLayout}
     */
    buildVertexLightmapLayout(vl: VertexLayout): VertexLayout;
  }
  class Build2DVertexLayoutFactory {
    readonly changeSize: number;
    constructor();
    init(): void;
    addBuildin2DVertexLayout(): void;
    getBuildin2DVertexLayout(vertexNum: number): VertexLayout;
    getBuildin2DVertexLayoutByIndex(idx: number): wxGA.VertexLayout;
  }
  export const buildInVertexLayoutFactory3D: BuildInVertexLayoutFactory;
  export const buildin2DVertexLayout: VertexLayout;
  export const buildin2DVertexLayoutFactory: Build2DVertexLayoutFactory;
  export {};
}
declare module "engine/assets/classes/mesh" {
  import BoundBall from "engine/math/boundBall";
  import BoundBox from "engine/math/boundBox";
  import VertexLayout from "engine/render/vertexLayout";
  import { Nullable, DeepImmutable } from "engine/type";
  import BaseResource from "engine/assets/classes/baseResource";
  /**
   * @public
   */
  export default class Mesh extends BaseResource {
    static readonly MAX_BONECOUNT = 96;
    constructor(vertexLayout: VertexLayout, vertexBuffers: IBuffer[], indiceBuffer: IBuffer);
    /**
     * 给外部init mesh时使用，这个init方法把DynamicBuffer、createNativeBuffer等底层方法在本函数内执行，这些内部接口无需对外暴露。
     *
     * @static
     * @param {VertexLayout} vertexLayout
     * @param {ArrayBuffer[]} vArrayBuffers
     * @param {ArrayBuffer} iArrayBuffer
     * @returns {Mesh}
     * @memberof Mesh
     */
    static createFromDynamicArrayBuffer(vertexLayout: VertexLayout, vArrayBuffer: ArrayBuffer, iArrayBuffer: ArrayBuffer): Mesh;
    /**
     * 包围球，只读
     *
     * @readonly
     * @type {DeepImmutable<BoundBall>}
     * @memberof Mesh
     */
    get boundBall(): DeepImmutable<BoundBall>;
    /**
     * 包围盒，只读
     *
     * @readonly
     * @type {DeepImmutable<BoundBall>}
     * @memberof Mesh
     */
    get boundBox(): DeepImmutable<BoundBox>;
    /**
     * 仅适用于dynamic模式的Mesh
     *
     * @param {number} vBufferOffset
     * @param {number} vBufferLength
     * @param {number} iBufferOffset
     * @param {number} iBufferLength
     * @memberof Mesh
     */
    uploadBufferData(vBufferOffset: number, vBufferLength: number, iBufferOffset: number, iBufferLength: number): void;
    /**
     * 获得Mesh的骨骼数量
     *
     * @returns {number}
     * @memberof Mesh
     */
    getBoneCount(): number;
    /**
     * 获取当前mesh有多少subMesh
     *
     * @returns {number}
     * @memberof Mesh
     */
    getSubMeshCount(): number;
    /**
     * 获取指定序号的subMesh的索引起始点
     *
     * @param {number} subMeshIndex
     * @returns {number} 索引起始点,返回-1代表SubMesh不存在
     * @memberof Mesh
     */
    getIndiceStart(subMeshIndex: number): number;
    /**
     * 获取指定序号的subMesh的索引长度
     *
     * @param {number} subMeshIndex
     * @returns {number} 索引长度，返回-1代表SubMesh不存在
     * @memberof Mesh
     */
    getIndiceLength(subMeshIndex: number): number;
    /**
     * 获取指定序号的subMesh的材质序号
     *
     *
     * @param {number} subMeshIndex
     * @returns {number} 材质序号，返回-1代表subMesh不存在
     * @memberof Mesh
     */
    getMaterialIndex(subMeshIndex: number): number;
  }
}
declare module "engine/game/particles/libs/gradientColor" {
  import Color from "engine/math/color";
  export enum GradientMode {
    Blend = 1,
    Fixed = 2,
  }
  export interface IGradientPoint<T extends number | Color> {
    location: number;
    value: T;
  }
  export type GradientPointAlpha = IGradientPoint<number>;
  export type GradientPointColor = IGradientPoint<Color>;
  export interface ISerializeData {
    mode: GradientMode;
    alpha: number[];
    color: number[];
  }
  export interface GradientColorInfo {
    colors: GradientPointColor[];
    alphas: GradientPointAlpha[];
  }
  export default class GradientColor {
    /**
     * @param data data: { mode: GradientMode, alpha: number[], color: number[] }
     * alpha: location1,a1, location2,a2, ...
     * color: location1,r1,g1,b1,a1, location2,r2,g2,b2,a2, ...
     */
    static Deserialize(json: ISerializeData, gColor: GradientColor, context?: any, builtContext?: any): GradientColor;
    static GetPointsContainPercent(percent: number, rawData: Float32Array, stride: number): number[];
    static GetAlpha(percent: number, gColor: GradientColor): number;
    static GetColor(percent: number, gColor: GradientColor, dst?: Color): Color;
    /**
     * 获取渐变色中precent位置的颜色
     * @static
     * @param {number} percent
     * @param {GradientColor} gColor
     * @param {Color} [dst]
     * @returns {Color}
     * @memberof GradientColor
     */
    static GetMixedColor(percent: number, gColor: GradientColor, dst?: Color): Color;
    /**
     * 通过Color的数组来创建渐变色
     * @static
     * @param {Color[]} colors
     * @returns {GradientColor}
     * @memberof GradientColor
     */
    static CreateFromColorArr(colors: Color[]): GradientColor;
    static CreateFromColorLocationInfos(colorLocations: Array<IGradientPoint<Color>>): GradientColor;
    static defaultAlphaRaw: number[];
    static defaultColorRaw: number[];
    mode: GradientMode;
    constructor(alphaRaw?: Float32Array, colorRaw?: Float32Array);
    gen4pointsFromColor(dst?: Float32Array | number[]): Float32Array | number[];
    gen4pointsFromAlpha(dst?: Float32Array | number[]): Float32Array | number[];
    /**
     * 从gradient中生成四个采样点，如果不够四个则补齐，如果大于四个点，则仅选四个点。(目前用于粒子系统)
     * @param src source rawData
     * @param srcStride source rawData stride,
     * @param srcStartOffset 最开始的偏移量，现在color和alpha的都初始偏移量都是1，第一个位置表示点位数
     * @param srcPointCount source rawData的点数
     * @param dstStride 目标 rawData的步长
     * @param dst
     */
    gen4pointsFromGradient(src: Float32Array, srcStride: number, srcStartOffset: number, srcPointCount: number, dstStride: number, dst?: Float32Array | number[]): Float32Array | number[];
    get colorPointCount(): number;
    get alphaPointCount(): number;
    /**
     * 拷贝渐变色
     * @returns {GradientColor}
     * @memberof GradientColor
     */
    clone(): GradientColor;
    /**
     * 通过渐变色获取对应的color和alpha的数组
     * @returns {GradientColorInfo}
     * @memberof GradientColor
     */
    getGradientColorInfo(): GradientColorInfo;
  }
}
declare module "engine/game/particles/libs/hermiteCurve" {
  import { SmartArray } from "engine/misc/array";
  export interface ISerializeData {
    x: number[];
    y: number[];
    in: number[];
    out: number[];
  }
  export interface CurvePoint {
    x: number;
    y: number;
    in: number;
    out: number;
  }
  /**
   * 埃尔米特(Hermite)曲线
   */
  export default class HermiteCurve {
    /**
     * @param data data:
     */
    static Deserialize(
      data: ISerializeData,
      curve: HermiteCurve,
      context?: {
        [key: string]: any[];
      },
      builtContext?: {
        [key: string]: SmartArray<any>;
      },
    ): HermiteCurve;
    /**
     * 根据创建关键点，创建曲线
     * @static
     * @param {CurvePoint[]} points
     * @returns {HermiteCurve}
     * @memberof HermiteCurve
     */
    static CreateFromPoints(points: CurvePoint[]): HermiteCurve;
    maxValue: number;
    pointCount: number;
    constructor(raw?: Float32Array);
    /**
     * 设置曲线关键点
     * @param {Array<{ x: number; y: number; in?: number; out?: number }>} points
     * @memberof HermiteCurve
     */
    setPoints(
      points: Array<{
        x: number;
        y: number;
        in?: number;
        out?: number;
      }>,
    ): void;
    /**
     * 计算曲线插值结果
     * 插值计算参考 https://www.cubic.org/docs/hermite.htm
     * @param x 取值[0,1]范围
     */
    get(x: number): number;
    /**
     * 获取曲线的关键点
     * @returns {CurvePoint[]}
     * @memberof HermiteCurve
     */
    getCurvePoints(): CurvePoint[];
    /**
     * 拷贝曲线
     * @returns {HermiteCurve}
     * @memberof HermiteCurve
     */
    clone(): HermiteCurve;
  }
}
declare module "engine/game/particles/libs/advancedProperty" {
  import Color from "engine/math/color";
  import GradientColor from "engine/game/particles/libs/gradientColor";
  import HermiteCurve from "engine/game/particles/libs/hermiteCurve";
  abstract class AdvancedProperty {
    abstract get(t?: number): any;
    abstract getRaw(): Float32Array;
    abstract getMax(): any;
    abstract clone(): AdvancedProperty;
    abstract getUniformType(): Float32Array | Float32Array[];
    abstract getUniformArrayData(): number[] | Array<number[]>;
  }
  export { GradientColor, HermiteCurve };
  export class ConstantProperty extends AdvancedProperty {
    /**
     * 常数值
     *
     * @type {number}
     * @memberof ConstantProperty
     */
    value: number;
    constructor(value?: number);
    get(t?: number): number;
    /**
     * 获取最大值，也就是常数值本身
     *
     * @returns {number}
     * @memberof ConstantProperty
     */
    getMax(): number;
    /**
     * 把value赋给一个dst中的第一个值
     *
     * @param {Float32Array} [dst]
     * @returns {Float32Array}
     * @memberof ConstantProperty
     */
    getRaw(dst?: Float32Array): Float32Array;
    clone(): ConstantProperty;
    getUniformType(dst?: Float32Array): Float32Array;
    getUniformArrayData(dst?: number[]): number[];
  }
  export class CurveProperty extends AdvancedProperty {
    static HermiteCurve: typeof HermiteCurve;
    curve: HermiteCurve;
    constructor(curve?: HermiteCurve);
    get(t: number): number;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): number;
    getUniformType(dst?: Float32Array): Float32Array;
    clone(): CurveProperty;
    getUniformArrayData(dst?: number[]): number[];
  }
  export class GradientProperty extends AdvancedProperty {
    static initGradientProperty(): GradientProperty;
    gColor: GradientColor;
    constructor(gColor?: GradientColor);
    get(percent: number): Color;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): any;
    getUniformType(colorDst?: Float32Array, alphaDst?: Float32Array): Float32Array[];
    getUniformArrayData(colorDst?: number[], alphaDst?: number[]): Array<number[]>;
    clone(): GradientProperty;
  }
  export class OneColorProperty extends AdvancedProperty {
    color: Color;
    constructor(color?: Color);
    get(): Color;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): any;
    getUniformType(): never[];
    clone(): OneColorProperty;
    getUniformArrayData(): never[];
  }
  export class TwoConstantsProperty extends AdvancedProperty {
    min: number;
    max: number;
    constructor(min?: number, max?: number);
    get(t?: number): number;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): number;
    getUniformType(dst?: Float32Array): Float32Array;
    getUniformArrayData(dst?: number[]): number[];
    clone(): TwoConstantsProperty;
  }
  export class TwoCurvesProperty extends AdvancedProperty {
    min: HermiteCurve;
    max: HermiteCurve;
    constructor(min?: HermiteCurve, max?: HermiteCurve);
    get(t: number): number;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): number;
    clone(): TwoCurvesProperty;
    getUniformType(dst?: Float32Array): Float32Array;
    getUniformArrayData(dst?: number[]): number[];
  }
  export class TwoGradientsProperty extends AdvancedProperty {
    min: GradientColor;
    max: GradientColor;
    constructor(min?: GradientColor, max?: GradientColor);
    get(percent: number): Color;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): any;
    getUniform(colorDst1: Float32Array | number[], alphaDst1: Float32Array | number[], colorDst2: Float32Array | number[], alphaDst2: Float32Array | number[]): Float32Array[] | number[][];
    clone(): TwoGradientsProperty;
    getUniformType(colorDst1?: Float32Array, alphaDst1?: Float32Array, colorDst2?: Float32Array, alphaDst2?: Float32Array): Float32Array[];
    getUniformArrayData(colorDst1?: number[], alphaDst1?: number[], colorDst2?: number[], alphaDst2?: number[]): number[][];
  }
  export class TwoColorsProperty extends AdvancedProperty {
    min: Color;
    max: Color;
    constructor(min?: Color, max?: Color);
    get(): Color;
    getRaw(dst?: Float32Array): Float32Array;
    getMax(): any;
    getUniformType(): never[];
    clone(): TwoColorsProperty;
    getUniformArrayData(): never[];
  }
}
declare module "engine/game/3D/lineRenderer" {
  import Color from "engine/math/color";
  import Vector3 from "engine/math/vector3";
  import { Nullable } from "engine/type";
  import { GradientColor } from "engine/game/particles/libs/advancedProperty";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  export enum LineAlignment {
    View = 0,
    Local = 1,
  }
  export enum LineTextureMode {
    Stretch = 0,
    Tile = 1,
  }
  /**
   * @public
   */
  export default class LineRenderer extends MeshRenderer {
    /**
     * 线上所有点的位置列表
     *
     * @type {Vector3[]}
     * @memberof LineRenderer
     */
    get positions(): Vector3[];
    set positions(p: Vector3[]);
    /**
     * 起始宽度
     * @type {number}
     * @memberof LineRenderer
     */
    get startWidth(): number;
    set startWidth(val: number);
    /**
     * 终止宽度
     * @type {number}
     * @memberof LineRenderer
     */
    get endWidth(): number;
    set endWidth(val: number);
    /**
     * 起始颜色
     * @type {Color}
     * @memberof LineRenderer
     */
    get startColor(): Color;
    set startColor(val: Color);
    /**
     * 终止颜色
     * @type {Color}
     * @memberof LineRenderer
     */
    get endColor(): Color;
    set endColor(val: Color);
    /**
     * 对齐方式
     * @type {LineAlignment}
     * @memberof LineRenderer
     */
    get alignment(): LineAlignment;
    set alignment(val: LineAlignment);
    /**
     * positions是否是世界坐标中的位置
     * @type {boolean}
     * @memberof LineRenderer
     */
    get useWorldSpace(): boolean;
    set useWorldSpace(val: boolean);
    /**
     * 渐变色
     * @type {GradientColor}
     * @memberof LineRenderer
     */
    get gColor(): Nullable<GradientColor>;
    set gColor(val: Nullable<GradientColor>);
    get posCount(): number;
    set posCount(val: number);
    linkup: boolean;
    getPosition(index: any): Vector3;
    setPosition(index: number, position: Vector3): boolean;
    getColor(percent: any, dst?: Color): Color;
    /**
     * 两个点分别生成自己的两个沿法相拉伸的兄弟点
     * @param pos1
     * @param pos2
     * @param width1
     * @param width2
     */
    genBrotherPos(pos1: Vector3, pos2: Vector3, width1: number, width2: number): Vector3[];
    /**
     *
     * 通过空间中两个点的坐标与第三个点到第一个点的距离计算出第三个点的坐标
     * !!!设第三个点的y轴坐标与第一个点的y轴坐标相同（主观设定）
     * 联立关于第三个点坐标x和z的方程组
     * 1. (x - x1)*(x - x1) + (z - z1)*(z - z1) = width * width / 4
     * 2. (x1 - x2) * (x - x1) + (z1 - z2) * (z - z1) = 0  =>  x = -a * z + a * z1 + x1
     * 设 a = (z1 - z2) / (x1 - x2)
     * 相当于求解A*z*z + B*z + C = 0 一元二次方程
     * A = a*a + 1; B = -2*z1*(a*a + 1); C = (a*a + 1)*z1*z1 - width * width / 4
     * @param pos1 (x1, y1, z1)
     * @param pos2 (x2, y2, z2)
     * @param width 第三个点到第一个点的距离
     */
    genOnePointBroPosition(pos1: Vector3, pos2: Vector3, width: number, dst1?: Vector3, dst2?: Vector3): Vector3[];
    updateWidthAndColor(): void;
    setDirty(): void;
  }
}
declare module "engine/misc/pool" {
  interface TMetrics {
    totalAlloc: number;
    totalFree: number;
  }
  export default class Pool<T extends object> {
    metrics: TMetrics;
    constructor(
      cls: {
        new (...args: any[]): T;
      },
      args?: any[],
    );
    alloc(): T;
    free(obj: T): void;
    collect(): void;
  }
  export {};
}
declare module "engine/game/transform3D" {
  import Quaternion from "engine/math/quaternion";
  import Vector3 from "engine/math/vector3";
  import { Entity3D } from "engine/scene/scene";
  import TransformBase from "engine/game/transformBase";
  import { M4ReadOnly, V3ReadOnly, QuatReadOnly } from "engine/math/types";
  export default class Transform3D extends TransformBase {
    readonly entity: Entity3D;
    /**
     * 本地位置
     *
     * @type {Vector3}
     * @memberof Transform3D
     */
    get position(): Vector3;
    set position(val: Vector3);
    /**
     * 本地旋转，用四元数表示
     *
     * @type {Quaternion}
     * @memberof Transform3D
     */
    get quaternion(): Quaternion;
    set quaternion(val: Quaternion);
    /**
     * 本地旋转，用欧拉角表示
     *
     * @type {Vector3}
     * @memberof Transform3D
     */
    get euler(): Vector3;
    set euler(val: Vector3);
    /**
     * 本地缩放
     *
     * @type {Vector3}
     * @memberof Transform3D
     */
    get scale(): Vector3;
    set scale(val: Vector3);
    /**
     * 本地RTS矩阵，只读
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof Transform3D
     */
    get localMatrix(): M4ReadOnly;
    /**
     * 世界RTS矩阵，只读
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof Transform3D
     */
    get worldMatrix(): M4ReadOnly;
    /**
     * 世界位置，只读
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get worldPosition(): V3ReadOnly;
    /**
     * 世界空间缩放，只读
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get worldScale(): V3ReadOnly;
    /**
     * 世界空间旋转，用矩阵表示
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof Transform3D
     */
    get worldRotationMatrix(): M4ReadOnly;
    /**
     * 世界空间旋转，用四元数表示
     *
     * @readonly
     * @type {QuatReadOnly}
     * @memberof Transform3D
     */
    get worldQuaternion(): QuatReadOnly;
    /**
     * 世界空间旋转，用欧拉角表示
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get worldEuler(): V3ReadOnly;
    /**
     * 世界空间前方向，只读
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get forward(): V3ReadOnly;
    /**
     * 世界空间上方向，只读
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get up(): V3ReadOnly;
    /**
     * 世界空间右方向，只读
     *
     * @readonly
     * @type {V3ReadOnly}
     * @memberof Transform3D
     */
    get right(): V3ReadOnly;
    /**
     * 请使用engine.game.createEntity3D(name)创建3D对象
     *
     * @param {Entity3D} entity
     * @param {Float32Array} [_raw]
     * @param {number} [_offset]
     * @memberof Transform3D
     */
    constructor(entity: Entity3D, raw?: Float32Array, offset?: number);
    /**
     * 添加子节点，若子节点已存在父节点，则会先移除其父节点
     * 子节点必须是Transform3D
     *
     * @param {Transform3D} child 子节点
     * @returns {boolean} 添加是否成功
     * @memberof Transform3D
     */
    addChild(child: Transform3D): boolean;
    /**
     * 添加子节点到指定index，若子节点已存在父节点，则会先移除其父节点
     * 子节点必须是Transform3D
     *
     * @param {Transform3D} child 子节点
     * @param {number} index index顺序
     * @returns {boolean} 添加是否成功
     * @memberof Transform3D
     */
    addChildAtIndex(child: Transform3D, index: number): boolean;
    /**
     * 移除子节点
     *
     * @param {Transform3D} child 子节点
     * @returns {boolean} 是否移除成功
     * @memberof Transform3D
     */
    removeChild(child: Transform3D): boolean;
    /**
     * 将世界坐标转换为本地坐标系坐标
     *
     * @param {V3ReadOnly} worldPosition 世界坐标
     * @param {Vector3} [dst] 是否将计算结果输出到Dst
     * @returns {Vector3} 本地坐标系坐标
     * @memberof Transform3D
     */
    convertWorldPositionToLocal(worldPosition: V3ReadOnly, dst?: Vector3): Vector3;
    /**
     * 对自身做旋转变换。
     *
     * @param {Vector3} rotation 旋转幅度。
     * @param {boolean} [isLocal] 是否局部空间。
     * @param {boolean} [isRadian] 是否弧度制。
     * @memberof Transform3D
     */
    rotate(rotation: V3ReadOnly, isLocal?: boolean, isRadian?: boolean): void;
  }
}
declare module "engine/game/3D/skinnedMeshRenderer" {
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import { Entity3D } from "engine/scene/scene";
  import Mesh from "engine/assets/classes/mesh";
  /**
   * @public
   */
  export default class SkinnedMeshRenderer extends MeshRenderer {
    /**
     * 骨骼数量
     *
     * @readonly
     * @memberof SkinnedMeshRenderer
     */
    get boneCount(): number;
    constructor(entity: Entity3D);
  }
}
declare module "engine/game/3D/trailRenderer" {
  import Camera from "engine/game/3D/camera";
  import Color from "engine/math/color";
  import Vector3 from "engine/math/vector3";
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import { GradientColor, HermiteCurve } from "engine/game/particles/libs/advancedProperty";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  export enum TrailAlignment {
    View = 0,
    Local = 1,
  }
  export enum TrailTextureMode {
    Stretch = 0,
    Tile = 1,
  }
  /**
   * @public
   */
  export default class TrailRenderer extends MeshRenderer {
    /**
     * 起始宽度
     * @type {number}
     * @memberof TrailRenderer
     */
    get startWidth(): number;
    set startWidth(val: number);
    /**
     * 中止宽度
     * @type {number}
     * @memberof TrailRenderer
     */
    get endWidth(): number;
    set endWidth(val: number);
    /**
     * 尾迹持续的时间
     * @type {number}
     * @memberof TrailRenderer
     */
    get time(): number;
    set time(val: number);
    /**
     * 宽度曲线
     * @type {HermiteCurve}
     * @memberof TrailRenderer
     */
    get widthCurve(): HermiteCurve;
    set widthCurve(val: HermiteCurve);
    /**
     * 宽度系数
     * @type {number}
     * @memberof TrailRenderer
     */
    get widthMultiplier(): number;
    set widthMultiplier(val: number);
    /**
     * 起始颜色
     * @type {Color}
     * @memberof TrailRenderer
     */
    get startColor(): Color;
    set startColor(val: Color);
    /**
     * 终止颜色
     * @type {Color}
     * @memberof TrailRenderer
     */
    get endColor(): Color;
    set endColor(val: Color);
    /**
     * 渐变色
     * @type {GradientColor}
     * @memberof TrailRenderer
     */
    get gColor(): GradientColor;
    set gColor(val: GradientColor);
    /**
     * 尾迹中一个面片的最小长度
     * @type {number}
     * @memberof TrailRenderer
     */
    get minVertexDistance(): number;
    set minVertexDistance(val: number);
    /**
     * 尾迹呈现方式
     * @type {TrailAlignment}
     * @memberof TrailRenderer
     */
    get alignment(): TrailAlignment;
    set alignment(val: TrailAlignment);
    /**
     * 贴图模式
     * @type {TrailTextureMode}
     * @memberof TrailRenderer
     */
    get textureMode(): TrailTextureMode;
    set textureMode(val: TrailTextureMode);
    get lastPosition(): Vector3;
    set lastPosition(val: Vector3);
    get curPosition(): Vector3;
    set curPosition(val: Vector3);
    get totalLength(): number;
    get camera(): Camera;
  }
}
declare module "engine/game/particles/libs/boxShape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import { default as ParticleShape, EmitFromBox } from "engine/game/particles/libs/shape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleBoxShape extends ParticleShape {
    static createDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    static createByDefaultVal(particle: Particle): ParticleBoxShape;
    /**
     * 粒子从盒子的哪个位置喷射
     * @type {EmitFromBox}
     * @memberof ParticleBoxShape
     */
    get emitFrom(): EmitFromBox;
    set emitFrom(val: EmitFromBox);
    /**
     * 盒子表面的厚度
     * @type {Vector3}
     * @memberof ParticleBoxShape
     */
    get boxThickness(): Vector3;
    set boxThickness(val: Vector3);
    getEmitPositionAndDirection(dst: {
      position: Vector3;
      direction: Vector3;
    }): {
      position: Vector3;
      direction: Vector3;
    };
    /**
     * 获取喷射出的粒子的位置和速度
     * @param {Float32Array} dst
     * @param {{ posOffset: number; dirOffset: number }} posDirtOffsetMap
     * @memberof ParticleBoxShape
     */
    getEmitPosAndDir(
      dst: Float32Array,
      posDirtOffsetMap: {
        posOffset: number;
        dirOffset: number;
      },
    ): void;
  }
  export {};
}
declare module "engine/game/particles/libs/arcShape" {
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import { ArcMode, ParticleShape } from "engine/game/particles/libs/shape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleArcShape extends ParticleShape {
    static getArcShapeDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
    /**
     * 弧半径
     * @type {number}
     * @memberof ParticleArcShape
     */
    get radius(): number;
    set radius(val: number);
    /**
     * 弧半径厚度
     * @type {number}
     * @memberof ParticleArcShape
     */
    get radiusThickness(): number;
    set radiusThickness(val: number);
    /**
     * 弧角度
     * @type {number}
     * @memberof ParticleArcShape
     */
    get arc(): number;
    set arc(val: number);
    /**
     * 发射模式
     * @type {ArcMode}
     * @memberof ParticleArcShape
     */
    get arcMode(): ArcMode;
    set arcMode(val: ArcMode);
    /**
     * 0 to 1 控制粒子角度间隔，值为0将允许粒子在任何角度生成，0.1将仅在形状周围以10%间隔产生粒子；非ArcMode.Random时有效
     * @type {number}
     * @memberof ParticleArcShape
     */
    get arcSpread(): number;
    set arcSpread(val: number);
  }
  export {};
}
declare module "engine/game/particles/libs/circleShape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import ParticleArcShape from "engine/game/particles/libs/arcShape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleCircleShape extends ParticleArcShape {
    static createDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    static createByDefaultVal(particle: Particle): ParticleCircleShape;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
    getEmitPositionAndDirection(dst: { position: Vector3; direction: Vector3 }): void;
    /**
     * 获取喷射出的粒子的位置和速度
     * @param {Float32Array} dst
     * @param {{posOffset: number, dirOffset: number}} posDirtOffsetMap
     * @memberof ParticleCircleShape
     */
    getEmitPosAndDir(
      dst: Float32Array,
      posDirtOffsetMap: {
        posOffset: number;
        dirOffset: number;
      },
    ): void;
  }
  export {};
}
declare module "engine/game/particles/libs/coneShape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import ParticleArcShape from "engine/game/particles/libs/arcShape";
  import { EmitFromCone } from "engine/game/particles/libs/shape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleConeShape extends ParticleArcShape {
    static createDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    static createByDefaultVal(particle: Particle): ParticleConeShape;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
    /**
     * 圆锥的角度
     * @type {number}
     * @memberof ParticleConeShape
     */
    get angle(): number;
    set angle(val: number);
    /**
     * 圆锥母线长度
     * @type {number}
     * @memberof ParticleConeShape
     */
    get length(): number;
    set length(val: number);
    /**
     * 粒子发射的位置
     * @type {EmitFromCone}
     * @memberof ParticleConeShape
     */
    get emitFrom(): EmitFromCone;
    set emitFrom(val: EmitFromCone);
    getEmitPositionAndDirection(dst: { position: Vector3; direction: Vector3 }): void;
    /**
     * 获取喷射出的粒子的位置和速度
     * @param {Float32Array} dst
     * @param {{posOffset: number, dirOffset: number}} posDirtOffsetMap
     * @memberof ParticleConeShape
     */
    getEmitPosAndDir(
      dst: Float32Array,
      posDirtOffsetMap: {
        posOffset: number;
        dirOffset: number;
      },
    ): void;
  }
  export {};
}
declare module "engine/game/particles/libs/hemiSphereShape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import ParticleArcShape from "engine/game/particles/libs/arcShape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleHemiSphereShape extends ParticleArcShape {
    static createDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    static createByDefaultVal(particle: Particle): ParticleHemiSphereShape;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
    getEmitPositionAndDirection(dst: { position: Vector3; direction: Vector3 }): void;
    /**
     * 获取喷射出的粒子的位置和速度
     * @param {Float32Array} dst
     * @param {{posOffset: number, dirOffset: number}} posDirtOffsetMap
     * @memberof ParticleHemiSphereShape
     */
    getEmitPosAndDir(
      dst: Float32Array,
      posDirtOffsetMap: {
        posOffset: number;
        dirOffset: number;
      },
    ): void;
  }
  export {};
}
declare module "engine/game/particles/libs/sphereShape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  import ParticleArcShape from "engine/game/particles/libs/arcShape";
  type Particle = import("engine/game/particles/particle").default;
  export default class ParticleSphereShape extends ParticleArcShape {
    static createDefaultOffsetMap(): IParticleEmitterShapeOffsetMap;
    static createByDefaultVal(particle: Particle): ParticleSphereShape;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
    getEmitPositionAndDirection(dst: { position: Vector3; direction: Vector3 }): void;
    /**
     * 获取喷射出的粒子的位置和速度
     * @param {Float32Array} dst
     * @param {{posOffset: number, dirOffset: number}} posDirtOffsetMap
     * @memberof ParticleSphereShape
     */
    getEmitPosAndDir(
      dst: Float32Array,
      posDirtOffsetMap: {
        posOffset: number;
        dirOffset: number;
      },
    ): void;
  }
  export {};
}
declare module "engine/game/particles/particleModule" {
  import Particle from "engine/game/particles/particle";
  interface ParticleModule {}
  abstract class ParticleModule {
    static configToArray(config: any, offset: number, bufferData?: number[]): void;
  }
  export default ParticleModule;
}
declare module "engine/game/particles/modules/particleEmitterShape" {
  import { IParticleEmitterShape, IParticleEmitterShapeOffsetMap, IParticleOffsetMap } from "engine/game/particles/interface";
  import ParticleBoxShape from "engine/game/particles/libs/boxShape";
  import ParticleCircleShape from "engine/game/particles/libs/circleShape";
  import ParticleConeShape from "engine/game/particles/libs/coneShape";
  import ParticleHemiSphereShape from "engine/game/particles/libs/hemiSphereShape";
  import ParticleSphereShape from "engine/game/particles/libs/sphereShape";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum EmitterShapeProperties {
    position = "position",
    rotation = "rotation",
    scale = "scale",
    boxThickness = "boxThickness",
    radius = "radius",
    radiusThickness = "radiusThickness",
    arc = "arc",
    arcMode = "arcMode",
    arcSpread = "arcSpread",
    emitFrom = "emitFrom",
  }
  export enum EmitterShapeType {
    ParticleBoxShape = "ParticleBoxShape",
    ParticleCircleShape = "ParticleCircleShape",
    ParticleConeShape = "ParticleConeShape",
    ParticleHemiSphereShape = "ParticleHemiSphereShape",
    ParticleSphereShape = "ParticleSphereShape",
  }
  export default class ParticleEmitterShape extends ParticleModule {
    static configToArray(
      config: IParticleEmitterShape,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleEmitterShapeOffsetMap;
      curOffset: number;
    };
    static createByDefaultVal(particle: Particle): ParticleEmitterShape;
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: number[];
    };
    static ParticleBoxShape: typeof ParticleBoxShape;
    static ParticleConeShape: typeof ParticleConeShape;
    static ParticleCircleShape: typeof ParticleCircleShape;
    static ParticleHemiSphereShape: typeof ParticleHemiSphereShape;
    static ParticleSphereShape: typeof ParticleSphereShape;
    shape: ParticleBoxShape | ParticleConeShape | ParticleHemiSphereShape | ParticleSphereShape | ParticleCircleShape;
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/libs/shape" {
  import Vector3 from "engine/math/vector3";
  import { IParticleEmitterShapeOffsetMap } from "engine/game/particles/interface";
  type Particle = import("engine/game/particles/particle").default;
  export enum ArcMode {
    Random = 1,
    Loop = 2,
    PingPong = 3,
    BurstSpread = 4,
  }
  export enum EmitFromCone {
    Base = 1,
    Volume = 2,
  }
  export enum EmitFromBox {
    Volume = 1,
    Shell = 2,
    Edge = 3,
  }
  export const randomBetween: (v1: number, v2: number) => number;
  export class ParticleShape {
    static getShapeDefaultOffsetMap(): {
      position: {
        type: string;
        realBuffer: Float32Array;
        rawDataOffset: number;
      };
      rotation: {
        type: string;
        realBuffer: Float32Array;
        rawDataOffset: number;
      };
      scale: {
        type: string;
        realBuffer: Float32Array;
        rawDataOffset: number;
      };
    };
    /**
     * 发射器形状的位置
     * @type {Vector3}
     * @memberof ParticleShape
     */
    get position(): Vector3;
    set position(val: Vector3);
    /**
     * 发射器形状的旋转
     * @type {Vector3}
     * @memberof ParticleShape
     */
    get rotation(): Vector3;
    set rotation(val: Vector3);
    /**
     * 发射器形状的缩放
     * @type {Vector3}
     * @memberof ParticleShape
     */
    get scale(): Vector3;
    set scale(val: Vector3);
    static EmitFromBox: typeof EmitFromBox;
    static EmitFromCone: typeof EmitFromCone;
    static ArcMode: typeof ArcMode;
    constructor(particle: Particle, offsetMap: IParticleEmitterShapeOffsetMap);
  }
  export default ParticleShape;
}
declare module "engine/game/particles/interface" {
  import { ISerializeData as IGradient } from "engine/game/particles/libs/gradientColor";
  import { ISerializeData as ICurve } from "engine/game/particles/libs/hermiteCurve";
  import { ArcMode, EmitFromBox, EmitFromCone } from "engine/game/particles/libs/shape";
  export enum ParticleScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
  }
  export enum ParticleSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
  }
  export enum ParticleRenderMode {
    None = 0,
    Billboard = 1,
    StretchedBillboard = 2,
    HorizontalBillboard = 3,
    VerticalBillboard = 4,
    Mesh = 5,
  }
  export enum ParticleRenderAlignment {
    View = 1,
    World = 2,
    Local = 3,
    Facing = 4,
    Velocity = 5,
  }
  export enum AnimationType {
    WholeSheet = 1,
    SingleRow = 2,
  }
  export enum AdvancedType {
    Constant = "Constant",
    TwoConstants = "TwoConstants",
    Curve = "Curve",
    TwoCurves = "TwoCurves",
    OneColor = "OneColor",
    TwoColors = "TwoColors",
    Gradient = "Gradient",
    TwoGradients = "TwoGradients",
  }
  interface IProperty {
    type: AdvancedType;
    data: any;
  }
  interface IConstantProperty extends IProperty {
    type: AdvancedType.Constant;
    data: {
      value: number;
    };
  }
  interface ITwoConstantProperty extends IProperty {
    type: AdvancedType.TwoConstants;
    data: {
      min: number;
      max: number;
    };
  }
  interface ICurveProperty extends IProperty {
    type: AdvancedType.Curve;
    data: {
      curve: ICurve;
    };
  }
  interface ITwoCurveProperty extends IProperty {
    type: AdvancedType.TwoCurves;
    data: {
      min: ICurve;
      max: ICurve;
    };
  }
  interface IOneColorProperty extends IProperty {
    type: AdvancedType.OneColor;
    data: {
      color: number[];
    };
  }
  interface ITwoColorProperty extends IProperty {
    type: AdvancedType.TwoColors;
    data: {
      min: number[];
      max: number[];
    };
  }
  interface IGradientProperty extends IProperty {
    type: AdvancedType.Gradient;
    data: {
      gColor: IGradient;
    };
  }
  interface ITwoGradientProperty extends IProperty {
    type: AdvancedType.TwoGradients;
    data: {
      min: IGradient;
      max: IGradient;
    };
  }
  export type AdvancedProperty = IConstantProperty | ITwoConstantProperty | ICurveProperty | ITwoCurveProperty;
  export type ColorAdvancedProperty = IOneColorProperty | IGradientProperty | ITwoColorProperty | ITwoGradientProperty;
  export interface IParticleCommon {
    startLifetime: AdvancedProperty;
    startColor?: ColorAdvancedProperty;
    startSpeed?: AdvancedProperty;
    startSize3D: boolean;
    startSize?: AdvancedProperty;
    startSizeX?: AdvancedProperty;
    startSizeY?: AdvancedProperty;
    startSizeZ?: AdvancedProperty;
    startRotation3D?: boolean;
    startRotationX?: AdvancedProperty;
    startRotationY?: AdvancedProperty;
    startRotationZ?: AdvancedProperty;
    scalingMode?: ParticleScalingMode;
    simulationSpace?: ParticleSimulationSpace;
  }
  export interface IParticleEmitterBursts {
    time: number;
    count: AdvancedProperty;
    cycles: number;
    interval: number;
    probability: number;
  }
  export interface IParticleEmitter {
    playOnAwake: boolean;
    looping: boolean;
    duration: number;
    startDelay: IConstantProperty | ITwoConstantProperty;
    maxParticles: number;
    rateOverTime: AdvancedProperty;
    bursts: Array<IParticleEmitterBursts>;
  }
  export interface IParticleRenderer {
    renderAlignment?: ParticleRenderAlignment;
    renderMode: ParticleRenderMode;
    speedScale?: number;
    lengthScale?: number;
    mesh?: string;
  }
  export interface IParticleEmitterShape {
    shape: {
      type: IEmitterShapeName;
      data: {
        position: number[];
        rotation: number[];
        scale: number[];
        angle?: number;
        arc?: number;
        radius?: number;
        radiusThickness?: number;
        arcMode?: ArcMode;
        arcSpread?: number;
        length?: number;
        emitFrom?: EmitFromBox | EmitFromCone;
        boxThickness?: number[];
      };
    };
  }
  export interface IParticleSizeByLife {
    separateAxes: boolean;
    x: AdvancedProperty;
    y?: AdvancedProperty;
    z?: AdvancedProperty;
  }
  export interface IParticleRotationByLife {
    separateAxes: boolean;
    x?: AdvancedProperty;
    y?: AdvancedProperty;
    z: AdvancedProperty;
  }
  export interface IParticleSpeedByLife {
    x: AdvancedProperty;
    y: AdvancedProperty;
    z: AdvancedProperty;
  }
  export interface IParticleSpeedLimitByLife {
    separateAxes: boolean;
    x: AdvancedProperty;
    y?: AdvancedProperty;
    z?: AdvancedProperty;
    dampen: number;
  }
  export interface IParticleColorByLife {
    gColor: ColorAdvancedProperty;
  }
  export interface IParticleTextureSheetAnimation {
    tiles: number[];
    animationType: AnimationType;
    cycles: number;
    startFrame: AdvancedProperty;
    frameOverTime: AdvancedProperty;
  }
  export default interface IParticleConfig {
    common: IParticleCommon;
    emitter: IParticleEmitter;
    renderer: IParticleRenderer;
    emitterShape?: IParticleEmitterShape;
    sizeByLife?: IParticleSizeByLife;
    rotationByLife?: IParticleRotationByLife;
    speedByLife?: IParticleSpeedByLife;
    speedLimitByLife?: IParticleSpeedLimitByLife;
    colorByLife?: IParticleColorByLife;
    textureSheetAnimation?: IParticleTextureSheetAnimation;
  }
  export interface IAdvancedPropertyOffsetMap {
    type: AdvancedType;
    realBuffer?: Float32Array;
    rawDataOffset: number;
    rawDataLength: number;
    computedDataOffset?: number;
    computedDataLength?: number;
    uniformDataOffset?: number;
    uniformDataLength?: number;
  }
  export interface ISimplePropertyOffsetMap {
    rawDataOffset: number;
    rawDataLength?: number;
    realBuffer?: Float32Array;
  }
  export interface IVectorPropertyOffsetMap {
    type: "Vector2" | "Vector3" | "Vector4";
    realBuffer?: Float32Array;
    rawDataOffset: number;
    rawDataLength?: number;
  }
  export interface IParticleEmitterBurstsOffsetMap {
    time: ISimplePropertyOffsetMap;
    count: IAdvancedPropertyOffsetMap;
    cycles: ISimplePropertyOffsetMap;
    probability: ISimplePropertyOffsetMap;
    interval: ISimplePropertyOffsetMap;
  }
  export interface IParticleCommonOffsetMap {
    startLifetime: IAdvancedPropertyOffsetMap;
    startColor?: IAdvancedPropertyOffsetMap;
    startSpeed?: IAdvancedPropertyOffsetMap;
    startSize3D: ISimplePropertyOffsetMap;
    startSize?: IAdvancedPropertyOffsetMap;
    startSizeX?: IAdvancedPropertyOffsetMap;
    startSizeY?: IAdvancedPropertyOffsetMap;
    startSizeZ?: IAdvancedPropertyOffsetMap;
    startRotation3D?: ISimplePropertyOffsetMap;
    startRotationX?: IAdvancedPropertyOffsetMap;
    startRotationY?: IAdvancedPropertyOffsetMap;
    startRotationZ?: IAdvancedPropertyOffsetMap;
    scalingMode?: ISimplePropertyOffsetMap;
    simulationSpace?: ISimplePropertyOffsetMap;
  }
  export interface IParticleEmitterOffsetMap {
    rateOverTime: IAdvancedPropertyOffsetMap;
    startDelay: IAdvancedPropertyOffsetMap;
    duration: ISimplePropertyOffsetMap;
    looping: ISimplePropertyOffsetMap;
    maxParticles: ISimplePropertyOffsetMap;
    playOnAwake: ISimplePropertyOffsetMap;
    bursts: Array<IParticleEmitterBurstsOffsetMap>;
  }
  export interface IParticleRendererOffsetMap {
    renderAlignment?: ISimplePropertyOffsetMap;
    renderMode: ISimplePropertyOffsetMap;
    speedScale?: ISimplePropertyOffsetMap;
    lengthScale?: ISimplePropertyOffsetMap;
    mesh?: string;
  }
  export type IEmitterShapeName = "ParticleBoxShape" | "ParticleConeShape" | "ParticleHemiSphereShape" | "ParticleSphereShape" | "ParticleCircleShape";
  export interface IParticleEmitterShapeOffsetMap {
    type: IEmitterShapeName;
    position: IVectorPropertyOffsetMap;
    rotation: IVectorPropertyOffsetMap;
    scale: IVectorPropertyOffsetMap;
    angle?: ISimplePropertyOffsetMap;
    arc?: ISimplePropertyOffsetMap;
    radius?: ISimplePropertyOffsetMap;
    radiusThickness?: ISimplePropertyOffsetMap;
    arcMode?: ISimplePropertyOffsetMap;
    arcSpread?: ISimplePropertyOffsetMap;
    length?: ISimplePropertyOffsetMap;
    emitFrom?: ISimplePropertyOffsetMap;
    boxThickness?: IVectorPropertyOffsetMap;
  }
  export interface IParticleRotationByLifeOffsetMap {
    separateAxes: ISimplePropertyOffsetMap;
    x?: IAdvancedPropertyOffsetMap;
    y?: IAdvancedPropertyOffsetMap;
    z: IAdvancedPropertyOffsetMap;
  }
  export interface IParticleSizeByLifeOffsetMap {
    separateAxes: ISimplePropertyOffsetMap;
    x: IAdvancedPropertyOffsetMap;
    y?: IAdvancedPropertyOffsetMap;
    z?: IAdvancedPropertyOffsetMap;
  }
  export interface IParticleSpeedByLifeOffsetMap {
    x: IAdvancedPropertyOffsetMap;
    y: IAdvancedPropertyOffsetMap;
    z: IAdvancedPropertyOffsetMap;
  }
  export interface IParticleSpeedLimitByLifeOffsetMap {
    separateAxes: ISimplePropertyOffsetMap;
    x: IAdvancedPropertyOffsetMap;
    y?: IAdvancedPropertyOffsetMap;
    z?: IAdvancedPropertyOffsetMap;
    dampen: ISimplePropertyOffsetMap;
  }
  export interface IParticleColorByLifeOffsetMap {
    gColor: IAdvancedPropertyOffsetMap;
  }
  export interface IParticleTextureSheetAnimationOffsetMap {
    tiles: IVectorPropertyOffsetMap;
    animationType: ISimplePropertyOffsetMap;
    cycles: ISimplePropertyOffsetMap;
    startFrame: IAdvancedPropertyOffsetMap;
    frameOverTime: IAdvancedPropertyOffsetMap;
    randomRow?: ISimplePropertyOffsetMap;
    row?: ISimplePropertyOffsetMap;
  }
  export type IParticleModulesOffsetMapAll = IParticleCommonOffsetMap &
    IParticleEmitterOffsetMap &
    IParticleEmitterBurstsOffsetMap &
    IParticleRendererOffsetMap &
    IParticleEmitterShapeOffsetMap &
    IParticleRotationByLifeOffsetMap &
    IParticleSizeByLifeOffsetMap &
    IParticleSpeedByLifeOffsetMap &
    IParticleSpeedLimitByLifeOffsetMap &
    IParticleColorByLifeOffsetMap &
    IParticleTextureSheetAnimationOffsetMap;
  export type IParticleModulesOffsetMapOne =
    | IParticleCommonOffsetMap
    | IParticleEmitterOffsetMap
    | IParticleEmitterBurstsOffsetMap
    | IParticleRendererOffsetMap
    | IParticleEmitterShapeOffsetMap
    | IParticleRotationByLifeOffsetMap
    | IParticleSizeByLifeOffsetMap
    | IParticleSpeedByLifeOffsetMap
    | IParticleSpeedLimitByLifeOffsetMap
    | IParticleColorByLifeOffsetMap
    | IParticleTextureSheetAnimationOffsetMap;
  export interface IParticleOffsetMap {
    common: IParticleCommonOffsetMap;
    emitter: IParticleEmitterOffsetMap;
    renderer: IParticleRendererOffsetMap;
    emitterShape?: IParticleEmitterShapeOffsetMap;
    rotationByLife?: IParticleRotationByLifeOffsetMap;
    sizeByLife?: IParticleSizeByLifeOffsetMap;
    speedByLife?: IParticleSpeedByLifeOffsetMap;
    speedLimitByLife?: IParticleSpeedLimitByLifeOffsetMap;
    colorByLife?: IParticleColorByLifeOffsetMap;
    textureSheetAnimation?: IParticleTextureSheetAnimationOffsetMap;
    maxCount: number;
  }
  export {};
}
declare module "engine/game/particles/bufferManager" {
  import Vector2 from "engine/math/vector2";
  import Vector3 from "engine/math/vector3";
  import Vector4 from "engine/math/vector4";
  import { AdvancedProperty, ColorAdvancedProperty, IParticleModulesOffsetMapAll, IParticleModulesOffsetMapOne, IVectorPropertyOffsetMap } from "engine/game/particles/interface";
  import {
    ConstantProperty,
    CurveProperty,
    GradientProperty,
    OneColorProperty,
    TwoColorsProperty,
    TwoConstantsProperty,
    TwoCurvesProperty,
    TwoGradientsProperty,
  } from "engine/game/particles/libs/advancedProperty";
  export function handleAdvancedPropertyToData(
    config: AdvancedProperty | ColorAdvancedProperty,
    needUniform?: boolean,
    needComputed?: boolean,
  ): {
    rawData: number[];
    computedData: number[];
    uniformData: number[];
  } | null;
  export function handleVectorPropertyToData(
    arr: number[],
    offset: number,
    bufferData: number[],
  ):
    | false
    | {
        offsetMap: IVectorPropertyOffsetMap;
        curOffset: number;
      };
  export const randomBetween: (v1: number, v2: number) => number;
  export function getAdvancedPropertyComputedValue(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, isInit?: boolean): number;
  export function getAdvancedPropertyInitNumberValue(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, getMin?: boolean): number;
  export function getAdvancedPropertyUniformValue(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, dst: Float32Array): Float32Array;
  export function getColorAdvancedPropertyComputedValue(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, isFirst?: boolean): number;
  export function getColorAdvancedPropertyUniformValue(
    defaultBuffer: Float32Array,
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
    dstAlpha1?: Float32Array,
    dstColor1?: Float32Array,
    dstAlpha2?: Float32Array,
    dstColor2?: Float32Array,
  ):
    | Float32Array
    | {
        dstAlpha1: Float32Array | undefined;
        dstColor1: Float32Array | undefined;
        dstAlpha2: Float32Array | undefined;
        dstColor2: Float32Array | undefined;
      };
  export function getBooleanProperty(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, defaultVal?: boolean): boolean;
  export function setBooleanProperty(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, val: boolean): void;
  export function getNumProperty(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, defaultVal: number): number;
  export function setNumProperty(defaultBuffer: Float32Array, offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, val: number): void;
  export function getVectorProperty(
    defaultBuffer: Float32Array,
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
    dst: Vector2 | Vector3 | Vector4,
    defaultVal: Vector2 | Vector3 | Vector4,
  ): Vector2 | Vector3 | Vector4;
  export function setVectorProperty(offsetMap: IParticleModulesOffsetMapOne, key: keyof IParticleModulesOffsetMapAll, val: Vector2 | Vector3 | Vector4): void;
  export function getAdvancedProperty(
    defaultBuffer: Float32Array,
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
  ): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
  export function setAdvancedProperty(
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
    val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined,
  ): void;
  export function getColorAdvancedProperty(
    defaultBuffer: Float32Array,
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
  ): OneColorProperty | TwoColorsProperty | GradientProperty | TwoGradientsProperty | undefined;
  export function setColorAdvancedProperty(
    offsetMap: IParticleModulesOffsetMapOne,
    key: keyof IParticleModulesOffsetMapAll,
    val: OneColorProperty | TwoColorsProperty | GradientProperty | TwoGradientsProperty | undefined,
  ): void;
}
declare module "engine/game/particles/modules/particleColorByLife" {
  import { IParticleColorByLife, IParticleColorByLifeOffsetMap, IParticleOffsetMap } from "engine/game/particles/interface";
  import { GradientProperty, TwoGradientsProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum ColorProperties {
    gColor = "gColor",
  }
  export default class ParticleColorByLife extends ParticleModule {
    static configToArray(
      config: IParticleColorByLife,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleColorByLifeOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    }[];
    /**
     * 创建一个默认的ParticleColorByLife模块
     * 在IDE中给粒子新增一个colorByLife模块时会调用此方法
     * @static
     * @param {Particle} particle
     * @returns
     * @memberof ParticleColorByLife
     */
    static createByDefaultVal(particle: Particle): ParticleColorByLife;
    constructor(particle: Particle);
    /**
     * 渐变色信息
     * @type {(GradientProperty | TwoGradientsProperty)}
     * @memberof ParticleColorByLife
     */
    get gColor(): GradientProperty | TwoGradientsProperty;
    set gColor(val: GradientProperty | TwoGradientsProperty);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleRenderer" {
  import Mesh from "engine/assets/classes/mesh";
  import { IParticleOffsetMap, IParticleRenderer, IParticleRendererOffsetMap } from "engine/game/particles/interface";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum ParticleRenderMode {
    None = 0,
    Billboard = 1,
    StretchedBillboard = 2,
    HorizontalBillboard = 3,
    VerticalBillboard = 4,
    Mesh = 5,
  }
  export enum ParticleRenderAlignment {
    View = 1,
    World = 2,
    Local = 3,
    Facing = 4,
    Velocity = 5,
  }
  export enum ParticleSortMode {
    None = 0,
    ByDistance = 1,
    OldestInFront = 2,
    YoungestInFront = 3,
  }
  export enum RendererProperties {
    mesh = "mesh",
    speedScale = "speedScale",
    lengthScale = "lengthScale",
    renderMode = "renderMode",
    renderAlignment = "renderAlignment",
  }
  export default class ParticleRenderer extends ParticleModule {
    static configToArray(
      config: IParticleRenderer,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleRendererOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(
      uniformArr: number[] | Float32Array,
      renderMode: ParticleRenderMode,
      renderAlignment: ParticleRenderAlignment,
      lengthScale: number,
      speedScale?: number,
      cameraScale?: number,
    ): Float32Array | number[];
    static createByDefaultVal(particle: Particle): ParticleRenderer;
    /**
     * 根据速度计算粒子的大小在速度方向的拉伸长度（仅在strechedBillboard可用）
     * @type {number}
     * @memberof ParticleRenderer
     */
    get speedScale(): number;
    set speedScale(val: number);
    /**
     * 沿着粒子速度方向按比例拉伸粒子的当前尺寸。将此值设置为0会使粒子消失，有效长度为0。（仅在strechedBillboard可用）
     * @type {number}
     * @memberof ParticleRenderer
     */
    get lengthScale(): number;
    set lengthScale(val: number);
    /**
     * 粒子的mesh，若renderMode为Mesh，则必须对此属性赋值
     * @type {Mesh | undefined}
     * @memberof ParticleRenderer
     */
    get mesh(): Mesh | undefined;
    set mesh(val: Mesh | undefined);
    /**
     * 粒子渲染模式
     * @type {ParticleRenderMode}
     * @memberof ParticleRenderer
     */
    get renderMode(): ParticleRenderMode;
    set renderMode(val: ParticleRenderMode);
    /**
     * 对齐方式，决定Billboard粒子的朝向。
     * @type {ParticleRenderAlignment}
     * @memberof ParticleRenderer
     */
    get renderAlignment(): ParticleRenderAlignment;
    set renderAlignment(val: ParticleRenderAlignment);
    static RenderMode: typeof ParticleRenderMode;
    static RenderAlignment: typeof ParticleRenderAlignment;
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleCommon" {
  import { IParticleCommon, IParticleCommonOffsetMap } from "engine/game/particles/interface";
  import {
    ConstantProperty,
    CurveProperty,
    GradientProperty,
    OneColorProperty,
    TwoColorsProperty,
    TwoConstantsProperty,
    TwoCurvesProperty,
    TwoGradientsProperty,
  } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum ParticleScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
  }
  export enum ParticleSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
  }
  export enum CommonProperties {
    startSize3D = "startSize3D",
    startRotation3D = "startRotation3D",
    scalingMode = "scalingMode",
    simulationSpace = "simulationSpace",
    startLifetime = "startLifetime",
    startSize = "startSize",
    startSizeX = "startSizeX",
    startSizeY = "startSizeY",
    startSizeZ = "startSizeZ",
    startRotationX = "startRotationX",
    startRotationY = "startRotationY",
    startRotationZ = "startRotationZ",
    startColor = "startColor",
    startSpeed = "startSpeed",
  }
  export default class ParticleCommon extends ParticleModule {
    static configToArray(
      config: IParticleCommon,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleCommonOffsetMap;
      curOffset: number;
    };
    /**
     * 是否开启XYZ三个方向的大小设置。
     * @type {boolean}
     * @memberof ParticleCommon
     */
    get startSize3D(): boolean;
    set startSize3D(val: boolean);
    /**
     * 是否开启XYZ三个方向的旋转设置。
     * @type {boolean}
     * @memberof ParticleCommon
     */
    get startRotation3D(): boolean;
    set startRotation3D(val: boolean);
    /**
     * 缩放模式
     * @type {ParticleScalingMode}
     * @memberof ParticleCommon
     */
    get scalingMode(): ParticleScalingMode;
    set scalingMode(val: ParticleScalingMode);
    /**
     * 模拟粒子在世界空间或本地空间
     * @type {ParticleSimulationSpace}
     * @memberof ParticleCommon
     */
    get simulationSpace(): ParticleSimulationSpace;
    set simulationSpace(val: ParticleSimulationSpace);
    /**
     * 粒子的生命时长（单位 秒）
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
     * @memberof ParticleCommon
     */
    get startLifetime(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startLifetime(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 每个粒子的初始大小。
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startSize(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startSize(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startSize3D时，粒子在x轴的大小
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startSizeX(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startSizeX(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startSize3D时，粒子在y轴的大小
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startSizeY(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startSizeY(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startSize3D时，粒子在z轴的大小
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startSizeZ(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startSizeZ(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startRotation3D时，粒子在x轴的旋转值（角度）
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startRotationX(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startRotationX(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startRotation3D时，粒子在y轴的旋转值（角度）
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startRotationY(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startRotationY(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 开启startRotation3D时，粒子在z轴的旋转值（角度）
     * 不开启startRotation3D时，粒子的初始旋转角度，即startRotation
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startRotationZ(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startRotationZ(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 兼容旧版本逻辑，新版本没有startRotation属性，旧版本的startRotation对应新版本的startRotationZ
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
     * @memberof ParticleCommon
     */
    get startRotation(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startRotation(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 粒子初始颜色
     * @type {(OneColorProperty | GradientProperty | TwoColorsProperty | TwoGradientsProperty)}
     * @memberof ParticleCommon
     */
    get startColor(): GradientProperty | OneColorProperty | TwoGradientsProperty | TwoColorsProperty | undefined;
    set startColor(val: GradientProperty | OneColorProperty | TwoGradientsProperty | TwoColorsProperty | undefined);
    /**
     * 粒子初始速度
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleCommon
     */
    get startSpeed(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set startSpeed(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    static ScalingMode: typeof ParticleScalingMode;
    static SimulationSpace: typeof ParticleSimulationSpace;
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/libs/emitterBurst" {
  import { IParticleEmitterBursts, IParticleEmitterBurstsOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  type Particle = import("engine/game/particles/particle").default;
  export enum BurstProperties {
    count = "count",
    time = "time",
    cycles = "cycles",
    probability = "probability",
    interval = "interval",
  }
  export default class ParticleEmitterBurst {
    static configToArray(
      config: IParticleEmitterBursts,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: any;
      curOffset: number;
    };
    /**
     * 触发的时间/s
     * @type {number}
     * @memberof ParticleEmitterBurst
     */
    get time(): number;
    set time(val: number);
    /**
     * 每次发射的粒子数
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleEmitterBurst
     */
    get count(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set count(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    get countInitVal(): number;
    get countMaxVal(): number;
    /**
     * 循环次数，0=infinite
     * @type {number}
     * @memberof ParticleEmitterBurst
     */
    get cycles(): number;
    set cycles(val: number);
    /**
     * 触发的可能性，为0是，当做是1处理，因为unity 2017版本以前没有这个字段
     * @type {number}
     * @memberof ParticleEmitterBurst
     */
    get probability(): number;
    set probability(val: number);
    /**
     * 每次循环的间隔/s，必须大于0
     * @type {number}
     * @memberof ParticleEmitterBurst
     */
    get interval(): number;
    set interval(val: number);
    constructor(particle: Particle, offsetMap: IParticleEmitterBurstsOffsetMap);
    /**
     * 判断当前时刻要发射几个粒子
     * @param roundDuration 发射器当前轮次的时间
     * @returns number 要发射点粒子数
     */
    trigger(roundDuration: number): number;
    reset(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleEmitter" {
  import { IParticleEmitter, IParticleEmitterOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleEmitterBurst from "engine/game/particles/libs/emitterBurst";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum EmitterProperties {
    playOnAwake = "playOnAwake",
    looping = "looping",
    duration = "duration",
    maxParticles = "maxParticles",
    rateOverTime = "rateOverTime",
    startDelay = "startDelay",
    bursts = "bursts",
  }
  /**
   * 粒子发射器，控制粒子发射
   */
  export default class ParticleEmitter extends ParticleModule {
    static configToArray(
      config: IParticleEmitter,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleEmitterOffsetMap;
      curOffset: number;
    };
    static createByDefaultVal(particle: Particle): ParticleEmitter;
    /**
     * 发射器每秒排放的粒子数
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined)}
     * @memberof ParticleEmitter
     */
    get rateOverTime(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined;
    set rateOverTime(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty | undefined);
    /**
     * 延迟多少s发射第一个粒子 只影响第一个发出的粒子时间
     * @type {(ConstantProperty | TwoConstantsProperty | undefined)}
     * @memberof ParticleEmitter
     */
    get startDelay(): ConstantProperty | TwoConstantsProperty;
    set startDelay(val: ConstantProperty | TwoConstantsProperty);
    /**
     * 粒子是否在onAwake时自动播放
     * @type {boolean}
     * @memberof ParticleEmitter
     */
    get playOnAwake(): boolean;
    set playOnAwake(val: boolean);
    /**
     * 一次喷射周期的时常（单位秒）
     * @type {number}
     * @memberof ParticleEmitter
     */
    get duration(): number;
    set duration(val: number);
    /**
     * 粒子是否循环播放
     * @type {boolean}
     * @memberof ParticleEmitter
     */
    get looping(): boolean;
    set looping(val: boolean);
    /**
     * 设置最大的粒子数量（暂时在runtime时，只可减小，不能增大）
     * @type {number}
     * @memberof ParticleEmitter
     */
    get maxParticles(): number;
    set maxParticles(val: number);
    /**
     *
     * @type {boolean}
     * @memberof ParticleEmitter
     */
    get start(): boolean;
    set start(val: boolean);
    set startTotalTime(val: number);
    static ParticleEmitterBurst: typeof ParticleEmitterBurst;
    bursts: ParticleEmitterBurst[];
    constructor(particle: Particle);
    triggerPlayOnAwake(): void;
    emitParticle(activedParticleCount: any, curGameTime: number): number;
  }
  export {};
}
declare module "engine/game/particles/modules/particleRotationByLife" {
  import { IParticleOffsetMap, IParticleRotationByLife, IParticleRotationByLifeOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
  export enum RotationProperties {
    separateAxes = "separateAxes",
    x = "x",
    y = "y",
    z = "z",
  }
  /**
   * 粒子生命周期里，每秒转多少度rotaiton的模块
   */
  export default class ParticleRotationByLife extends ParticleModule {
    static configToArray(
      config: IParticleRotationByLife,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleRotationByLifeOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(bufferData: Float32Array, offsetMap: IParticleOffsetMap, uRotationByLife: Float32Array): Float32Array;
    static createByDefaultVal(particle: Particle): ParticleRotationByLife;
    /**
     * 旋转时是否三个轴分开
     * @type {boolean}
     * @memberof ParticleRotationByLife
     */
    get separateAxes(): boolean;
    set separateAxes(val: boolean);
    /**
     * separateAxes开启时，x轴的旋转角度的变化情况
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleRotationByLife
     */
    get x(): AdvancedProperty | undefined;
    set x(val: AdvancedProperty | undefined);
    /**
     * separateAxes开启时，y轴的旋转角度的变化情况
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleRotationByLife
     */
    get y(): AdvancedProperty | undefined;
    set y(val: AdvancedProperty | undefined);
    /**
     * separateAxes开启时，z轴的旋转角度的变化情况
     * separateAxes不开启时的默认旋转角度的变化情况
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleRotationByLife
     */
    get z(): AdvancedProperty;
    set z(val: AdvancedProperty);
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleSizeByLife" {
  import { IParticleOffsetMap, IParticleSizeByLife, IParticleSizeByLifeOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
  export enum SizeProperties {
    separateAxes = "separateAxes",
    x = "x",
    y = "y",
    z = "z",
  }
  export default class ParticleSizeByLife extends ParticleModule {
    static configToArray(
      config: IParticleSizeByLife,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleSizeByLifeOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(bufferData: Float32Array, offsetMap: IParticleSizeByLifeOffsetMap, uSizeByLife: Float32Array): Float32Array;
    static createByDefaultVal(particle: Particle): ParticleSizeByLife;
    /**
     * 是否分开计算三个轴向上粒子的大小
     * @type {boolean}
     * @memberof ParticleSizeByLife
     */
    get separateAxes(): boolean;
    set separateAxes(val: boolean);
    /**
     * separateAxes开启时，表示x轴上粒子大小的变化情况
     * separateAxes未开启时，表示xyz轴上粒子大小的变化情况
     * @type {AdvancedProperty}
     * @memberof ParticleSizeByLife
     */
    get x(): AdvancedProperty;
    set x(val: AdvancedProperty);
    /**
     * separateAxes开启时，表示y轴上粒子大小的变化情况
     * @type {AdvancedProperty}
     * @memberof ParticleSizeByLife
     */
    get y(): AdvancedProperty | undefined;
    set y(val: AdvancedProperty | undefined);
    get z(): AdvancedProperty | undefined;
    set z(val: AdvancedProperty | undefined);
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleSpeedByLife" {
  import { IParticleOffsetMap, IParticleSpeedByLife, IParticleSpeedByLifeOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
  export enum SpeedProperties {
    x = "x",
    y = "y",
    z = "z",
  }
  export default class ParticleSpeedByLife extends ParticleModule {
    static configToArray(
      config: IParticleSpeedByLife,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleSpeedByLifeOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(bufferData: Float32Array, offsetMap: IParticleSpeedByLifeOffsetMap, uSpeedByLife: Float32Array): Float32Array;
    static createByDefaultVal(particle: Particle): ParticleSpeedByLife;
    /**
     * x轴上粒子速度的值
     * @type {AdvancedProperty}
     * @memberof ParticleSpeedByLife
     */
    get x(): AdvancedProperty;
    set x(val: AdvancedProperty);
    /**
     * y轴上粒子速度的值
     * @type {AdvancedProperty}
     * @memberof ParticleSpeedByLife
     */
    get y(): AdvancedProperty;
    set y(val: AdvancedProperty);
    /**
     * z轴上粒子速度的值
     * @type {AdvancedProperty}
     * @memberof ParticleSpeedByLife
     */
    get z(): AdvancedProperty;
    set z(val: AdvancedProperty);
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleSpeedLimitByLife" {
  import { IParticleOffsetMap, IParticleSpeedLimitByLife, IParticleSpeedLimitByLifeOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  type AdvancedProperty = ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
  export enum SpeedLimitProperties {
    separateAxes = "separateAxes",
    dampen = "dampen",
    x = "x",
    y = "y",
    z = "z",
  }
  export default class ParticleSpeedLimitByLife extends ParticleModule {
    static configToArray(
      config: IParticleSpeedLimitByLife,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleSpeedLimitByLifeOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(bufferData: Float32Array, offsetMap: IParticleSpeedLimitByLifeOffsetMap, uSpeedLimitByLife: Float32Array): Float32Array;
    static createByDefaultVal(particle: Particle): ParticleSpeedLimitByLife;
    /**
     * 每个轴上的速度下限是否分开
     * @type {boolean}
     * @memberof ParticleSpeedLimitByLife
     */
    get separateAxes(): boolean;
    set separateAxes(val: boolean);
    /**
     * x轴上的速度下限
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleSpeedLimitByLife
     */
    get x(): AdvancedProperty | undefined;
    set x(val: AdvancedProperty | undefined);
    /**
     * y轴上的速度下限
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleSpeedLimitByLife
     */
    get y(): AdvancedProperty | undefined;
    set y(val: AdvancedProperty | undefined);
    /**
     * z轴上的速度下限
     * @type {(AdvancedProperty | undefined)}
     * @memberof ParticleSpeedLimitByLife
     */
    get z(): AdvancedProperty;
    set z(val: AdvancedProperty);
    /**
     * 阻尼值[0 - 1]
     * @type {number}
     * @memberof ParticleSpeedLimitByLife
     */
    get dampen(): number;
    set dampen(val: number);
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/modules/particleTextureSheetAnimation" {
  import Vector2 from "engine/math/vector2";
  import { IParticleOffsetMap, IParticleTextureSheetAnimation, IParticleTextureSheetAnimationOffsetMap } from "engine/game/particles/interface";
  import { ConstantProperty, CurveProperty, TwoConstantsProperty, TwoCurvesProperty } from "engine/game/particles/libs/advancedProperty";
  import ParticleModule from "engine/game/particles/particleModule";
  type Particle = import("engine/game/particles/particle").default;
  export enum FrameMode {
    Grid = 1,
    Sprites = 2,
  }
  export enum AnimationType {
    WholeSheet = 1,
    SingleRow = 2,
  }
  export enum TimeMode {
    Lifetime = 1,
    Speed = 2,
    FPS = 3,
  }
  export enum UVChannels {
    UV0 = 1,
    UV1 = 2,
    UV2 = 4,
    UV3 = 8,
  }
  export enum TextureSheetAnimationProperties {
    tiles = "tiles",
    animationType = "animationType",
    cycles = "cycles",
    frameOverTime = "frameOverTime",
    startFrame = "startFrame",
    randomRow = "randomRow",
    row = "row",
  }
  export default class ParticleTextureSheetAnimation extends ParticleModule {
    static configToArray(
      config: IParticleTextureSheetAnimation,
      offset: number,
      bufferData?: number[],
    ): {
      propertyOffsetMap: IParticleTextureSheetAnimationOffsetMap;
      curOffset: number;
    };
    static getUniformFromBuffer(
      bufferData: Float32Array,
      offsetMap: IParticleOffsetMap,
    ): {
      key: string;
      value: any[];
    };
    static setUniformValue(bufferData: Float32Array, offsetMap: IParticleTextureSheetAnimationOffsetMap, uTextureSheetAnimation: Float32Array): Float32Array;
    static createByDefaultVal(particle: Particle): ParticleTextureSheetAnimation;
    /**
     * 贴图的行列个数，x表示列数，y表示行数
     * @type {Vector2}
     * @memberof ParticleTextureSheetAnimation
     */
    get tiles(): Vector2;
    set tiles(val: Vector2);
    /**
     * 动画类型
     * @type {AnimationType}
     * @memberof ParticleTextureSheetAnimation
     */
    get animationType(): AnimationType;
    set animationType(val: AnimationType);
    /**
     * 贴图动画序列数的变化曲线
     * @type {(ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty)}
     * @memberof ParticleTextureSheetAnimation
     */
    get frameOverTime(): ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty;
    set frameOverTime(val: ConstantProperty | CurveProperty | TwoConstantsProperty | TwoCurvesProperty);
    /**
     * 初始序列帧数
     * @type {(ConstantProperty | TwoConstantsProperty)}
     * @memberof ParticleTextureSheetAnimation
     */
    get startFrame(): ConstantProperty | TwoConstantsProperty;
    set startFrame(val: ConstantProperty | TwoConstantsProperty);
    /**
     * 在粒子生命周期中的循环次数
     * @type {number}
     * @memberof ParticleTextureSheetAnimation
     */
    get cycles(): number;
    set cycles(val: number);
    get randomRow(): boolean;
    set randomRow(val: boolean);
    get row(): number;
    set row(val: number);
    static AnimationType: typeof AnimationType;
    static FrameMode: typeof FrameMode;
    constructor(particle: Particle);
    setUniform(): void;
  }
  export {};
}
declare module "engine/game/particles/particleVertexLayout" {
  import VertexLayout from "engine/render/vertexLayout";
  const particleVertexLayout: VertexLayout;
  export default particleVertexLayout;
}
declare module "engine/game/particles/particle" {
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import { Entity2D, Entity3D } from "engine/scene/scene";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import { IParticleOffsetMap } from "engine/game/particles/interface";
  import * as AdvancedProperty from "engine/game/particles/libs/advancedProperty";
  import ParticleColorByLife from "engine/game/particles/modules/particleColorByLife";
  import ParticleCommon from "engine/game/particles/modules/particleCommon";
  import ParticleEmitter from "engine/game/particles/modules/particleEmitter";
  import ParticleEmitterShape from "engine/game/particles/modules/particleEmitterShape";
  import ParticleRenderer from "engine/game/particles/modules/particleRenderer";
  import ParticleRotationByLife from "engine/game/particles/modules/particleRotationByLife";
  import ParticleSizeByLife from "engine/game/particles/modules/particleSizeByLife";
  import ParticleSpeedByLife from "engine/game/particles/modules/particleSpeedByLife";
  import ParticleSpeedLimitByLife from "engine/game/particles/modules/particleSpeedLimitByLife";
  import ParticleTextureSheetAnimation from "engine/game/particles/modules/particleTextureSheetAnimation";
  import ParticleModule from "engine/game/particles/particleModule";
  export default class Particle extends MeshRenderer {
    readonly entity: Entity3D | Entity2D;
    constructor(entity: Entity3D | Entity2D);
    set offsetMap(val: IParticleOffsetMap);
    static AdvancedProperty: typeof AdvancedProperty;
    static ParticleCommon: typeof ParticleCommon;
    static ParticleEmitter: typeof ParticleEmitter;
    static ParticleEmitterShape: typeof ParticleEmitterShape;
    static ParticleColorByLife: typeof ParticleColorByLife;
    static ParticleRotationByLife: typeof ParticleRotationByLife;
    static ParticleSizeByLife: typeof ParticleSizeByLife;
    static ParticleSpeedByLife: typeof ParticleSpeedByLife;
    static ParticleSpeedLimitByLife: typeof ParticleSpeedLimitByLife;
    static ParticleRenderer: typeof ParticleRenderer;
    static ParticleTextureSheetAnimation: typeof ParticleTextureSheetAnimation;
    modules: Map<typeof ParticleModule, ParticleModule>;
    removedModules: Map<typeof ParticleModule, ParticleModule>;
    common: ParticleCommon;
    emitter: ParticleEmitter;
    renderer: ParticleRenderer;
    emitterShape?: ParticleEmitterShape;
    rotationByLife?: ParticleRotationByLife;
    sizeByLife?: ParticleSizeByLife;
    speedByLife?: ParticleSpeedByLife;
    speedLimitByLife?: ParticleSpeedLimitByLife;
    colorByLife?: ParticleColorByLife;
    textureSheetAnimation?: ParticleTextureSheetAnimation;
    isMesh: boolean;
    particleMaxCount: number;
    rebuildBuffer(forceInit?: boolean): void;
  }
}
declare module "engine/game/nativeObjectPool/nativeObjectPool" {
  abstract class NativeObjectPool<T> {
    get(): T | undefined;
    release(instance: T): void;
  }
  class NativeEntity2DPool extends NativeObjectPool<wxGA.Entity2D> {
    constructor();
  }
  class NativeRenderDrawPool extends NativeObjectPool<wxGA.RenderDraw> {
    constructor();
  }
  export default class NativeObjectPools {
    static nativeEntity2DPool: NativeEntity2DPool;
    static nativeRenderDrawPool: NativeRenderDrawPool;
    static nativeRenderDraw2DPool: NativeRenderDrawPool;
    static init(): void;
  }
  export {};
}
declare module "engine/misc/hash" {
  export function strToHashTime33(str: string): number;
  export function arrayToHashTime33(arr: ArrayLike<number>): number;
}
declare module "engine/assets/classes/material" {
  import { Nullable } from "engine/type";
  import { IMaterialRenderStates } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  import Effect from "engine/assets/classes/effect";
  import Texture from "engine/assets/classes/texture";
  import Vector2 from "engine/math/vector2";
  import Vector3 from "engine/math/vector3";
  import Vector4 from "engine/math/vector4";
  import { EnumBlendFactor, EnumBlendOp, EnumCullMode, EnumStencilOp, EnumCompareFunc, EnumPrimitiveType } from "wgfx/def";
  export default class Material extends BaseResource {
    static BlendFactor: typeof EnumBlendFactor;
    static BlendOp: typeof EnumBlendOp;
    static CullMode: typeof EnumCullMode;
    static StencilOp: typeof EnumStencilOp;
    static CompareFunc: typeof EnumCompareFunc;
    static PrimitiveType: typeof EnumPrimitiveType;
    /**
     * 该材质的Effect
     * 当更换材质Effect时，相同名字的shaderProperties和texture会被拷贝，不同名字的值被丢弃
     *
     * @type {Effect}
     * @memberof Material
     */
    get effect(): Effect;
    set effect(effect: Effect);
    /**
     * 渲染顺序，相机按照renderQueue从小到大的顺序进行渲染
     * 注：renderQueue>2500时，被认为是一个透明物体，渲染时会按物体到相机距离从远到近进行渲染
     *
     * @type {number}
     * @memberof Material
     */
    get renderQueue(): number;
    set renderQueue(val: number);
    /**
     * 获取材质hash，可用于排序等
     * 这里计算比较耗时，请谨慎使用
     *
     * @readonly
     * @type {number}
     * @memberof Material
     */
    get hash(): number;
    /**
     * 当使用MeshRenderer.getMaterialAtIndex时，会生成一份拷贝材质，该属性指向原材质
     *
     * @readonly
     * @type {Nullable<Material>}
     * @memberof Material
     */
    get sourceMaterial(): Nullable<Material>;
    /**
     * 创建材质对象，可在构造函数传入effect，也可在创建后赋值
     * 材质必须设置effect才可以正常使用
     *
     * const mat = new engine.Material(effect1);
     * const mat2 = new engine.Material();
     * mat2.effect = effect1;
     *
     * @param {Effect} [effect]
     * @memberof Material
     */
    constructor(effect?: Effect);
    /**
     * 拷贝自身，生成一份新的材质数据
     *
     * @returns {Material}
     * @memberof Material
     */
    clone(): Material;
    /**
     * 设置一个Float
     *
     * @param {string} key
     * @param {number} value
     * @returns {boolean} 是否设置成功
     * @memberof Material
     */
    setFloat(key: string, value: number): boolean;
    /**
     * 设置一个Vector
     *
     * @param {string} key
     * @param {Vector2|Vector3|Vector4} value
     * @returns {boolean} 是否设置成功
     * @memberof Material
     */
    setVector(key: string, value: Vector2 | Vector3 | Vector4): boolean;
    /**
     * 获取一个Vector值的拷贝
     *
     * @param {string} key
     * @returns {(Nullable<Vector2 | Vector3 | Vector4>)}
     * @memberof Material
     */
    getVector(key: string): Nullable<Vector2 | Vector3 | Vector4>;
    /**
     * 设置一张贴图
     *
     * @param {string} key
     * @param {Texture} value
     * @returns {boolean} 是否设置成功
     * @memberof Material
     */
    setTexture(key: string, value: Texture): boolean;
    /**
     * 获取材质中已设置的贴图
     *
     * @param {string} key
     * @returns {Nullable<Texture>}获取的贴图，如材质中不存在key，则返回null
     * @memberof Material
     */
    getTexture(key: string): Nullable<Texture>;
    /**
     * 设置渲染状态
     * 只有标记了 useMaterialRenderStates 的Pass会受到影响
     *
     * @param {string} key
     * @param {(number|boolean)} value
     * @returns {boolean}
     * @memberof Material
     */
    setRenderState(key: string, value: number | boolean): boolean;
  }
}
declare module "engine/game/2D/UIMask" {
  import Material from "engine/assets/classes/material";
  import Transform2D from "engine/game/transform2D";
  import Entity from "engine/scene/entity";
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import Renderable2D from "engine/game/2D/renderable2D";
  export type Entity2D = Entity & {
    transform2D: Transform2D;
  };
  export default class UIMask extends Component {
    readonly priority: number;
    /**
     * 默认值为false，UIMask是否反向裁剪
     *
     * @type {boolean}
     * @memberof UIMask
     */
    get reverse(): boolean;
    set reverse(val: boolean);
    constructor(entity: Entity2D);
  }
}
declare module "engine/game/2D/UILayer" {
  import Renderable2D from "engine/game/2D/renderable2D";
  import Transform2D from "engine/game/transform2D";
  import Entity from "engine/scene/entity";
  export type Entity2D = Entity & {
    transform2D: Transform2D;
  };
  export default class UILayer extends Renderable2D {
    priority: number;
  }
}
declare module "engine/game/2D/UIMaskManager" {
  export default class UIMaskManager {}
}
declare module "engine/game/2D/renderWalker" {
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import Renderable2D from "engine/game/2D/renderable2D";
  export type Type2DRenderComp = Renderable2D | MeshRenderer;
  export default class RenderWalker {
    constructor();
  }
}
declare module "engine/game/2D/UIRenderManager" {
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import UICamera from "engine/game/2D/UICamera";
  import Renderable2D from "engine/game/2D/renderable2D";
  import UILayer from "engine/game/2D/UILayer";
  import { Entity2D } from "engine/scene/scene";
  export type Type2DRenderComp = Renderable2D | MeshRenderer | UILayer;
  export class RootNode {
    constructor(entity: Entity2D, isUITreeRoot?: boolean, initRenderLength?: number);
  }
  export default class UIRenderMananger {
    readonly uicamera: UICamera;
    constructor(uicamera: UICamera);
  }
}
declare module "engine/render/process/UICameraRenderProcess" {
  import Renderable2D from "engine/game/2D/renderable2D";
  import UICamera from "engine/game/2D/UICamera";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import RenderSystem from "engine/system/render";
  import Screen from "engine/render/screen";
  import BaseCameraRenderProcess from "engine/render/process/baseCameraRenderProcess";
  import Material from "engine/assets/classes/material";
  import { MeshRendererEventType, Renderable2DEventType, PipeLineEventType } from "engine/event";
  import { RootNode } from "engine/game/2D/UIRenderManager";
  export default class UICameraRenderProcess extends BaseCameraRenderProcess {
    constructor(camera: UICamera, scene: RenderSystem, screen: Screen);
    clearObjectRenderCache(object: Renderable2D | MeshRenderer): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
  }
}
declare module "engine/game/2D/UICamera" {
  import { TouchManager } from "engine/input/touch";
  import Matrix4 from "engine/math/matrix4";
  import Vector2 from "engine/math/vector2";
  import { Delegate } from "engine/misc/delegate";
  import { RawTouchEvents } from "engine/platform/touch";
  import UICameraRenderProcess from "engine/render/process/UICameraRenderProcess";
  import Screen from "engine/render/screen";
  import { Entity2D } from "engine/scene/scene";
  import RenderSystem from "engine/system/render";
  import { Nullable } from "engine/type";
  import BaseCamera from "engine/game/baseCamera";
  import Transform2D from "engine/game/transform2D";
  import { Type2DRenderComp } from "engine/game/2D/renderWalker";
  import UICanvas from "engine/game/2D/UICanvas";
  import { Listener, Emitter } from "engine/misc/emitter";
  import TouchInputComponent from "engine/game/2D/input/TouchInputComponent";
  import { BoundsChangeEventType, UILayerChangeType } from "engine/event";
  import { V2ReadOnly } from "engine/math/types";
  /**
   * 2D相机组件。
   * @export
   * @class UICamera
   * @extends {BaseCamera}
   */
  export default class UICamera extends BaseCamera {
    readonly entity: Entity2D;
    get uiCanvas(): Nullable<UICanvas>;
    get projectionMatrix2D(): Matrix4;
    get viewMatrix2D(): Matrix4;
    get viewMatrixInverse2D(): Matrix4;
    readonly touchManager: TouchManager;
    readonly touchEvent: Emitter<RawTouchEvents, TouchEvent>;
    constructor(entity: Entity2D);
    /**
     * 将事件坐标转换为UICanvas世界坐标
     *
     * @param {V2ReadOnly} eventPosition 事件坐标，Y轴向下
     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
     * @returns {Vector2} UICanvas坐标，Y轴向上
     * @memberof UICamera
     */
    convertEventPositionToUICanvas(eventPosition: V2ReadOnly, dst?: Vector2): Vector2;
    /**
     * 将事件坐标转换为齐次裁剪坐标
     *
     * @param {V2ReadOnly} eventPosition 事件坐标，Y轴向下
     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
     * @returns {Vector2} 齐次裁剪坐标
     * @memberof UICamera
     */
    convertEventPositionToClip(point: V2ReadOnly, dst?: Vector2): Vector2;
    /**
     * 将齐次裁剪坐标转换为UICanvas世界坐标
     *
     * @param {V2ReadOnly} eventPosition 齐次裁剪坐标
     * @param {Vector2} [dst] 若传入，则输出计算结果到该向量
     * @returns {Vector2} UICanvas坐标，Y轴向上
     * @memberof UICamera
     */
    convertClipPositionToCanvas(point: V2ReadOnly, dest?: Vector2): Vector2;
  }
}
declare module "engine/input/touch" {
  import TouchInputComponent, { TouchEventNames } from "engine/game/2D/input/TouchInputComponent";
  import Renderable2D from "engine/game/2D/renderable2D";
  import UICamera from "engine/game/2D/UICamera";
  import UIMask from "engine/game/2D/UIMask";
  import Vector2 from "engine/math/vector2";
  import { SmartArray } from "engine/misc/array";
  import { Delegate } from "engine/misc/delegate";
  import { RawTouchEvents } from "engine/platform/touch";
  import { Entity2D } from "engine/scene/scene";
  import { DeepImmutable, Nullable } from "engine/type";
  import { Listener } from "engine/misc/emitter";
  type Component = import("engine/game/component").default;
  interface ITouchStatus {
    startWorldPosition: [number, number];
    startClient: [number, number];
    maxMovement: [number, number];
    position: [number, number];
    isStarted: boolean;
    isOver: boolean;
  }
  interface ITouchInfo {
    index: number;
    component: Nullable<TouchInputComponent>;
    mask: Nullable<UIMask>;
    renderable: Nullable<Renderable2D>;
  }
  export type TouchPoint = Touch & {
    readonly position: DeepImmutable<Vector2>;
    readonly worldPosition: DeepImmutable<Vector2>;
    readonly startWorldPosition: DeepImmutable<Vector2>;
  };
  export type TouchInputEvent = Readonly<{
    readonly type: TouchEventNames;
    readonly touches: DeepImmutable<Array<TouchPoint>>;
    allowThrough: boolean;
    originalEvent: TouchEvent;
    stopTouchThrough(): void;
  }>;
  export const EventTypeNamesToCallbackNames: {
    [key in TouchEventNames]: string;
  };
  export class TouchManager {
    readonly uiCamera: UICamera;
    get onEventTrigger(): Delegate<Component, TouchInputEvent>;
    enableTouchForRenderableOnly: boolean;
    constructor(uiCamera: UICamera);
    markComponentDataNeedUpdate(): void;
    update(): void;
    traverse(): void;
    dispose(): void;
    forceTouchEndExcept(event: TouchEvent, touchInputComponent: Nullable<TouchInputComponent>): void;
  }
  export {};
}
declare module "engine/game/2D/input/TouchInputComponent" {
  import { TouchInputEvent } from "engine/input/touch";
  import { Delegate } from "engine/misc/delegate";
  import { Entity2D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import Rect from "engine/math/rect";
  /**
   * 触摸事件类型枚举值。
   * @export
   * @enum {number}
   */
  export enum TouchEventNames {
    TOUCH_START = "TOUCH_START",
    TOUCH_END = "TOUCH_END",
    TOUCH_MOVE = "TOUCH_MOVE",
    TOUCH_ENTER = "TOUCH_ENTER",
    TOUCH_LEAVE = "TOUCH_LEAVE",
    TOUCH_OVER = "TOUCH_OVER",
    TOUCH_CANCEL = "TOUCH_CANCEL",
    CLICK = "CLICK",
  }
  /**
   * 触摸响应类。
   * @export
   * @class Touchable
   * @extends {Component}
   */
  export class Touchable extends Component {
    /**
     * 物体对象。
     * @type {Entity2D}
     * @memberof Touchable
     */
    readonly entity: Entity2D;
    /**
     * 触摸开始事件。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchStart(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸结束事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchEnd(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸移动事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchMove(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸进入事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchEnter(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸离开事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchLeave(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸掠过事件，没有触发过触摸开始事件才能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchOver(): Delegate<this, TouchInputEvent>;
    /**
     * 触摸取消事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onTouchCancel(): Delegate<this, TouchInputEvent>;
    /**
     * 点击事件，只有触发过触摸开始事件才可能触发。
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof Touchable
     */
    get onClick(): Delegate<this, TouchInputEvent>;
  }
  /**
   * 2D点击组件，负责点击判定和事件分发。
   * @export
   * @class TouchInputComponent
   * @extends {Touchable}
   */
  export default class TouchInputComponent extends Touchable {
    /**
     * 触摸事件类型枚举值。
     * @static
     * @type {typeof TouchEventNames}
     * @memberof TouchInputComponent
     */
    static TOUCH_EVENTS: typeof TouchEventNames;
    /**
     * 是否允许事件穿透。
     * @type {boolean}
     * @memberof TouchInputComponent
     */
    touchThrough: boolean;
    /**
     * 点击判定区域。
     * @type {Nullable<Rect>}
     * @memberof TouchInputComponent
     */
    hitArea: Nullable<Rect>;
    /**
     * 点击判定的移动阈值，超出阈值则不视为点击事件。
     * @type {number}
     * @memberof TouchInputComponent
     */
    clickMovementThreshold: number;
  }
}
declare module "engine/game/2D/UICanvas" {
  import Vector2 from "engine/math/vector2";
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import { Entity2D, Entity3D } from "engine/scene/scene";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import Transform2D from "engine/game/transform2D";
  import { DeepImmutable } from "engine/type";
  import { Nullable } from "engine/type";
  import TouchInputComponent from "engine/game/2D/input/TouchInputComponent";
  import { Emitter } from "engine/misc/emitter";
  import { UIAdaptationType } from "engine/assets/resource";
  import { UILayerChangeType } from "engine/event";
  export default class UICanvas extends MeshRenderer {
    readonly entity: Entity3D & Entity2D;
    static readonly AdaptationType: Readonly<typeof UIAdaptationType>;
    /**
     * 正交模式，屏幕适配的模式
     */
    get adaptationType(): UIAdaptationType;
    set adaptationType(val: UIAdaptationType);
    get designResolution(): Vector2;
    set designResolution(designSize: Vector2);
    get deviceResolution(): Vector2;
    set deviceResolution(resolution: Vector2);
    /**
     * @duplicate
     */
    get resolution(): DeepImmutable<Vector2>;
    /**
     * @deprecated
     */
    get UITreeRoot(): Transform2D;
    readonly treeDirtyEvent: Emitter<void, void>;
    readonly treeChangeEvent: Emitter<UILayerChangeType, Entity2D>;
    readonly interactiveDirtyEvent: Emitter<void>;
    readonly forceTouchEndExceptEvent: Emitter<TouchEvent, Nullable<TouchInputComponent>>;
    /**
     * @deprecated
     */
    get touchManager(): import("engine/input/touch").TouchManager;
    constructor(entity: Entity3D & Entity2D);
    convertEventPositionToUICanvasPosition(pos: Vector2, dist?: Vector2): Vector2;
    markTreeDirty(): void;
    markLayerRootDirtyByTransform2D(transform2D: Transform2D): void;
    addUILayerRoot(rootEntity: Entity2D): void;
    removeUILayerRoot(rootEntity: Entity2D): void;
    markUILayerRootDirty(rootEntity: Entity2D): void;
    markInteractiveDirty(): void;
  }
}
declare module "engine/game/2D/renderable2D" {
  import Material from "engine/assets/classes/material";
  import Color, { BlendType } from "engine/math/color";
  import { Entity2D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import UICanvas from "engine/game/2D/UICanvas";
  import { BoundsChangeEventType } from "engine/event";
  export interface RenderData {
    material?: Material;
    vDataViewU32?: Uint32Array;
    vDataViewF32?: Float32Array;
    vData?: wxGA.BatchableVertexBuffer;
    iData?: wxGA.BatchableIndexBuffer;
    vertexNum?: number;
    indiceNum?: number;
  }
  /**
   * 所有需要绘制的2D组件都需要继承自此类，负责管理材质，加速模块的对象以及颜色等信息。
   */
  export default class Renderable2D extends Component {
    /**
     * 继承混合颜色的方式
     * @static
     * @memberof Renderable2D
     */
    static BlendType: Readonly<typeof BlendType>;
    readonly entity: Entity2D;
    readonly priority: number;
    /**
     * 渲染组件本身是否active
     *
     * @type {boolean}
     * @overload
     * @memberof Component
     */
    get active(): boolean;
    set active(value: boolean);
    /**
     * 渲染组件本身的颜色，用于与渲染元素进行颜色混合
     *
     * @type {Color}
     * @memberof Renderable2D
     */
    set color(val: Color);
    get color(): Color;
    /**
     * 渲染组件继承父渲染组件颜色，颜色混合的方式
     *
     * @type {BlendType}
     * @overload
     * @memberof Renderable2D
     */
    set colorBlendType(val: BlendType);
    get colorBlendType(): BlendType;
    get isMask(): boolean;
    get cullingMask(): number;
    set cullingMask(val: number);
  }
}
declare module "engine/graphicResource/shader" {
  import { Nullable } from "engine/type";
  export default class Shader {
    constructor(vert: string, frag: string, uniform_blocks: wgfx.ShaderUniformBlockDesc[], images: wgfx.ShaderImageDesc[], cachePath?: string);
    destroy(): void;
    /**
     * 获取Shader需要的UniformBlock数
     *
     * @returns {number}
     * @memberof Shader
     */
    getUniformBlockCount(): number;
    /**
     *获取Shader需要的贴图数
     *
     * @returns {wgfx.ShaderImageDesc[]}
     * @memberof Shader
     */
    getImageDescs(): wgfx.ShaderImageDesc[];
  }
}
declare module "engine/render/baseRenderDraw" {
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import ShaderDefination from "engine/materials/shaderDefination";
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import { Emitter } from "engine/misc/emitter";
  import { ShadowMode } from "engine/game/3D/camera";
  type Material = import("engine/assets/classes/material").default;
  type Mesh = import("engine/assets/classes/mesh").default;
  type Renderable2D = import("engine/game/2D/renderable2D").default;
  type Pass = import("engine/materials/pass").default;
  export function setRenderTypeMap(ctor: any, typeEnum: any): void;
  export default class RenderDrawHelper {
    static renderDefinationDirtyEvent: Emitter<MeshRenderer>;
    static getShaderDefinationByMesh(mesh: Mesh): ShaderDefination;
    static deleteShaderDefinationByMeshRenderer(meshRenderer: MeshRenderer): void;
    static getShaderDefinationByMeshRenderer(meshRenderer: MeshRenderer, shadowMode?: ShadowMode): ShaderDefination;
    static createRenderDraw(): wxGA.RenderDraw | undefined;
    static destroyRenderDraw(renderDraw: wxGA.RenderDraw): void;
    /**
     * 获取某个renderDraw的subMeshIndex
     *
     * @param {wxGA.RenderDraw} rd
     * @returns {number}
     * @memberof RenderDrawHelper
     */
    static getRenderDrawSubMeshIndex(rd: wxGA.RenderDraw): number;
    /**
     * 获取某个renderDraw的renderQueue
     *
     * @param {wxGA.RenderDraw} rd
     * @returns {number}
     * @memberof RenderDrawHelper
     */
    static getRenderDrawQueue(rd: wxGA.RenderDraw): number;
    /**
     * 获取某个renderDraw的materialHash，用于排序
     *
     * @param {wxGA.RenderDraw} rd
     * @returns {number}
     * @memberof RenderDrawHelper
     */
    static getRenderDrawMaterialHash(rd: wxGA.RenderDraw): number;
    /**
     * 填充RenderDraw数据结构，返回是否成功
     *
     * @param {wxGA.RenderDraw} rd
     * @param {wxGA.RenderView} renderView
     * @param {MeshRenderer} meshRenderer
     * @param {number} subMeshIndex
     * @param {Material} material
     * @param {Pass} pass
     * @param {ShaderDefination} globalShaderDefination
     * @param {UniformBlockValue} globalUniformValue
     * @param {wgfx.Image[]} globalImages
     * @param {wgfx.ShaderImageDesc[]} globalImageDesc
     * @param {wgfx.EnumPixelFormat} [depthPixelFormat]
     * @returns {boolean}
     * @memberof RenderDrawHelper
     */
    static encodeRenderDraw(
      rd: wxGA.RenderDraw,
      renderView: wxGA.RenderView,
      meshRenderer: MeshRenderer,
      subMeshIndex: number,
      material: Material,
      pass: Pass,
      globalShaderDefination: ShaderDefination,
      globalUniformValue: UniformBlockValue,
      globalImages: {
        [name: string]: wgfx.Image;
      },
      depthPixelFormat: wgfx.EnumPixelFormat,
      shadowMode: ShadowMode,
    ): boolean;
    static encodeUIRenderDraw(
      rd: wxGA.RenderDraw,
      renderView: wxGA.RenderView,
      render2D: Renderable2D,
      material: Material,
      vData: wxGA.BatchableVertexBuffer,
      iData: wxGA.BatchableIndexBuffer,
      indiceNum: number,
      globalShaderDefination: ShaderDefination,
      globalUniformValue: UniformBlockValue,
      globalImages: {
        [name: string]: wgfx.Image;
      },
      vertexLayoutIndex: number,
      depthPixelFormat?: wgfx.EnumPixelFormat,
    ): boolean;
    static encodePostProcessRenderDraw(
      rd: wxGA.RenderDraw,
      renderView: wxGA.RenderView,
      sourceTex: wgfx.Image,
      depthTex: wgfx.Image,
      pass: Pass,
      globalUniformBlockValue?: UniformBlockValue,
      customUniformBlockValue?: UniformBlockValue,
    ): boolean | undefined;
    static buildSubMeshRenderDraws(
      object: MeshRenderer,
      renderView: wxGA.RenderView,
      lightMode: string,
      globalShaderDefination: ShaderDefination,
      globalUniformValue: UniformBlockValue,
      globalImages: {
        [name: string]: wgfx.Image;
      },
      depthPixelFormat?: wgfx.EnumPixelFormat,
      shadowMode?: ShadowMode,
    ): wxGA.RenderDraw[];
    static rebuildRenderDrawSubmeshInfo(renderDraw: wxGA.RenderDraw, meshRenderer: MeshRenderer): void;
    static rebuildUIRenderDrawsVertex(renderDraws: Array<wxGA.RenderDraw>, renderable2D: Renderable2D): boolean;
    static rebuildUIRenderDrawsMaterial(
      renderDraws: Array<wxGA.RenderDraw>,
      renderable2D: Renderable2D,
      globalShaderDefination: ShaderDefination,
      globalUniformValue: UniformBlockValue,
      globalImages: {
        [name: string]: wgfx.Image;
      },
    ): boolean;
  }
  export {};
}
declare module "engine/render/process/forwardBasePassProcess" {
  import RenderTexture from "engine/assets/classes/renderTexture";
  import Camera, { ShadowMode } from "engine/game/3D/camera";
  import DirectionalLight from "engine/game/3D/directionalLight";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import ShaderDefination from "engine/materials/shaderDefination";
  import Matrix4 from "engine/math/matrix4";
  import RenderSystem from "engine/system/render";
  import { Nullable } from "engine/type";
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import { ITypeCullResult } from "engine/render/process/cameraRenderProcess";
  import RenderProcess from "engine/render/process/renderProcess";
  export default class ForwardBasePassProcess extends RenderProcess {
    constructor(scene: RenderSystem, camera: Camera, renderView: wxGA.RenderView, defaultObjectCount: number);
    /**
     * 每帧更新
     *
     * @param {MeshRenderer[]} objects 要参与渲染的物体
     * @memberof ForwardBasePassProcess
     */
    update(cullResult: ITypeCullResult): void;
    setMainDirLight(light: Nullable<DirectionalLight>): void;
    setRenderView(renderView: wxGA.RenderView): void;
    clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    setShadowParams(
      mode: ShadowMode,
      shadowMap: Nullable<RenderTexture>,
      csmFarBounds: Nullable<Float32Array>,
      shadowTilingOffsets: Nullable<Float32Array>,
      csmLightSpaceMatrices: Nullable<Float32Array>,
    ): void;
  }
}
declare module "engine/math/OBB" {
  import Vector3 from "engine/math/vector3";
  export default class OBB {
    constructor();
    setValues(cenX: number, cenY: number, cenZ: number, forward: Vector3, w: number, h: number, d: number): void;
    get center(): Vector3;
    set center(pos: Vector3);
    get width(): number;
    set width(w: number);
    get height(): number;
    set height(h: number);
    get depth(): number;
    set depth(d: number);
    setForward(forward: Vector3): void;
    get AxisX(): Vector3;
    get AxisY(): Vector3;
    get AxisZ(): Vector3;
  }
}
declare module "engine/math/intersection" {
  import BoundBall from "engine/math/boundBall";
  import OBB from "engine/math/OBB";
  export function spheresIntersect(ballA: BoundBall, ballB: BoundBall): boolean;
  export function OBBIntersectSphere(obb: OBB, ball: BoundBall): boolean;
}
declare module "engine/render/process/shadowMapPassProcess" {
  import RenderTexture from "engine/assets/classes/renderTexture";
  import Camera, { ShadowMode } from "engine/game/3D/camera";
  import DirectionalLight from "engine/game/3D/directionalLight";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import Matrix4 from "engine/math/matrix4";
  import Vector3 from "engine/math/vector3";
  import { Nullable } from "engine/type";
  import RenderProcess from "engine/render/process/renderProcess";
  import { SmartArray } from "engine/misc/array";
  import OBB from "engine/math/OBB";
  export const CSM_MAX_SPLITS = 4;
  class ShadowSetting {
    static csm_split_weight: number;
    constructor(shadowMode: ShadowMode);
    setShadowMode(shadowMode: ShadowMode): void;
    setCascadedSplits(val: Vector3): void;
    adjustSplitPercents(index: number, percent: number): void;
    get tilingOffsets(): Float32Array;
    get csmSplitsNum(): number;
    get csmSplitPercents(): number[];
  }
  export class LightCamera {
    constructor(camera: Camera, shadowMode: ShadowMode);
    get fars(): Float32Array;
    get lightSpaceMatricesRaw(): Float32Array;
    get shadowSetting(): ShadowSetting;
    update(camera: Camera, lightDir: Vector3): void;
    setShadowMode(mode: ShadowMode): void;
    setCascadedSplits(cas: Vector3): void;
    setShadowDistance(dist: number): void;
    getLightSpaceMatrix(f_id: number): Matrix4;
  }
  export class ShadowMapPassProcess extends RenderProcess {
    constructor(objectCount: number, renderCamera: Camera, shadowMode: ShadowMode);
    getShadowMap(): Nullable<RenderTexture>;
    get lightCamera(): LightCamera;
    csmFarBounds(): Float32Array;
    get tilingOffsets(): Float32Array;
    getLightSpaceMatrices(): Float32Array;
    setMainDirLight(light: Nullable<DirectionalLight>): void;
    setShadowMode(mode: ShadowMode): void;
    setCascadedSplits(cas: Vector3): void;
    setShadowDistance(dist: number): void;
    clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
    preCastShadow(): void;
    update(shadowObjects: SmartArray<MeshRenderer>): void;
  }
  export {};
}
declare module "engine/render/process/skyboxProcess" {
  import RenderProcess from "engine/render/process/renderProcess";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  export default class SkyboxProcess extends RenderProcess {
    constructor();
    clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
  }
}
declare module "engine/misc/string" {
  export function upperFirst(s: string): string;
}
declare module "engine/render/postProcess/basePostProcess" {
  import { LoggerInstance } from "engine/debug/logger";
  import RenderTexture from "engine/assets/classes/renderTexture";
  import * as pp from "engine/render/postProcess/type";
  import UniformBlockValue from "engine/render/uniformBlockValue";
  import Effect from "engine/assets/classes/effect";
  /**
   * @abstract
   * 代表了一次后处理的步骤（比如说一次FXAA）；
   * 设置好输入材质，以及输出（renderView）之后，
   * 外部提供commandBuffer，调用run()就可以运行了。
   *
   * 需要手动实现生成renderDraw的方法。
   * 需要手动提供实例所需要的effect的名称。
   * 需要手动提供logger。
   */
  export default abstract class BasePostProcess {
    constructor(config?: pp.PostProcessStepData);
    /**
     * 重新设置输入输出，以及输入材质的大小；
     * 新建的实例经过一次设置才能使用。
     * @param renderView
     * @param sourceTex
     * @param width
     * @param height
     */
    reset(renderView: wxGA.RenderView, sourceTex: wgfx.Image, depthTex: wgfx.Image, width: number, height: number, hdr: boolean): void;
    /**
     * @virtual
     * @param config
     */
    setData(config: pp.PostProcessStepData): void;
    /**
     * 暴露给外部的运行命令；
     * 会更新所有的renderDraw，并写入commandBuffer；
     * 需要reset过一次才能使用。
     * @param commandBuffer
     */
    run(commandBuffer: wxGA.CommandBuffer, globalUniformBlock?: UniformBlockValue): void;
    destroy(): void;
  }
  export function setFloatUniformOnChange(configName: string, uniformName: string): (constructor: Function) => void;
}
declare module "engine/render/postProcess/bloom" {
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import { LoggerInstance } from "engine/debug/logger";
  import * as pp from "engine/render/postProcess/type";
  export default class Bloom extends BasePostProcess {
    reset(renderView: wxGA.RenderView, sourceTex: wgfx.Image, depthTex: wgfx.Image, width: number, height: number, hdr: boolean): void;
    /**
     * @override
     */
    destroy(): void;
  }
}
declare module "engine/render/postProcess/fxaa" {
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import { LoggerInstance } from "engine/debug/logger";
  import * as pp from "engine/render/postProcess/type";
  export default class FXAA extends BasePostProcess {}
}
declare module "engine/render/postProcess/hdr" {
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import { LoggerInstance } from "engine/debug/logger";
  import * as pp from "engine/render/postProcess/type";
  export default class HDR extends BasePostProcess {}
}
declare module "engine/render/postProcess/dof" {
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import { LoggerInstance } from "engine/debug/logger";
  import * as pp from "engine/render/postProcess/type";
  export default class DepthOfField extends BasePostProcess {}
}
declare module "engine/render/postProcess/type" {
  type Bloom = typeof import("engine/render/postProcess/bloom").default;
  type FXAA = typeof import("engine/render/postProcess/fxaa").default;
  type HDR = typeof import("engine/render/postProcess/hdr").default;
  type DepthOfField = typeof import("engine/render/postProcess/dof").default;
  export enum Effects {
    FXAA = "System::Effect::FXAA",
    BLIT = "System::Effect::Blit",
    BLOOM = "System::Effect::Bloom",
    HDR = "System::Effect::HDR",
    DOF = "System::Effect::DepthOfField",
  }
  export interface FXAAConfig {}
  export interface BloomConfig {
    threshold?: number;
    softThreshold?: number;
    iterations?: number;
    intensity?: number;
  }
  export interface HDRConfig {
    exposure?: number;
  }
  const HDRPixelFormat: wgfx.EnumPixelFormat;
  export { HDRPixelFormat };
  export type PostProcessStepData = BloomConfig | FXAAConfig | HDRConfig;
  export type DerivedPostProcess = Bloom | FXAA | HDR | DepthOfField;
}
declare module "engine/game/postProcess" {
  /**
   * @Date 2019.12.30
   * @File 后处理组件，作用在相机物体上
   */
  import { PostProcessStepData } from "engine/render/postProcess/type";
  import { Entity3D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import { Emitter } from "engine/misc/emitter";
  export interface IPostProcessStep {
    type: string;
    data: PostProcessStepData;
  }
  export type PostProcessConfig = Array<IPostProcessStep>;
  /**
   * @TODO 检查config里的type名称和data格式
   */
  export default class PostProcessComponent extends Component {
    readonly entity: Entity3D;
    /**
     * 临时方案，为了在IDE里画出组件面板
     */
    get fxaa(): boolean;
    set fxaa(on: boolean);
    get bloom(): boolean;
    set bloom(on: boolean);
    get tonemapping(): boolean;
    set tonemapping(on: boolean);
    get effects(): Array<IPostProcessStep>;
    set effects(e: Array<IPostProcessStep>);
    constructor(entity: Entity3D);
    getConfig(): PostProcessConfig | undefined;
    setDirty(): void;
  }
}
declare module "engine/render/postProcess/blit" {
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import { LoggerInstance } from "engine/debug/logger";
  import * as pp from "engine/render/postProcess/type";
  export default class Blit extends BasePostProcess {}
}
declare module "engine/render/postProcess/pipe" {
  type BasePostProcess = import("engine/render/postProcess/basePostProcess").default;
  import UniformBlockValue from "engine/render/uniformBlockValue";
  /**
   * 在数组内填充BasePostProcess，之后使用run()就可以依次执行了；
   * 注意不要填充两个相同的BasePostProcess实例，需要进行两次相同的步骤时需要new两个不同的实例出来。
   */
  export default class PostProcessPipe extends Array<BasePostProcess> {
    get hdr(): boolean;
    set hdr(v: boolean);
    constructor(...args: any[]);
    run(commandBuffer: wxGA.CommandBuffer, renderView: wxGA.RenderView, sourceTex: wgfx.Image, depthTex: wgfx.Image, width: number, height: number, additionalUniformBlock?: UniformBlockValue): void;
    destroy(): void;
  }
  export {};
}
declare module "engine/render/postProcess" {
  import FXAA from "engine/render/postProcess/fxaa";
  import Bloom from "engine/render/postProcess/bloom";
  import HDR from "engine/render/postProcess/hdr";
  import DepthOfField from "engine/render/postProcess/dof";
  import BasePostProcess from "engine/render/postProcess/basePostProcess";
  import PostProcessPipe from "engine/render/postProcess/pipe";
  export { FXAA, Bloom, BasePostProcess, PostProcessPipe, HDR, DepthOfField };
}
declare module "engine/render/process/postProcess" {
  import RenderProcess from "engine/render/process/renderProcess";
  import { PostProcessConfig } from "engine/game/postProcess";
  import { RenderTexture } from "engine/engine";
  import Camera from "engine/game/3D/camera";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  export default class PostProcessRenderProcess extends RenderProcess {
    constructor(camera: Camera, renderView: wxGA.RenderView, config: PostProcessConfig);
    setConfig(config: PostProcessConfig): void;
    setRenderView(renderView: wxGA.RenderView): void;
    update(source: RenderTexture): void;
    clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
  }
}
declare module "engine/render/process/cameraRenderProcess" {
  import Camera, { ShadowMode } from "engine/game/3D/camera";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import RenderSystem from "engine/system/render";
  import Screen from "engine/render/screen";
  import BaseCameraRenderProcess from "engine/render/process/baseCameraRenderProcess";
  import { SmartArray } from "engine/misc/array";
  import { PostProcessConfig } from "engine/game/postProcess";
  import { MeshRendererEventType, PipeLineEventType } from "engine/event";
  import Vector3 from "engine/math/vector3";
  export interface ITypeCullResult {
    objects: SmartArray<MeshRenderer>;
    distances: Float32Array;
    shadowObjects: SmartArray<MeshRenderer>;
    hash: number;
  }
  export default class CameraRenderProcess extends BaseCameraRenderProcess {
    constructor(camera: Camera, scene: RenderSystem, screen: Screen, shadowMode: ShadowMode, postProcessConfig?: PostProcessConfig);
    setShadowMode(mode: ShadowMode): void;
    setCascadedSplits(val: Vector3): void;
    setShadowDistance(dist: number): void;
    clearObjectRenderCache(meshRenderer: MeshRenderer): void;
    resetObjectSubMeshInfo(meshRenderer: MeshRenderer): void;
    clearAllObjectsRenderCache(): void;
  }
}
declare module "engine/game/3D/camera" {
  import Vector3 from "engine/math/vector3";
  import CameraRenderProcess from "engine/render/process/cameraRenderProcess";
  import Screen from "engine/render/screen";
  import { Entity3D } from "engine/scene/scene";
  import RenderSystem from "engine/system/render";
  import { Nullable } from "engine/type";
  import BaseCamera from "engine/game/baseCamera";
  import PostProcessComponent from "engine/game/postProcess";
  import Transform3D from "engine/game/transform3D";
  import { Listener } from "engine/misc/emitter";
  export enum ShadowMode {
    /**
     * 关闭阴影
     */
    None = 0,
    /**
     * 开启单级联阴影，并开启PCF
     */
    OneCascade_PCF = 1,
    TwoCascade_PCF = 2,
    FourCascade_PCF = 3,
  }
  export enum ShadowFitMode {
    /**
     * 阴影范围适配视锥体
     * 更稳定，可能降低阴影精度
     */
    FitFrustum = 0,
    /**
     * 阴影范围适配物体
     * 能提高阴影精度，但可能会导致阴影不稳定
     */
    FitObjects = 1,
  }
  export default class Camera extends BaseCamera {
    readonly entity: Entity3D;
    /**
     * 阴影模式
     *
     * @static
     * @memberof Camera
     */
    static readonly ShadowMode: Readonly<typeof ShadowMode>;
    /**
     * 阴影适配模式
     *
     * @static
     * @memberof Camera
     */
    static readonly ShadowFitMode: Readonly<typeof ShadowFitMode>;
    /**
     * 阴影渲染模式
     *
     * @type {ShadowMode}
     * @memberof Camera
     */
    get shadowMode(): ShadowMode;
    set shadowMode(val: ShadowMode);
    /**
     * Cascaded splits
     *
     * @type {Vector3}
     * @memberof Camera
     */
    get cascadedSplits(): Vector3;
    set cascadedSplits(val: Vector3);
    /**
     * 阴影适配模式
     *
     * @type {ShadowFitMode}
     * @memberof Camera
     */
    get shadowFitMode(): ShadowFitMode;
    set shadowFitMode(val: ShadowFitMode);
    /**
     * 阴影距离
     *
     * @readonly
     * @type {number}
     * @memberof Camera
     */
    get shadowDistance(): number;
    set shadowDistance(val: number);
    /**
     * 是否开启HDR
     *
     * @type {boolean}
     * @memberof Camera
     */
    get hdr(): boolean;
    set hdr(val: boolean);
    /**
     * 相机的跟拍目标
     * 该属性有值时，相机为跟拍模式，相机的rotation会被自动更新
     * 该属性设置为null时，相机为自由旋转模式
     *
     * @readonly
     * @type {Nullable<Transform3D>}
     * @memberof Camera
     */
    get targetTransform(): Nullable<Transform3D>;
    set targetTransform(val: Nullable<Transform3D>);
    /**
     * 请使用entity.addComponent(engine.Camera)来创建
     * @param {Entity3D} entity
     * @memberof Camera
     */
    constructor(entity: Entity3D);
  }
}
declare module "engine/game/3D/meshRenderer" {
  import Camera from "engine/game/3D/camera";
  import BoundBall from "engine/math/boundBall";
  import Vector4 from "engine/math/vector4";
  import { Entity2D, Entity3D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import Mesh from "engine/assets/classes/mesh";
  import Texture2D from "engine/assets/classes/texture2D";
  import Material from "engine/assets/classes/material";
  import Transform3D from "engine/game/transform3D";
  export default class MeshRenderer extends Component {
    readonly entity: Entity3D | Entity2D;
    /**
     * 设置该MeshRenderer渲染的Mesh
     *
     * @readonly
     * @type {Nullable<Mesh>}
     * @memberof MeshRenderer
     */
    get mesh(): Nullable<Mesh>;
    set mesh(val: Nullable<Mesh>);
    /**
     * 世界坐标系下的包围球
     * 只读
     *
     * @readonly
     * @type {BoundBall}
     * @memberof MeshRenderer
     */
    get worldBoundBall(): BoundBall;
    /**
     * 光照贴图
     * 建议使用lightMapIndex来设置
     *
     * @type {Nullable<Texture2D>}
     * @memberof MeshRenderer
     */
    get lightMap(): Nullable<Texture2D>;
    set lightMap(val: Nullable<Texture2D>);
    /**
     * 光照贴图的scaleOffset
     * 暂时不支持 meshRenderer.lightMapScaleOffset.x = 1这种写法
     *
     * @type {Vector4}
     * @memberof MeshRenderer
     */
    get lightMapScaleOffset(): Vector4;
    set lightMapScaleOffset(l: Vector4);
    /**
     * 是否投射阴影
     *
     * @type {boolean}
     * @memberof MeshRenderer
     */
    get castShadow(): boolean;
    set castShadow(s: boolean);
    /**
     * 是否接收阴影
     *
     * @type {boolean}
     * @memberof MeshRenderer
     */
    get receiveShadow(): boolean;
    set receiveShadow(s: boolean);
    /**
     * 剔除掩码，有效值：0~0x00ffffff
     * 剔除时将使用该值与Camera的cullingMask做按位与，有值时才渲染
     *
     * @type {number}
     * @memberof MeshRenderer
     */
    get cullingMask(): number;
    set cullingMask(val: number);
    /**
     * 光照贴图index
     *
     * @type {number}
     * @memberof MeshRenderer
     */
    get lightMapIndex(): number;
    set lightMapIndex(s: number);
    /**
     * 当前材质数量
     *
     * @readonly
     * @type {number}
     * @memberof MeshRenderer
     */
    get materialCount(): number;
    /**
     * 主材质
     *
     * @type {Nullable<Material>}
     * @memberof MeshRenderer
     */
    get material(): Nullable<Material>;
    set material(material: Nullable<Material>);
    /**
     * 请使用entity.addComponent(engine.MeshRenderer)来创建
     * @param {(Entity3D | Entity2D)} entity
     * @memberof MeshRenderer
     */
    constructor(entity: Entity3D | Entity2D);
    /**
     * 获取第index位材质，当第一次获取成功时，该材质会被拷贝，并将替换材质
     *
     * @param {number} index
     * @returns {Nullable<Material>} 材质
     * @memberof MeshRenderer
     */
    getMaterialAtIndex(index: number): Nullable<Material>;
    /**
     * 获取第index位材质的sharedMaterial，此操作不会进行材质拷贝
     *
     * @param {number} index
     * @returns {Nullable<Material>} 材质
     * @memberof MeshRenderer
     */
    getSharedMaterialAtIndex(index: number): Nullable<Material>;
    /**
     * 增加材质
     *
     * @param {Material} material
     * @memberof MeshRenderer
     */
    addMaterial(material: Material): void;
    /**
     * 设置第n个位置的材质
     *
     * @param {Nullable<Material>} material 材质
     * @param {number} index 位置
     * @memberof MeshRenderer
     */
    setMaterialAtIndex(material: Nullable<Material>, index: number): void;
    /**
     * 清除所有Materials
     * 组件销毁时会自动调用
     *
     * @param {boolean} [needRenderDirty=true] 是否抛渲染脏事件，开发者调用时使用默认值即可
     * @memberof MeshRenderer
     */
    clearAllMaterials(needRenderDirty?: boolean): void;
  }
}
declare module "engine/render/renderer" {
  import BaseCamera from "engine/game/baseCamera";
  import Game from "engine/game/game";
  import { RawTouchEvents } from "engine/platform/touch";
  import RenderSystem from "engine/system/render";
  import Screen from "engine/render/screen";
  import { Listener } from "engine/misc/emitter";
  export default class Renderer {
    readonly game: Game;
    readonly screen: Screen;
    constructor(game: Game, screen: Screen);
    dispose(): void;
    addCamera(child: BaseCamera): void;
    removeCamera(child: BaseCamera): void;
    resortCamera(): void;
    drawScene(scene: RenderSystem): void;
  }
}
declare module "engine/system/render" {
  import DirectionalLight from "engine/game/3D/directionalLight";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import { IGameSystem } from "engine/game/game";
  import Renderer from "engine/render/renderer";
  import Screen from "engine/render/screen";
  import { Nullable } from "engine/type";
  import { MeshRendererEventType, DirectionalLightEventType } from "engine/event";
  type Game = import("engine/game/game").default;
  /**
   * @public
   */
  export default class RenderSystem implements IGameSystem {
    readonly game: Game;
    readonly screen: Screen;
    readonly renderer: Renderer;
    readonly displayObjects: Map<number, MeshRenderer>;
    constructor(game: Game);
    /**
     * 获取场景中的主平行光源，用于渲染阴影
     *
     * @returns {DirectionalLight}
     * @memberof RenderScene
     */
    get mainDirectionalLight(): Nullable<DirectionalLight>;
    /**
     * 通过native加速对象的id来查找meshRenderer
     *
     * @private
     * @param {number} id
     * @returns {MeshRenderer}
     * @memberof RenderScene
     */
    getMeshRendererByNativeId(id: number): Nullable<MeshRenderer>;
    /**
     * 在渲染队列中添加MeshRenderer
     *
     * @private
     * @param {MeshRenderer} child
     * @memberof RenderScene
     */
    addMeshRenderer(child: MeshRenderer): void;
    /**
     * 从渲染队列移除指定meshRenderer
     *
     * @private
     * @param {MeshRenderer} child
     * @memberof RenderScene
     */
    removeMeshRenderer(child: MeshRenderer): void;
    /**
     * 添加平行光
     *
     * @private
     * @param {DirectionalLight} child
     * @memberof RenderScene
     */
    addDirectionalLight(child: DirectionalLight): void;
    /**
     * 移除指定平行光
     *
     * @private
     * @param {DirectionalLight} child
     * @memberof RenderScene
     */
    removeDirectionalLight(child: DirectionalLight): void;
    /**
     * 增加屏幕空间物体
     *
     * @private
     * @param {MeshRenderer} child
     * @memberof RenderScene
     */
    addScreenSpaceObject(child: MeshRenderer): void;
    /**
     * 移除屏幕空间物体
     *
     * @private
     * @param {MeshRenderer} child
     * @memberof RenderScene
     */
    removeScreenSpaceObject(child: MeshRenderer): void;
    update(dt: number): void;
    dispose(): void;
  }
  export {};
}
declare module "engine/assets/classes/bitmapFont" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import BaseResource from "engine/assets/classes/baseResource";
  import { Glyph } from "engine/game/2D/label/glyph";
  import { BitmapFontResourceDescription } from "engine/assets/resource";
  /**
   * 位图字体资源。
   * @export
   * @class BitmapFont
   * @extends {BaseResource}
   */
  export default class BitmapFont extends BaseResource {
    /**
     * 字符在字符集中的信息。
     * @type {{ [character: string]: Glyph }}
     * @memberof BitmapFont
     */
    spriteSheet: {
      [character: string]: Glyph;
    };
    /**
     * 字体大小。
     * @type {(number | null)}
     * @memberof BitmapFont
     */
    fontSize: number | null;
    /**
     * 是否为启用状态。
     * @type {boolean}
     * @memberof BitmapFont
     */
    enabled: boolean;
    /**
     * 位图字体资源的反序列化方法。
     * @static
     * @param {BitmapFontResourceDescription} resourceDescription
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {BitmapFont}
     * @memberof BitmapFont
     */
    static DeserializeResource(resourceDescription: BitmapFontResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): BitmapFont;
  }
}
declare module "engine/assets/classes/font" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import BaseResource from "engine/assets/classes/baseResource";
  import { FontResourceDescription } from "engine/assets/resource";
  /**
   * 字体资源。
   * @export
   * @class Font
   * @extends {BaseResource}
   */
  export default class Font extends BaseResource {
    /**
     * 所有已知的字体集合。
     * @static
     * @memberof Font
     */
    static FontFamilies: Set<string>;
    /**
     * 字体名称。
     * @type {string}
     * @memberof Font
     */
    fontFamily: string;
    /**
     * 字体资源的反序列化方法。
     * @static
     * @param {FontResourceDescription} resourceDescription
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {Font}
     * @memberof Font
     */
    static DeserializeResource(resourceDescription: FontResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): Font;
  }
}
declare module "engine/game/2D/label/enum" {
  export enum TextAlign {
    Default = 0,
    Left = 1,
    Center = 2,
    Right = 3,
  }
  export enum TextVAlign {
    Default = 0,
    Top = 1,
    Middle = 2,
    Bottom = 3,
  }
  export enum TextRenderMode {
    NoCache = 0,
    Cache = 1,
  }
  export enum overflowType {
    Auto = 0,
    Hidden = 1,
  }
}
declare module "engine/game/2D/label/split" {
  const _default: (text: string) => RegExpMatchArray | null;
  export default _default;
}
declare module "engine/game/2D/label/typesetting" {
  import Vector2 from "engine/math/vector2";
  import { Glyph } from "engine/game/2D/label/glyph";
  import Texture2D from "engine/assets/classes/texture2D";
  import UILabel from "engine/game/2D/label/UILabel";
  export interface CharacterData {
    character: string;
    x: number;
    y: number;
    width: number;
    height: number;
    batchIndex: number;
    glyph: Glyph;
  }
  interface LineData {
    x: number;
    y: number;
    width: number;
    height: number;
    characters: CharacterData[];
  }
  export interface TypesettingData {
    batches: {
      characterCount: number;
      texture: Texture2D;
    }[];
    x: number;
    y: number;
    width: number;
    height: number;
    lines: LineData[];
  }
  export const Typesetting: (offset: Vector2 | undefined, label: UILabel) => TypesettingData;
  export {};
}
declare module "engine/game/2D/label/fillRenderData" {
  import { BlendType } from "engine/math/color";
  import { TypesettingData } from "engine/game/2D/label/typesetting";
  import { RenderData } from "engine/game/2D/renderable2D";
  import UILabel from "engine/game/2D/label/UILabel";
  /**
   * 阴影 -> 字符 -> 下划线
   */
  export function fillRenderData(label: UILabel, tsData: TypesettingData, renderDatas: RenderData[]): void;
  export function fillRenderDataColor(label: UILabel, tsData: TypesettingData, renderDatas: RenderData[], parentColor: number, blentType: BlendType): void;
}
declare module "engine/game/2D/label/UILabel" {
  import BitmapFont from "engine/assets/classes/bitmapFont";
  import Font from "engine/assets/classes/font";
  import Color from "engine/math/color";
  import Vector2 from "engine/math/vector2";
  import { Entity2D } from "engine/scene/scene";
  import { Immutable, Nullable } from "engine/type";
  import Renderable2D, { RenderData } from "engine/game/2D/renderable2D";
  import TextSystem from "engine/game/2D/system/text";
  import { TextAlign, TextVAlign, overflowType } from "engine/game/2D/label/enum";
  export default class UILabel extends Renderable2D {
    readonly entity: Entity2D;
    /**
     * 富文本越界处理方式枚举类型
     *
     * @static
     * @memberof UIRichText
     */
    static overflowType: typeof overflowType;
    static DefaultFontFamily: string;
    static DefaultFontSize: number;
    get text(): string;
    set text(val: string);
    get italic(): boolean;
    set italic(val: boolean);
    get bold(): boolean;
    set bold(val: boolean);
    get fontFamily(): string;
    set fontFamily(val: string);
    get font(): Nullable<Font>;
    set font(font: Nullable<Font>);
    get bitmapFont(): Nullable<BitmapFont>;
    set bitmapFont(bitmapFont: Nullable<BitmapFont>);
    get fontSize(): number;
    set fontSize(val: number);
    get fontColor(): Color;
    set fontColor(val: Color);
    get applyGradient(): boolean;
    set applyGradient(val: boolean);
    get gradientTop(): Color;
    set gradientTop(val: Color);
    get gradientBottom(): Color;
    set gradientBottom(val: Color);
    get spacing(): number;
    set spacing(val: number);
    get lineSpace(): number;
    set lineSpace(val: number);
    get align(): TextAlign;
    set align(val: TextAlign);
    get valign(): TextVAlign;
    set valign(val: TextVAlign);
    get wordWrap(): boolean;
    set wordWrap(val: boolean);
    get autoSize(): boolean;
    set autoSize(val: boolean);
    get stroke(): number;
    set stroke(val: number);
    get strokeColor(): Color;
    set strokeColor(val: Color);
    get shadowOffset(): Vector2;
    set shadowOffset(val: Vector2);
    get shadowColor(): Color;
    set shadowColor(val: Color);
    /**
     * 下划线的宽度
     * @memberof UILabel
     */
    get underline(): number;
    set underline(val: number);
    /**
     * 下划线的颜色
     * @memberof UILabel
     */
    get underlineColor(): Color;
    set underlineColor(val: Color);
    get emoji(): boolean;
    set emoji(val: boolean);
    get metrics(): Immutable<{
      width: number;
      height: number;
      innerWidth: number;
      innerHeight: number;
      outerWidth: number;
      outerHeight: number;
    }>;
    /**
     * 文本越界处理方式
     *
     * @type {overflowType}
     * @memberof UILabel
     */
    set overflow(val: overflowType);
    get overflow(): overflowType;
    queryDirty: boolean;
    constructor(entity: Entity2D);
    setTextDirty(): void;
    resetProperties(): void;
  }
}
declare module "engine/game/2D/label/glyph" {
  import Texture2D from "engine/assets/classes/texture2D";
  export const getFontString: (italic: boolean, bold: boolean, fontSize?: number, fontFamily?: string) => string;
  export type Glyph = {
    offsetX: number;
    offsetY: number;
    width: number;
    height: number;
    uvs: number[];
    texture: Texture2D;
  };
  class GlyphSet {
    has(character: string, font: string): boolean;
    set(character: string, font: string, glyph: Glyph): void;
    get(character: string, font?: string): Glyph | undefined;
    getUnderline(): Glyph;
    getByFontStyle(character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string): Glyph | undefined;
  }
  const _default: GlyphSet;
  export default _default;
}
declare module "engine/game/2D/label/glyph/gfx" {
  import { Glyph } from "engine/game/2D/label/glyph";
  export const getBlankGlyph: (font: string) => Glyph;
  export const queryGlyph: (character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string) => Glyph;
  export const queryGlyphByFontString: (character: string, font: string) => Glyph;
  export const batchQueryGlyphByFontString: (text: ArrayLike<string>, font: string, emoji: boolean) => Glyph[];
  export const batchQueryGlyph: (text: ArrayLike<string>, italic: boolean, bold: boolean, fontSize: number, fontFamily: string, emoji: boolean) => Glyph[];
}
declare module "engine/assets/classes/spriteFrame" {
  import Rect from "engine/math/rect";
  import Vector4 from "engine/math/vector4";
  import { Nullable } from "engine/type";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { SpriteframeResourceDescription } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  import Texture2D from "engine/assets/classes/texture2D";
  /**
   *
   *
   * @export
   * @class SpriteFrame
   * @extends {BaseResource}
   */
  export default class SpriteFrame extends BaseResource {
    /**
     * 贴图。
     * @type {Nullable<Texture2D>}
     * @memberof SpriteFrame
     */
    get texture(): Nullable<Texture2D>;
    /**
     * 贴图在图集中的区域。
     * @type {Rect}
     * @memberof SpriteFrame
     */
    get rect(): Rect;
    /**
     * 贴图在图集中的边框大小。
     * @readonly
     * @type {Vector4}
     * @memberof SpriteFrame
     */
    get trim(): Vector4;
    /**
     * 九宫格裁剪位置在Rect中的相对位置。
     * @type {Rect}
     * @memberof SpriteFrame
     */
    get slicedRect(): Rect;
    /**
     * 图片资源反序列化方法。
     * @static
     * @param {SpriteframeResourceDescription} resourceDescription 资源配置。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {SpriteFrame}
     * @memberof SpriteFrame
     */
    static DeserializeResource(resourceDescription: SpriteframeResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): SpriteFrame;
    /**
     * 从贴图资源创建图片资源。
     * @static
     * @param {Texture2D} texture
     * @param {Rect} [rect]
     * @param {Rect} [slicedRect]
     * @param {Vector4} [trim]
     * @returns {SpriteFrame}
     * @memberof SpriteFrame
     */
    static createFromTexture(texture: Texture2D, rect?: Rect, slicedRect?: Rect, trim?: Vector4): SpriteFrame;
  }
}
declare module "engine/settings" {
  export const BaseSettings: {
    TexturePackingWidth: number;
    TexturePackingHeight: number;
    designWidth: number;
    designHeight: number;
    renderWidth: number;
    renderHeight: number;
    enableCatchError: boolean;
  };
  export enum AdaptationType {
    Auto = 0,
    FillWidth = 1,
    FillHeight = 2,
  }
  export default class Settings {
    get screenWidth(): number;
    get screenHeight(): number;
    get renderScale(): number;
    get enableCatchError(): boolean;
    set enableCatchError(val: boolean);
    get designWidth(): number;
    set designWidth(val: number);
    get designHeight(): number;
    set designHeight(val: number);
    get baseURL(): string;
    set baseURL(val: string);
    get renderWidth(): number;
    set renderWidth(val: number);
    get renderHeight(): number;
    set renderHeight(val: number);
    get aspect(): number;
    get uiScale(): number;
    get setDesignWidth(): number;
    get setDesignHeight(): number;
    get setRenderWidth(): number;
    get setRenderHeight(): number;
    get mainScreenMSAA(): boolean;
    constructor(settings: any);
    setScreenSize(width: number, height: number): void;
    setDesignSize(width: number, height: number): void;
    setRenderSize(width: number, height: number): void;
  }
}
declare module "engine/graphicResource/texturePacker" {
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  import Texture2D, { Texture2DDesc } from "engine/assets/classes/texture2D";
  import Rect from "engine/math/rect";
  import { Nullable } from "engine/type";
  import { SmartArray } from "engine/misc/array";
  class BlockTreeNode extends Rect {
    used: boolean;
    right: Nullable<BlockTreeNode>;
    down: Nullable<BlockTreeNode>;
  }
  class BlockInfo {
    texture: Texture2D;
    frameInfo: Nullable<{
      rect: BlockTreeNode;
      texture: Nullable<Texture2D>;
      spriteFrame: Nullable<SpriteFrame>;
    }>;
    width: number;
    height: number;
    constructor(texture: Texture2D);
  }
  class BinPacker {
    root: BlockTreeNode;
    constructor(width: number, height: number);
    /**
     * Try to fit the node, if success the frameInfo of a node is not null.
     * @param blocks
     */
    fit(blocks: SmartArray<BlockInfo>): void;
  }
  export default class TexturePacker {
    constructor(textureDesc?: Texture2DDesc);
    addTextures(textures: Texture2D[]): SpriteFrame[];
    removeTextures(textures: Texture2D[]): void;
    releaseSpriteFrames(frames: SpriteFrame[]): void;
  }
  export {};
}
declare module "engine/game/2D/label/glyph/2d" {
  import { Glyph } from "engine/game/2D/label/glyph";
  export const queryGlyph: (character: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string) => Glyph;
}
declare module "engine/game/2D/label/glyph/query" {
  import { batchQueryGlyph, batchQueryGlyphByFontString } from "engine/game/2D/label/glyph/gfx";
  import { Glyph } from "engine/game/2D/label/glyph";
  const queryGlyph: (text: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string) => Glyph;
  const measureText: (
    text: string,
    italic: boolean,
    bold: boolean,
    fontSize: number,
    fontFamily: string,
    emoji: boolean,
  ) => {
    width: number;
    height: number;
  };
  export { queryGlyph, batchQueryGlyph, batchQueryGlyphByFontString, measureText };
}
declare module "engine/game/2D/system/text" {
  import { IGameSystem } from "engine/game/game";
  import UILabel from "engine/game/2D/label/UILabel";
  type Game = import("engine/game/game").default;
  export default class TextSystem implements IGameSystem {
    readonly game: Game;
    constructor(game: Game);
    dispose(): void;
    get useQueryTextList(): boolean;
    /**
     * 提交文字与对应样式到，文本预备批量处理队列。
     */
    queryText(text: string, italic: boolean, bold: boolean, fontSize: number, fontFamily: string, emoji: boolean): void;
    /**
     * 文本预备批量处理队列提交到客户端。
     */
    updateTexts(): void;
    /**
     * 提交文本对象到，文本对象预备批量处理队列
     */
    queryLabel(label: UILabel): void;
    /**
     * 文本预备批量处理队列，提交到文本队列，并执行
     */
    updateLabels(): void;
  }
  export {};
}
declare module "engine/game/FrameSystem" {
  import LitePromise from "lib/utils/promise";
  export enum FrameSystemMode {
    IMMEDIATE = 0,
    ORDINARY = 1,
  }
  export class FrameSystem {
    static init(startTime: any): void;
    static runTaskByFrame(task: any): LitePromise<unknown>;
    static update(frameStartTime: number): void;
    static setPreferredFramesPerSecond(fps: number): void;
    static TargetFrameTime(): number;
    static setMode(mode: FrameSystemMode): void;
  }
}
declare module "engine/worker/messenger" {
  /**
   * @file 简易通信类
   * @author shanexyzhou
   */
  import EngineWorker from "engine/worker/worker";
  export default class Messenger {
    constructor(worker: EngineWorker);
    once(callback: any, pred: any): void;
    on(callback: any, pred: any): void;
  }
}
declare module "engine/worker/syncPair" {
  export default class SyncPair {
    constructor(sab?: any);
    get sab(): [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];
    get toggle(): number;
    get(): engineWX.SharedArrayBuffer;
    switch(): this;
    lock(cb: () => void): void;
    unlock(): void;
  }
}
declare module "engine/worker/msgapi" {
  // 这里记录engine和worker通信的格式
  export namespace WorkerMessageAPI {
    export interface BaseWorkerMsg {
      type: string;

      /**
       * 引擎内的worker版本号
       * 通过engine.workerVersion获取
       */
      version: string;
    }

    // 启动任务
    export interface StartJob extends BaseWorkerMsg {
      type: "startJob";

      /**
       * 用于同步的两个锁
       */
      sync: [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];

      /**
       * 用于同步状态的flag
       * flag[0] sync位置(0-1)
       * flag[1] 任务状态
       * flag[1]=0 worker未执行任务
       * flag[1]=1 job running
       * flag[1]=2 engine主动停止任务
       * flag[1]=3 invalid
       */
      flag: engineWX.SharedArrayBuffer;

      /**
       * 任务名, 在worker里注册
       */
      name: string;

      /**
       * 用于数据交换的object, 里面包含wx.SharedArrayBuffer
       */
      data: object;
    }

    export interface RequireAndStartJob extends BaseWorkerMsg {
      type: "requireAndStartJob";

      sync: [engineWX.SharedArrayBuffer, engineWX.SharedArrayBuffer];

      flag: engineWX.SharedArrayBuffer;

      /**
       * require的文件路径
       */
      path: string;

      data: object;
    }

    // RPC
    export interface RPCSend extends BaseWorkerMsg {
      type: "rpc";

      /**
       * flag[0] 过程状态
       * flag[0] = 0 worker内未执行
       * flag[1] = 1 worker内正在执行
       * flag[1] = 2 worker内完成
       */
      flag: engineWX.SharedArrayBuffer;

      /**
       * 数据交互块
       */
      data: object;

      /**
       * 过程名
       */
      name: string;

      /**
       * 过程编号
       */
      taskId: number;
    }
  }
}
declare module "engine/worker/worker" {
  /**
   * @file 代表一个worker资源
   * @author shanexyzhou
   */
  import { Nullable } from "engine/type";
  import SyncPair from "engine/worker/syncPair";
  type StatusEnum = "init" | "running" | "terminated" | "invalid";
  export default class EngineWorker {
    static getCurrent(): Nullable<EngineWorker>;
    /**
     * 外部使用makeCurrent来切换当前worker
     * @param worker
     */
    static makeCurrent(worker: EngineWorker): void;
    status: StatusEnum;
    constructor(path: string);
    postMessage(msg: any): void;
    onMessage(callback: (message: any) => void): void;
    on(pred: (msg: any) => boolean, callback: (msg: any) => void): void;
    once(pred: (msg: any) => boolean, callback: (msg: any) => void): void;
    terminate(): void;
  }
  export {};
}
declare module "engine/worker/job" {
  /**
   * @file 代表game中的一个job
   * @author shanexyzhou
   */
  import SyncPair from "engine/worker/syncPair";
  type Game = import("engine/game/game").default;
  type StatusEnum = "init" | "starting" | "running" | "suspended" | "destroying" | "destroyed" | "invalid";
  export default class WorkerJob {
    flagView: Uint8Array;
    resolve?: Function;
    /**
     * 用户指定的engine内回调
     */
    work?: Function;
    get data(): object;
    get jobPath(): string;
    get status(): StatusEnum;
    get sync(): SyncPair;
    constructor(game: Game, jobPath: string, data: object);
    /**
     * 启动job
     * @param workCallback 引擎内的回调
     */
    start(workCallback?: Function): void;
    /**
     * 暂停任务，会跳过每帧末的回调，worker内也不执行。
     */
    suspend(): void;
    /**
     * 重启任务。状态会回到starting。
     */
    resume(): void;
    /**
     * 终止任务。worker内的任务也会被删除。
     */
    dispose(): void;
    /**
     * 重新设置引擎内回调。
     * @param workCallback 引擎内回调
     */
    setWorkCallback(workCallback: Function): void;
  }
  export {};
}
declare module "engine/worker/rpc" {
  type Game = import("engine/game/game").default;
  type StatusEnum = "init" | "starting" | "running" | "done" | "invalid";
  export default class WorkerRPC {
    flagView: Uint8Array;
    resolve?: Function;
    get status(): StatusEnum;
    constructor(game: Game, funcName: string, data: object);
  }
  export {};
}
declare module "engine/system/worker" {
  /**
   * @file game中的workerSystem
   * @author shanexyzhou
   */
  import EngineWorker from "engine/worker/worker";
  import WorkerJob from "engine/worker/job";
  import WorkerRPC from "engine/worker/rpc";
  import { Nullable } from "engine/type";
  import { IGameSystem } from "engine/game/game";
  type Game = import("engine/game/game").default;
  /**
   * @classdesc 保存game创建的所有job，并每帧末更新job
   */
  export default class WorkerSystem implements IGameSystem {
    readonly game: Game;
    worker: Nullable<EngineWorker>;
    jobList: Array<WorkerJob>;
    plist: Array<Promise<void>>;
    rpcList: Array<WorkerRPC>;
    active: boolean;
    constructor(game: Game);
    init(): void;
    update(): Nullable<Promise<any>>;
    updateRPC(): void;
    createJob(jobPath: string, data: object): Nullable<WorkerJob>;
    createRPC(funcName: string, data: object, callback: (data: any) => void): void;
    dispose(): void;
  }
  export {};
}
declare module "engine/game/game" {
  import { default as SceneResource } from "engine/assets/classes/scene";
  import KeyboardManager from "engine/input/keyboard";
  import { RawTouchEvents } from "engine/platform/touch";
  import Entity from "engine/scene/entity";
  import { Entity2D, Entity3D, Scene2D, Scene3D } from "engine/scene/scene";
  import AnimationSystem from "engine/system/animation";
  import NodeSystem from "engine/system/node";
  import RenderSystem from "engine/system/render";
  import TextSystem from "engine/game/2D/system/text";
  import UICamera from "engine/game/2D/UICamera";
  import UICanvas from "engine/game/2D/UICanvas";
  import { Emitter } from "engine/misc/emitter";
  import { DirectionalLightEventType, MeshRendererEventType, Renderable2DEventType, PipeLineEventType } from "engine/event";
  import WorkerSystem from "engine/system/worker";
  export interface IGameSystem {
    readonly game: Game;
    dispose(): void;
  }
  export const DefaultEntityName = "NewEntity";
  export const DefaultEntity2DName = "NewEntity2D";
  export default class Game {
    readonly keyboardManager: KeyboardManager;
    readonly renderSystem: RenderSystem;
    readonly nodeSystem: NodeSystem;
    readonly animationSystem: AnimationSystem;
    readonly textSystem: TextSystem;
    readonly workerSystem: WorkerSystem;
    readonly root: Entity3D;
    readonly sceneRoot: Entity2D & Entity3D;
    readonly detachedRoot: Entity2D & Entity3D;
    readonly editorRootEntity?: Entity2D & Entity3D;
    readonly rootUICanvas: UICanvas;
    readonly rootUICamera: UICamera;
    readonly persistEntities: Set<Entity>;
    readonly meshRendererEvent: Emitter<import("engine/game/3D/meshRenderer").default, MeshRendererEventType>;
    readonly directionalLightEvent: Emitter<import("engine/game/3D/directionalLight").default, DirectionalLightEventType>;
    readonly renderable2DEvent: Emitter<import("engine/game/2D/renderable2D").default, Renderable2DEventType>;
    readonly pipelineEvent: Emitter<PipeLineEventType, void>;
    readonly touchEvent: Emitter<RawTouchEvents, TouchEvent>;
    gameTime: number;
    get activeScene(): Scene3D;
    get activeScene2D(): Scene2D;
    startTime: number;
    lastFrameTime: number;
    mainFrameCnt: number;
    constructor();
    markAsPersist(entity: Entity): void;
    createEntity2D(name?: string): Entity2D;
    createEntity3D(name?: string): Entity3D;
    playScene(scene: SceneResource): Entity;
    clearScene(clear3D: boolean, clear2D: boolean): void;
    run(): void;
    dumpScene(): [string, string];
    dispose(): void;
    /**
     * 让game使用当前启用的worker。
     * 如果有之前在使用着的worker，会清空job队列。
     */
    initWorkerSystem(): void;
    /**
     * 创建worker job
     * @param jobPath 任务文件路径
     * @param data 自定义的共享数据块，用于和worker交换数据
     */
    createWorkerJob(jobPath: string, data: object): import("engine/type").Nullable<import("engine/engine").WorkerJob>;
    /**
     * TODO
     * in progress
     */
    rpc(funcName: string, data: object, callback: (data: any) => void): void;
  }
}
declare module "engine/system/animation" {
  import { IGameSystem } from "engine/game/game";
  import { SmartArray } from "engine/misc/array";
  type Game = import("engine/game/game").default;
  type TransformBase = import("engine/game/transformBase").default;
  type Transform3D = import("engine/game/transform3D").default;
  type MetaAnimationComponent = import("engine/game/3D/animator/meta").MetaAnimationComponent;
  export default class AnimationSystem implements IGameSystem {
    readonly game: Game;
    constructor(game: Game);
    markAnimatorNodesNeedDirty(comps: Transform3D[]): void;
    markAnimatorNeedUpdate(comp: wxGA.AnimatorComponent): void;
    cancelAnimatorUpdate(comp: wxGA.AnimatorComponent): void;
    markMetaAnimatorNeedUpdate(comp: MetaAnimationComponent): void;
    cancelMetaAnimatorUpdate(comp: MetaAnimationComponent): void;
    markSkinningMatrixNeedUpdate(comp: wxGA.SkinnedSkeletonComponent): void;
    bindBone(transform: TransformBase, entity: wxGA.Entity3D): void;
    unbindBone(transform: TransformBase): void;
    updateAnimators(): void;
    updateMetaAnimators(): void;
    updateSkinningMatrices(): void;
    updateBones(): void;
    dispose(): void;
  }
  export {};
}
declare module "engine/game/3D/animator/avatar" {
  import AnimationClip from "engine/assets/classes/animationClip";
  import AnimationSystem from "engine/system/animation";
  import { DeepImmutable, Nullable } from "engine/type";
  import { MetaAnimationComponent } from "engine/game/3D/animator/meta";
  import Avatar from "engine/assets/classes/avatar";
  import Transform3D from "engine/game/transform3D";
  interface IAvatarInfo {
    names: string[];
    pathToIndex: {
      [path: string]: number;
    };
    nameToPath: {
      [name: string]: string;
    };
  }
  interface IAvatarInstance {
    root: wxGA.Entity3D;
    skeletons: wxGA.Entity3D[];
  }
  export class AvatarUtils {
    static GetSkeletons(avatar: Avatar, info: IAvatarInfo): IAvatarInstance;
    static PutSkeletons(avatar: Avatar, instance: IAvatarInstance): boolean;
    static GetAvatarInfo(avatar: Avatar): IAvatarInfo;
    static FindNodeByPath(root: Transform3D, path: string): Nullable<Transform3D>;
  }
  export class AvatarBinding {
    get hasAvatar(): boolean;
    constructor(avatar: Nullable<Avatar>, animator: wxGA.AnimatorComponent, metaAnimator: MetaAnimationComponent, rootNode: Transform3D, animationClips: Array<DeepImmutable<AnimationClip>>);
    getBoneByPath(path: string): Nullable<wxGA.Entity3D>;
    rebind(animationClips: Array<DeepImmutable<AnimationClip>>): void;
    update(): void;
    dispose(): void;
    /**
     * 新增一个Avatar Shadow Bones
     *
     * @param {string} path
     * @param {string} name
     * @returns
     * @memberof AvatarBinding
     */
    addExtraAvatarShadowBones(path: string, name?: string): void;
  }
  export {};
}
declare module "engine/game/3D/animator/error" {
  import { AnimatorState } from "engine/game/3D/animator/classes";
  import AnimationClip from "engine/assets/classes/animationClip";
  export enum ErrorCode {
    /**
     * Calcution errors.
     */
    InvalidNormalizedTime = 4608,
    MissingCycleOffsetParameter = 4609,
    MissingMirrorParameter = 4610,
    MissingSpeedParameter = 4611,
    /**
     * Logic errors.
     */
    ClipIndexOutOfRange = 4864,
    MissingStateMachine = 4865,
    InvalidTransition = 4866,
    StateMachineTransitionNotSupport = 4867,
    /**
     * API params errors.
     */
    InvalidCrossFadeStateName = 5120,
    InvalidCrossFadeLayerName = 5121,
    CrossFadeStateNameNotFound = 5122,
    CrossFadeStateHashNotFound = 5123,
    CrossFadeLayerIndexOutOfRange = 5124,
    CrossFadeInvalidCurrentState = 5125,
  }
  export const ErrorFunctions: {
    4608: () => void;
    4609: (state: AnimatorState) => void;
    4610: (state: AnimatorState) => void;
    4611: (state: AnimatorState) => void;
    4864: (animationClip: import("engine/type").DeepImmutableObject<AnimationClip>) => void;
    4865: (layerName: string) => void;
    4866: () => void;
    4867: () => void;
    5120: (stateName: string) => void;
    5121: (layerName: string) => void;
    5122: (layerName: string, stateName: string) => void;
    5123: (stateHashOrName: number) => void;
    5124: (layerIndex: number) => void;
    5125: () => void;
  };
}
declare module "engine/game/3D/animator/transition" {
  export {};
}
declare module "engine/game/3D/animator/clipvalues" {
  import { IBlendInfo } from "engine/game/3D/animator/blendtree";
  import Animator from "engine/game/3D/animator";
  import { AnimatorState } from "engine/game/3D/animator/classes";
  export const ClipValuesBuffer: ArrayBuffer;
  export function ResetClipValues(): void;
  export function ClampStateNormalizedTime(this: void, animator: Animator, normalizedTime: number, state: AnimatorState, loop: boolean): number;
  export function RegisterClipValues(this: Animator, state: AnimatorState, updatedNormalizedTime: number, blendInfo: IBlendInfo, weightCoefficient: number): void;
  export function CommitClipValues(this: Animator): void;
  export function UncommitClipValues(this: Animator): void;
}
declare module "engine/game/3D/animator" {
  import AnimatorController from "engine/assets/classes/animatorController";
  import Avatar from "engine/assets/classes/avatar";
  import { Delegate } from "engine/misc/delegate";
  import { Entity3D } from "engine/scene/scene";
  import { float, int, Nullable } from "engine/type";
  import Component from "engine/game/component";
  import { AvatarBinding } from "engine/game/3D/animator/avatar";
  import AnimationSystem from "engine/system/animation";
  import {
    AnimationLayer,
    AnimatorController as RuntimeAnimatorController,
    AnimatorControllerParameter,
    AnimatorState,
    AnimatorStateTransition,
    IAnimatorStateInfo,
    ITransitionInfo,
  } from "engine/game/3D/animator/classes";
  import { MetaAnimationComponent } from "engine/game/3D/animator/meta";
  import { StringToHash } from "engine/game/3D/animator/utils";
  import { SmartArray } from "engine/misc/array";
  export default class Animator extends Component {
    readonly entity: Entity3D;
    /**
     * The AnimatorControllerParameter list used by the animator. (Read Only)
     */
    get parameters(): AnimatorControllerParameter[];
    /**
     * Returns the number of parameters in the controller.
     */
    get parameterCount(): number;
    /**
     * Returns the number of layers in the controller.
     */
    get layerCount(): number;
    get speed(): number;
    set speed(speed: number);
    get avatar(): Nullable<Avatar>;
    set avatar(avatar: Nullable<Avatar>);
    get controller(): Nullable<RuntimeAnimatorController>;
    set controller(controller: Nullable<RuntimeAnimatorController>);
    get layers(): AnimationLayer[];
    get isInitialized(): boolean;
    /**
     * property：
     * -layerCount
     * -parameters(read Only)
     * -speed
     *
     * API
     * -GetAnimatorTransitionInfo //
     * -GetBool
     * -GetCurrentAnimatorClipInfo
     * -GetCurrentAnimatorClipInfoCount
     * -GetCurrentAnimatorStateInfo //
     * -GetFloat
     * -GetInteger
     * -GetLayerWeight
     * -GetNextAnimatorClipInfo
     * -GetNextAnimatorClipInfoCount
     * -GetNextAnimatorStateInfo
     * -HasState
     * -ResetTrigger
     * -SetBool
     * -SetFloat
     * -SetInteger
     * SetLayerWeight
     * -SetTrigger
     */
    static StringToHash: typeof StringToHash;
    priority: number;
    readonly onAvatarChanged: Delegate<this, Nullable<Avatar>>;
    constructor(entity: Entity3D);
    onDeserialized(
      data: any,
      context: {
        [key: string]: any[];
      },
      builtContext: {
        [key: string]: SmartArray<any>;
      },
    ): void;
    setController(controller: Nullable<RuntimeAnimatorController | AnimatorController>, cb?: Nullable<(...args: any[]) => any>): void;
    getCurrentAnimatorStateInfo(layerIndex: number | undefined, dst: IAnimatorStateInfo): Nullable<IAnimatorStateInfo>;
    getCurrentAnimatorState(layerIndex?: number): Nullable<AnimatorState>;
    getCurrentAnimatorTransition(layerIndex?: number): Nullable<AnimatorStateTransition>;
    getNextAnimatorStateInfo(layerIndex?: number): Nullable<IAnimatorStateInfo>;
    getParameter(name: string): Nullable<AnimatorControllerParameter>;
    getFloat(arg: string): Nullable<number>;
    setFloat(arg: string, value: number): void;
    getInteger(arg: string): Nullable<number>;
    setInteger(arg: string, value: number): void;
    getBool(arg: string): Nullable<boolean>;
    setBool(arg: string, value: boolean): void;
    setTrigger(arg: string): void;
    resetTrigger(arg: string): void;
    getAnimatorTransitionInfo(layerIndex: number): Nullable<ITransitionInfo>;
    getLayerWeight(layerIndex?: number): number;
    hasState(layerIndex: number, name: string | number): boolean;
    rebind(): void;
    isInTransition(layerIndex: number): boolean;
    /**
     * CrossFade to a state.
     * @param {string | int} stateHashOrName The name or hash generated for a state of animator, when name is used layer should be with the string, eg. 'Base Layer.Run'.
     * @param {float} transitionDuration The duration of the transition.
     * @param {boolean} fixedDuration To treat transitionDuration as normalized value or not.
     * @param {int} layer The layer where the crossfade occurs.
     * @param {float} normalizedTimeOffset The time of the state (normalized).
     * @param {float} normalizedTransitionTime The time of the transition (normalized).
     */
    crossFade(stateHashOrName: string | int, transitionDuration: float, fixedDuration?: boolean, layer?: int, normalizedTimeOffset?: float, normalizedTransitionTime?: float): void;
    /**
     * Play a state
     * @param {string | int} stateName The name or hash generated for a state of animator, when name is used layer should be with the string, eg. 'Base Layer.Run'.
     * @param {int} layer The layer where the crossfade occurs.
     * @param {float} normalizedTime The time of the state (normalized).
     */
    play(stateName: string | int, layer?: int, normalizedTime?: float): void;
    reset(): void;
  }
}
declare module "engine/game/3D/animator/blendtree" {
  import AnimationClip from "engine/assets/classes/animationClip";
  import { DeepImmutable } from "engine/type";
  import { AnimatorState } from "engine/game/3D/animator/classes";
  import Animator from "engine/game/3D/animator";
  import { SmartArray } from "engine/misc/array";
  /**
   * Blend info protocal.
   * Array<clip> + Array<| calculated length float32 | calculated weight float32 | calculated speed float32 | clip index uint8 | parentId uint8 | self loop uint8 | calculated loop 8 bits |>
   * At most support blend tree with 32 nodes.
   */
  export const MaxBlendTreeNodes = 128;
  export const AnimatorBlendInfoUnitSize: number;
  export const InvalidValue8: number;
  export const MaxAnimatorBlendInfoSize: number;
  export interface IBlendInfo {
    clips: SmartArray<DeepImmutable<AnimationClip>>;
    f32: Float32Array;
    uint8: Uint8Array;
    count: number;
  }
  export function GetStateSpeed(this: void, animator: Animator, state: AnimatorState): number;
  export function GetStateBlendInfo(this: Animator, currentState: AnimatorState, weight: number, result: IBlendInfo): number;
}
declare module "engine/game/3D/animator/classes" {
  import AnimationClip from "engine/assets/classes/animationClip";
  import Vector2 from "engine/math/vector2";
  import { DeepImmutable, Nullable } from "engine/type";
  import { SmartArray } from "engine/misc/array";
  import { AnimatorControllerDescription, BlendTreeType, AnimatorControllerParameterType, AnimatorLayerBlendingMode, ConditionMode, TransitionInterruptionSource } from "engine/assets/resource";
  export interface IAnimatorControllerParameter {
    name: string;
    type: AnimatorControllerParameterType;
    default: any;
  }
  export interface IBlend1D {
    type: BlendTreeType.Simple1D;
    parameter: string;
    thresholds: number[];
    minThreshold: number;
    maxThreshold: number;
  }
  export interface IBlend2D {
    type: BlendTreeType.FreeformCartesian2D | BlendTreeType.FreeformDirectional2D | BlendTreeType.SimpleDirectional2D;
    parameterX: string;
    parameterY: string;
    positions: Array<[number, number]>;
  }
  export interface IBlendDirect {
    type: BlendTreeType.Direct;
    parameters: Array<Nullable<string>>;
  }
  export type AnimatorBlend = IBlend1D | IBlend2D | IBlendDirect;
  export interface IAnimatorBlendTree {
    name: string;
    children: Array<{
      motion: IAnimatorBlendTree | DeepImmutable<AnimationClip>;
      timeScale: number;
    }>;
    blend: AnimatorBlend;
  }
  export interface IAnimatorState {
    name: string;
    motion: Nullable<DeepImmutable<AnimationClip> | IAnimatorBlendTree>;
    speed: number;
    speedParameter: Nullable<string>;
    timeParameter: Nullable<string>;
    cycleOffset: number;
    cycleOffsetParameter: Nullable<string>;
    mirror: boolean;
    mirrorParameter: Nullable<string>;
    transitions: IAnimatorStateTransition[];
  }
  export interface IAnimatorStateMachine {
    name: string;
    states: IAnimatorState[];
    defaultState: Nullable<IAnimatorState>;
    anyStateTransitions: IAnimatorStateTransition[];
    entryPosition?: Vector2;
    exitPosition?: Vector2;
    anyStatePosition?: Vector2;
  }
  export interface IAnimationLayer {
    name: string;
    stateMachine: IAnimatorStateMachine;
    blending: AnimatorLayerBlendingMode;
    IKPass: boolean;
    /**
     * Avatar mask
     */
    mask?: any;
    weight: number;
  }
  export interface IAnimatorStateTransition {
    conditions: Array<{
      name: string;
      operator: ConditionMode;
      value: number | boolean;
    }>;
    fixedDuration: boolean;
    duration: number;
    offset: number;
    interruption: number;
    orderedInterruption: boolean;
    exitTime: number;
    hasExitTime: boolean;
    destState: Nullable<IAnimatorState | IAnimatorStateMachine>;
  }
  export class AnimatorBlendTree implements IAnimatorBlendTree {
    name: string;
    children: Array<{
      index: number;
      motion: AnimatorBlendTree | DeepImmutable<AnimationClip>;
      timeScale: number;
    }>;
    blendParameter: string[];
    blend: AnimatorBlend;
    onDeserialized(
      data: any,
      context: {
        [key: string]: any[];
      },
      builtContext: {
        [key: string]: SmartArray<any>;
      },
    ): void;
  }
  export class AnimatorCondition {
    name: string;
    operator: ConditionMode;
    value: number | boolean;
    check(parameter: AnimatorControllerParameter): boolean;
  }
  export class AnimatorStateTransition implements IAnimatorStateTransition {
    conditions: AnimatorCondition[];
    /**
     * False as a fraction of the normalized time of the source state
     */
    fixedDuration: boolean;
    duration: number;
    /**
     * The offset of the time to begin playing in the destination state which is transitioned to.
     */
    offset: number;
    exitTime: number;
    hasExitTime: boolean;
    interruption: TransitionInterruptionSource;
    orderedInterruption: boolean;
    destState: AnimatorState | AnimatorStateMachine;
    index: number;
    sourceState: AnimatorState | AnimatorStateMachine;
  }
  export class AnimatorState implements IAnimatorState {
    readonly name: string;
    readonly nameHash: number;
    motion: Nullable<DeepImmutable<AnimationClip> | AnimatorBlendTree>;
    speed: number;
    speedParameter: Nullable<string>;
    /**
     * If timeParameterActive is true, the value of this Parameter will be used instead of normalized time.
     */
    timeParameter: Nullable<string>;
    cycleOffset: number;
    cycleOffsetParameter: Nullable<string>;
    mirror: boolean;
    mirrorParameter: Nullable<string>;
    transitions: AnimatorStateTransition[];
    position?: Vector2;
    onDeserialized(data: any): void;
  }
  export class AnimatorStateMachine implements IAnimatorStateMachine {
    name: string;
    states: AnimatorState[];
    defaultState: Nullable<AnimatorState>;
    anyStateTransitions: AnimatorStateTransition[];
    entryPosition?: Vector2;
    exitPosition?: Vector2;
    anyStatePosition?: Vector2;
  }
  export class AnimatorControllerParameter implements IAnimatorControllerParameter {
    name: string;
    type: AnimatorControllerParameterType;
    default: any;
    get value(): any;
    set value(value: any);
  }
  export class AnimationLayer implements IAnimationLayer {
    name: string;
    stateMachine: AnimatorStateMachine;
    blending: AnimatorLayerBlendingMode;
    IKPass: boolean;
    index: number;
    /**
     * Avatar mask
     */
    mask?: any;
    weight: number;
    onDeserialized(data: any): void;
  }
  export class AnimatorController {
    get parameterCount(): number;
    get layerCount(): number;
    name: string;
    parameters: AnimatorControllerParameter[];
    layers: AnimationLayer[];
    animationClips: Array<DeepImmutable<AnimationClip>>;
    onDeserialized(
      data: any,
      context: AnimatorControllerDescription,
      builtContext: {
        [key: string]: SmartArray<any>;
      },
    ): void;
  }
  export interface IAnimatorStateInfo {
    length: number;
    nameHash: number;
    normalizedTime: number;
  }
  export class Director {
    get isInTransition(): boolean;
    currentState: Nullable<AnimatorState>;
    currentTransition: Nullable<AnimatorStateTransition>;
    transitionInfo: Nullable<ITransitionInfo>;
    normalizedTime: number;
    length: number;
    constructor(layer: AnimationLayer);
  }
  export interface ITransitionInfo {
    enterTime: number;
    duration: number;
    fixedDuration: boolean;
    time: number;
    destState: AnimatorState | AnimatorStateMachine;
    transitionOffset: number;
  }
}
declare module "engine/game/3D/animator/utils" {
  export function StringToHash(this: void, str: string): number;
}
declare module "engine/materials/pass" {
  import Effect from "engine/assets/classes/effect";
  import { EffectAsset, IMaterialRenderStates, PipelineTypeString } from "engine/assets/resource";
  import Shader from "engine/graphicResource/shader";
  import { Nullable } from "engine/type";
  import { EnumRendererType } from "engine/materials/buildinShaderDesc";
  import ShaderDefination from "engine/materials/shaderDefination";
  export interface IPassRenderStates {
    blendOn: boolean;
    blendSrc: wgfx.EnumBlendFactor;
    blendDst: wgfx.EnumBlendFactor;
    blendFunc: wgfx.EnumBlendOp;
    cullOn: boolean;
    cullFace: wgfx.EnumCullMode;
    depthWrite: boolean;
    depthTestOn: boolean;
    depthTestComp: wgfx.EnumCompareFunc;
    stencilWriteMask: number;
    stencilTestOn: boolean;
    stencilRef: number;
    stencilReadMask: number;
    stencilComp: wgfx.EnumCompareFunc;
    stencilPass: wgfx.EnumStencilOp;
    stencilFail: wgfx.EnumStencilOp;
    stencilZFail: wgfx.EnumStencilOp;
    primitiveType: wgfx.EnumPrimitiveType;
  }
  export const DefaultRenderStates: IPassRenderStates;
  export default class Pass {
    get lightMode(): PipelineTypeString;
    /**
     * 该pass是否使用Material上指定的RenderStates
     *
     * @readonly
     * @type {boolean}
     * @memberof Pass
     */
    get useMaterialRenderStates(): boolean;
    constructor(config: EffectAsset["passes"][0], effect: Effect);
    /**
     * 预编译
     *
     * @param {EnumRendererType} typeKey
     * @returns {boolean}
     * @memberof Pass
     */
    warmUp(typeKey: EnumRendererType): boolean;
  }
}
declare module "engine/materials/fallbackPass" {
  import { Nullable } from "engine/type";
  import Pass from "engine/materials/pass";
  export default class FallbackPassFactory {
    static getPass(lightMode: string): Nullable<Pass>;
  }
}
declare module "engine/assets/classes/effect" {
  import { EnumRendererType } from "engine/materials/buildinShaderDesc";
  import Pass from "engine/materials/pass";
  import { Nullable } from "engine/type";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { EffectAsset } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  export default class Effect extends BaseResource {
    readonly description: EffectAsset;
    static RendererType: Readonly<typeof EnumRendererType>;
    /**
     * 特效名称。
     * @readonly
     * @type {string}
     * @memberof Effect
     */
    get name(): string;
    /**
     * 根据特效配置生成特效资源。
     * @param {EffectAsset} description 特效配置。
     * @memberof Effect
     */
    constructor(description: EffectAsset);
    /**
     * 特效资源的反序列化方法。
     * @static
     * @param {EffectAsset} resourceDescription 特效配置。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {Effect}
     * @memberof Effect
     */
    static DeserializeResource(resourceDescription: EffectAsset, loadContext: BaseLoadContext, dependencies: string[]): Effect;
    /**
     * 获取指定lightMode的第一个pass。
     * @param {string} lightMode 光照模式。
     * @returns {{Pass | null}}
     * @memberof Effect
     */
    getPassByLightMode(lightMode: string): Nullable<Pass>;
    /**
     * 获取指定lightMode的所有pass。
     * @param {string} lightMode 光照模式。
     * @returns {Pass[]}
     * @memberof Effect
     */
    getPassesByLightMode(lightMode: string): Pass[];
    /**
     * 预编译
     * @param {EnumRendererType} typeKey 渲染类型
     * @returns {boolean}
     * @memberof Effect
     */
    warmUp(typeKey?: EnumRendererType): boolean;
  }
}
declare module "engine/assets/load-contexts/load-context" {
  /**
   * 代表一个资源组下载过程的类
   */
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import LitePromise from "lib/utils/promise";
  import { DownloadSession, DownloadSessionStatus } from "engine/assets/lib/priority-download/session";
  import LoadTask from "engine/assets/load-task";
  import { ContextAction, ContextStatus } from "engine/assets/load-contexts/status/enum";
  import WeakAsset from "engine/assets/load-contexts/weak-asset";
  import { ComplexJSONMap } from "engine/assets/lib/util";
  import { EngineError } from "engine/error";
  interface CacheResult {
    startTime: number;
    stopTime: number;
    succeeded: boolean;
    alreadyExisted: boolean;
  }
  interface FileData {
    filetype: string;
    wxFilePath: string;
    filecontent: any;
    size: number;
    sessions?: DownloadSession[];
    hitCache: boolean;
    cacheResult?: CacheResult;
  }
  interface LoadTarget {
    url: string;
    version?: string;
    protocol?: string;
    pathname?: string;
    size: number;
  }
  export interface LoadContextInspect {
    status: ContextStatus;
    action: ContextAction;
    history: {
      time: number[];
      action: ContextAction[];
      status: ContextStatus[];
    };
    files: {
      [filepath: string]: {
        exist: boolean;
        sessions: DownloadSessionStatus[];
        cacheResult: CacheResult;
      };
    };
    assets: {
      [assetkey: string]: {
        exist: boolean;
        weak: "strong" | "weak";
      };
    };
    error: string;
  }
  export interface LoadTargetGroup extends LoadTarget {
    groupid: string;
    type: "group";
  }
  /**
   * 负责管理一个组或者一个文件的下载过程
   *
   * @export
   * @class LoadContext
   */
  export const groupManifests: ComplexJSONMap<IGroupManifest>;
  export default class LoadContext extends BaseLoadContext {
    get hitCache(): boolean;
    get progress(): {
      total: number;
      current: number;
    };
    get loaded(): boolean;
    get error(): Error | null;
    get groupManifest(): IGroupManifest | null;
    set groupManifest(groupManifest: IGroupManifest | null);
    cacheable: boolean;
    cachingPromise: LitePromise<void[]> | null;
    hashKey: string;
    files: {
      [relativePath: string]: FileData;
    };
    /**
     * 获取组内资源
     *
     * 当前的assetCache策略：首次get的时候会从文件中deserialize出资源，并且返回
     * 然后，包在一个WeakRef里存着。这个WeakRef不会对资源实例产生引用计数
     *
     * @param resourceID 资源id
     */
    isPackage: boolean;
    constructor(target: LoadTargetGroup);
    getKey(): string;
    inspect(): LoadContextInspect;
    getResourceDefinitions(): LitePromise<void>;
    get resourceDefinitions(): IResourceDefinitions | null;
    /**
     * 获取组内文件
     * @param fileDescriptionID 文件描述符id
     */
    getFile(fileDescriptionID: string): any;
    getAsset(assetID: string): any;
    registerTask(task: LoadTask<any>): void;
    unregisterTask(task: LoadTask<any>): void;
  }
  export {};
}
declare module "engine/debug/load-inspector" {
  import LoadTask from "engine/assets/load-task";
  export default class LoadInspector {
    /**
     * 记录开关。根据这个开关来记信息
     */
    static get recording(): boolean;
    static set recording(value: boolean);
    static onRecordingEnd(callback: (...args: any[]) => any): void;
    static startRecordTask(task: LoadTask<any>): void;
    static stopRecordTask(task: LoadTask<any>): void;
    static startRecordDownload(key: string, task: engineWX.DownloadTask): void;
    static stopRecordDownload(key: string, task: engineWX.DownloadTask): void;
    static getLoaderProfile(extend: any): string;
  }
}
declare module "engine/assets/load-task" {
  import LitePromise from "lib/utils/promise";
  import { ILoaderOptions } from "engine/assets/lib/util";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export interface LoadTaskInspect {
    assetID: string;
    httpPriority: number;
    progress: {
      current: number;
      total: number;
    };
    startTime: number;
    endTime: number;
    contexts: string[];
    pendingContexts: string[];
  }
  export default class LoadTask<T> {
    get progress(): {
      current: number;
      total: number;
    };
    type: "preload" | "load";
    httpRetryCount: number;
    httpPriority: number;
    /**
     * 加载过程的promise，最终会resolve加载结果
     * 如果有依赖失败，只要主资源加载下来了，它也是resolve的
     *
     * @memberof LoadTask
     */
    promise: LitePromise<T>;
    historyKey: string;
    readonly assetID: string;
    constructor(assetID: string, options: ILoaderOptions);
    addMainContext(context: BaseLoadContext): void;
    addContext(context: BaseLoadContext): void;
    /**
     * 取消这个加载任务
     *
     * @memberof LoadTask
     */
    abort(): void;
    fail(error: Error): void;
    startCheckLoaded(): void;
    inspect(): LoadTaskInspect;
  }
}
declare module "engine/assets/load-contexts/load-context-definition" {
  import { LoggerInstance } from "engine/debug/logger";
  import LitePromise from "lib/utils/promise";
  import LoadTask from "engine/assets/load-task";
  export abstract class BaseLoadContext {
    get progress(): {
      total: number;
      current: number;
    };
    readonly loadPromise: LitePromise<void>;
    get loaded(): boolean;
    get error(): Error | null;
    abstract get resourceDefinitions(): IResourceDefinitions | null;
    logger: LoggerInstance;
    abstract getKey(): string;
    abstract getResourceDefinitions(): LitePromise<void>;
    abstract getFile<T>(fileDescriptionID: string): T;
    abstract getAsset(resourceID: string): any;
    abstract registerTask(task: LoadTask<any>): any;
    abstract unregisterTask(task: LoadTask<any>): any;
  }
}
declare module "engine/assets/classes/scene" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { SceneResourceDescription } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  /**
   * 场景资源。
   * @export
   * @class Scene
   * @extends {BaseResource}
   */
  export default class Scene extends BaseResource {
    readonly description: SceneResourceDescription;
    /**
     * 场景资源反序列化逻辑。
     * @static
     * @param {SceneResourceDescription} resourceDescription
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {Scene}
     * @memberof Scene
     */
    static DeserializeResource(resourceDescription: SceneResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): Scene;
    get meta(): SceneResourceDescription["meta"];
    get data(): SceneResourceDescription;
    uuidToBufferMap: {
      [uuid: string]: ArrayBuffer;
    };
    scriptDeps: string[];
    /**
     * 从资源配置中实例化场景资源。
     * @param {SceneResourceDescription} description
     * @memberof Scene
     */
    constructor(description: SceneResourceDescription);
  }
}
declare module "engine/assets/classes/raw" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { RawResourceDescription } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  /**
   * 原始资源。
   * @export
   * @class RawResource
   * @extends {BaseResource}
   */
  export default class RawResource extends BaseResource {
    value: any;
    /**
     * 从文件内容初始化原始资源。
     * @param {*} value
     * @memberof RawResource
     */
    constructor(value: any);
    /**
     * 原始资源反序列化函数。
     * @static
     * @param {RawResourceDescription} resourceDescription 资源配置。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {RawResource}
     * @memberof RawResource
     */
    static DeserializeResource(resourceDescription: RawResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): RawResource;
  }
}
declare module "engine/scene/scene" {
  import { default as SceneResource } from "engine/assets/classes/scene";
  import { AmbientMode, FogMode, PrefabResourceDescription, UIAdaptationType } from "engine/assets/resource";
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import Transform3D from "engine/game/transform3D";
  import Color from "engine/math/color";
  import Vector2 from "engine/math/vector2";
  import Vector3 from "engine/math/vector3";
  import { SmartArray } from "engine/misc/array";
  import { Immutable, Nullable } from "engine/type";
  import Entity from "engine/scene/entity";
  import Texture2D from "engine/assets/classes/texture2D";
  export interface LightMapData {
    color: Texture2D;
    shadowMask?: Texture2D;
  }
  type Material = import("engine/assets/classes/material").default;
  type Game = import("engine/game/game").default;
  type DirectionalLight = import("engine/game/3D/directionalLight").default;
  export type Entity3D = Entity & {
    transform: Transform3D;
  };
  export type Entity2D = Entity & {
    transform2D: Transform2D;
  };
  /**
   * Prefab和Scene的反序列化过程。
   * 分两步：_BuildTree和_InitializeComponents，分别为：创建entity和component、初始化component的各个属性。
   * 这个类只对外暴露静态方法：Instantiate。
   */
  export class Instantiator {
    static Instantiate(
      game: Game,
      prefabJSON: PrefabResourceDescription,
      uuidToBufferMap: {
        [uuid: string]: ArrayBuffer;
      },
    ): Entity;
  }
  export class Scene3D {
    readonly settings: Scene3DSettings;
    readonly root: Entity3D;
    readonly name: string;
    readonly game: Game;
    constructor(game: Game, scene?: SceneResource);
    dispose(): void;
  }
  class Scene3DSettings {
    readonly scene: Scene3D;
    readonly directionalLights: DirectionalLight[];
    get fogMode(): FogMode;
    set fogMode(fogMode: FogMode);
    get fogColor(): Vector3;
    set fogColor(val: Vector3);
    get fogStart(): number;
    set fogStart(val: number);
    get fogRange(): number;
    set fogRange(val: number);
    get fogDensity(): number;
    set fogDensity(fogDensity: number);
    get ambientMode(): AmbientMode;
    set ambientMode(ambientMode: AmbientMode);
    get ambientLight(): Vector3;
    set ambientLight(val: Vector3);
    get ambientIntensity(): number;
    set ambientIntensity(ambientIntensity: number);
    get ambientSkyColor(): Color;
    set ambientSkyColor(ambientSkyColor: Color);
    get ambientEquatorColor(): Color;
    set ambientEquatorColor(ambientEquatorColor: Color);
    get ambientGroundColor(): Color;
    set ambientGroundColor(ambientGroundColor: Color);
    get skyBox(): Nullable<Material>;
    set skyBox(skyBox: Nullable<Material>);
    lightMaps: LightMapData[];
    lightMapType: number;
    subtractiveShadowColor: Color;
    constructor(scene: Scene3D, sceneResource: SceneResource);
  }
  export class Scene2D {
    readonly settings: Scene2DSettings;
    readonly root: Entity2D;
    readonly name: string;
    readonly game: Game;
    constructor(game: Game, scene?: SceneResource);
    get width(): number;
    get height(): number;
    dispose(): void;
  }
  class Scene2DSettings {
    readonly scene: Scene2D;
    get designWidth(): number;
    set designWidth(designWidth: number);
    get designHeight(): number;
    set designHeight(designHeight: number);
    get adaptationType(): UIAdaptationType;
    set adaptationType(adaptationType: UIAdaptationType);
    constructor(scene: Scene2D, sceneResource: SceneResource);
  }
  export const EmptyScene3DResource: SceneResource;
  export const EmptyScene2DResource: SceneResource;
  export {};
}
declare module "engine/game/transform2D" {
  import Rect from "engine/math/rect";
  import Vector2 from "engine/math/vector2";
  import { Entity2D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import TransformBase from "engine/game/transformBase";
  import { M4ReadOnly, M3ReadOnly, V2ReadOnly } from "engine/math/types";
  export default class Transform2D extends TransformBase {
    readonly entity: Entity2D;
    /**
     * local位移
     *
     * @type {Vector2}
     * @memberof Transform2D
     */
    get position(): Vector2;
    set position(val: Vector2);
    /**
     * local位移x分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get positionX(): number;
    set positionX(val: number);
    /**
     * local位移y分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get positionY(): number;
    set positionY(val: number);
    /**
     * local旋转
     *
     * @type {number}
     * @memberof Transform2D
     */
    get rotation(): number;
    set rotation(val: number);
    /**
     * local缩放
     *
     * @type {Vector2}
     * @memberof Transform2D
     */
    get scale(): Vector2;
    set scale(val: Vector2);
    /**
     * local缩放x分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get scaleX(): number;
    set scaleX(val: number);
    /**
     * local缩放y分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get scaleY(): number;
    set scaleY(val: number);
    /**
     * local尺寸
     *
     * @type {Vector2}
     * @memberof Transform2D
     */
    get size(): Vector2;
    set size(val: Vector2);
    /**
     * local尺寸x分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get sizeX(): number;
    set sizeX(val: number);
    /**
     * local尺寸y分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get sizeY(): number;
    set sizeY(val: number);
    /**
     * local锚点
     *
     * @type {Vector2}
     * @memberof Transform2D
     */
    get anchor(): Vector2;
    set anchor(val: Vector2);
    /**
     * 本地锚点x分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get anchorX(): number;
    set anchorX(val: number);
    /**
     * 本地锚点y分量
     *
     * @type {number}
     * @memberof Transform2D
     */
    get anchorY(): number;
    set anchorY(val: number);
    /**
     * 4x4的世界RTS矩阵，为了对齐3D，只读
     *
     * @readonly
     * @type {M4ReadOnly}
     * @memberof Transform2D
     */
    get worldMatrix(): M4ReadOnly;
    /**
     * 3x3世界RTS矩阵，只读
     *
     * @readonly
     * @type {M3ReadOnly}
     * @memberof Transform2D
     */
    get worldMatrix3(): M3ReadOnly;
    /**
     * 本地RTS矩阵，只读
     *
     * @readonly
     * @type {M3ReadOnly}
     * @memberof Transform2D
     */
    get localMatrix3(): M3ReadOnly;
    /**
     * 世界位移，只读
     *
     * @readonly
     * @type {V2ReadOnly}
     * @memberof Transform2D
     */
    get worldPosition(): V2ReadOnly;
    /**
     * 世界位移x分量，只读
     *
     * @readonly
     * @type {number}
     * @memberof Transform2D
     */
    get worldPositionX(): number;
    /**
     * 世界位移y分量，只读
     *
     * @readonly
     * @type {number}
     * @memberof Transform2D
     */
    get worldPositionY(): number;
    /**
     * 世界缩放，只读
     *
     * @readonly
     * @type {V2ReadOnly}
     * @memberof Transform2D
     */
    get worldScale(): V2ReadOnly;
    /**
     * 请使用engine.game.createEntity2D(name)创建2D对象
     *
     * @param {Entity2D} entity
     * @param {Float32Array} [_raw]
     * @param {number} [_offset]
     * @memberof Transform2D
     */
    constructor(entity: Entity2D, raw?: Float32Array, offset?: number);
    /**
     * 添加子节点，若子节点已存在父节点，则会先移除其父节点
     * 子节点必须是Transform2D
     *
     * @param {Transform2D} child
     * @returns {boolean} 是否添加成功
     * @memberof Transform2D
     */
    addChild(child: Transform2D): boolean;
    /**
     * 添加子节点到指定index，若子节点已存在父节点，则会先移除其父节点
     * 子节点必须是Transform2D
     *
     * @param {Transform2D} child 子节点
     * @param {number} index index顺序
     * @returns {boolean} 添加是否成功
     * @memberof Transform2D
     */
    addChildAtIndex(child: Transform2D, index: number): boolean;
    /**
     * 删除指定子节点
     *
     * @param {Transform2D} child 要删除的子节点
     * @returns {boolean} 是否删除成功
     * @memberof Transform2D
     */
    removeChild(child: Transform2D): boolean;
    /**
     * 将世界坐标转换为本地坐标系坐标
     *
     * @param {V2ReadOnly} worldPosition 世界坐标
     * @param {Vector2} [dst] 是否将计算结果输出到Dst
     * @returns {Vector2} 本地坐标系坐标
     * @memberof Transform2D
     */
    convertWorldPositionToLocal(worldPosition: V2ReadOnly, dst?: Vector2): Vector2;
    /**
     * 测试该节点世界包围盒是否包含某个点
     *
     * @param {V2ReadOnly} worldPosition 测试点的世界坐标
     * @param {Nullable<Rect>} [hitArea] 如果传了该参数，则使用该区域作为本地包围盒
     * @param {Vector2} [dstLocal] 如果传了该参数，则将返回测试点在本地坐标系下的坐标
     * @returns {boolean} 是否包含
     * @memberof Transform2D
     */
    hitTest(worldPosition: V2ReadOnly, hitArea?: Nullable<Rect>, dstLocal?: Vector2): boolean;
  }
}
declare module "engine/scene/entity" {
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import Transform3D from "engine/game/transform3D";
  import { Nullable } from "engine/type";
  import { Entity2D, Entity3D } from "engine/scene/scene";
  import Game from "engine/game/game";
  import Renderable2D from "engine/game/2D/renderable2D";
  /**
   * 场景节点类。
   * @export
   * @class Entity
   */
  export default class Entity {
    /**
     * 3D变换信息，2D节点该属性为空。
     * @type {Transform3D}
     * @memberof Entity
     */
    transform?: Transform3D;
    /**
     * 2D变换信息，3D节点该属性为空。
     * @type {Transform2D}
     * @memberof Entity
     */
    transform2D?: Transform2D;
    /**
     * 节点的名字
     * @type {string}
     * @memberof Entity
     */
    name: string;
    /**
     * 节点是否已经被销毁。
     * @type {boolean}
     * @memberof Entity
     */
    readonly isDestroyed: boolean;
    /**
     * 节点场景所在的游戏运行实例，当节点被销毁后该属性会置位null。
     * @type {Game}
     * @memberof Entity
     */
    game: Game;
    /**
     * 节点是否处于激活状态。
     * @type {boolean}
     * @memberof Entity
     */
    get active(): boolean;
    set active(val: boolean);
    /**
     * 节点在层级结构中是否处于激活状态。
     * @readonly
     * @type {boolean}
     * @memberof Entity
     */
    get activeInHierarchy(): boolean;
    /**
     * 创建一个节点。
     * @param {Game} game 所依附的游戏运行实例。
     * @param {string} [name="NewEntity"]
     * @memberof Entity
     */
    constructor(game: Game, name?: string);
    /**
     * 创建3D节点。
     * @deprecated
     * @static
     * @param {string} name
     * @returns {Entity3D}
     * @memberof Entity
     */
    static createEntity3D(name: string): Entity3D;
    /**
     * 创建2D节点。
     * @deprecated
     * @static
     * @param {string} name
     * @returns {Entity2D}
     * @memberof Entity
     */
    static createEntity2D(name: string): Entity2D;
    /**
     * 获取某一类型的组件。
     * @template T
     * @param {typeof Component} ctor
     * @returns {Nullable<T>}
     * @memberof Entity
     */
    getComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
    /**
     * 获取某一类型的组件列表。
     * @template T
     * @param {typeof Component} ctor
     * @returns {T[]}
     * @memberof Entity
     */
    getComponents<T extends Component>(ctor: typeof Component): T[];
    /**
     * 获取所有组件列表。
     * @readonly
     * @type {Component[]}
     * @memberof Entity
     */
    get components(): Component[];
    /**
     * 获取所有组件列表。
     * @deprecated
     * @returns {Component[]}
     * @memberof Entity
     */
    getAllComponents(): Component[];
    /**
     * 添加组件。
     * @template T
     * @param {typeof Component} ctor
     * @returns {(T | never)}
     * @memberof Entity
     */
    addComponent<T extends Component>(ctor: typeof Component): T | never;
    /**
     * 移除组件。
     * @param {Component} comp
     * @returns {void}
     * @memberof Entity
     */
    removeComponent(comp: Component): void;
    /**
     * 销毁节点。
     * @returns {void}
     * @memberof Entity
     */
    destroy(): void;
    /**
     * 立即销毁节点。
     * @returns {void}
     * @memberof Entity
     */
    destroyImmediate(): void;
  }
  export const InvalidEntity: Entity;
}
declare module "engine/game/component" {
  import Entity from "engine/scene/entity";
  interface Component {}
  class Component {
    get active(): boolean;
    set active(value: boolean);
    /**
     * 在场景树中是否active
     *
     * @readonly
     * @type {boolean}
     * @memberof Component
     */
    get activeInHierarchy(): boolean;
    static Serialize?: (...args: any[]) => any;
    static Priority: {
      Default: number;
      High: number;
      Low: number;
      Render: number;
      Align: number;
      Layout: number;
      Tool: number;
    };
    readonly priority: number;
    readonly isDestroyed: boolean;
    readonly isDestroying: boolean;
    readonly id: number;
    readonly entity: Entity;
    constructor(entity: Entity);
    getTypeName(): string;
    destroy(): void;
    resetProperties(): void;
  }
  export default Component;
}
declare module "engine/assets/deserialize/decorators" {
  import Component from "engine/game/component";
  import Entity from "engine/scene/entity";
  import { Nullable } from "engine/type";
  import BaseResource from "engine/assets/classes/baseResource";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export const TypeNames: {
    Object: string;
    String: string;
    Boolean: string;
    Number: string;
    AnimationClip: string;
    AnimatorController: string;
    Avatar: string;
    BitmapFont: string;
    Effect: string;
    Font: string;
    Material: string;
    Mesh: string;
    Prefab: string;
    Scene: string;
    SpriteFrame: string;
    Texture2D: string;
    TextureCube: string;
    Variant: string;
    Raw: string;
    Renderable2D: string;
    UIAnchor: string;
    UIButton: string;
    UICanvas: string;
    UIFrameAnimation: string;
    UIGraphic: string;
    UIGrid: string;
    UILabel: string;
    UIMask: string;
    UIRichText: string;
    UIScrollView: string;
    UISprite: string;
    UITextInput: string;
    UIToggle: string;
    UIToggleGroup: string;
    UIWidget: string;
    UILayer: string;
    KeyboardInput: string;
    TouchInput: string;
    Animator: string;
    Animation: string;
    Camera: string;
    Component: string;
    DirectionalLight: string;
    LineRenderer: string;
    MeshRenderer: string;
    SkinnedMeshRenderer: string;
    TrailRenderer: string;
    Particle: string;
    PostProcess: string;
    RawResourceCollection: string;
    Transform2D: string;
    Transform3D: string;
    TransformBase: string;
    Color: string;
    Quaternion: string;
    Rect: string;
    Vector2: string;
    Vector3: string;
    Vector4: string;
    Entity: string;
    GradientColor: string;
    HermiteCurve: string;
    ParticleEmitterBurst: string;
    ParticleBoxShape: string;
    ParticleConeShape: string;
    ParticleHemiSphereShape: string;
    ParticleSphereShape: string;
    ParticleCircleShape: string;
    ParticleCommon: string;
    ParticleEmitter: string;
    ParticleRenderer: string;
    ParticleEmitterShape: string;
    ParticleRotationByLife: string;
    ParticleSizeByLife: string;
    ParticleSpeedByLife: string;
    ParticleSpeedLimitByLife: string;
    ParticleColorByLife: string;
    ParticleTextureSheetAnimation: string;
    RuntimeAnimatorBlendTree: string;
    RuntimeAnimatorCondition: string;
    RuntimeAnimatorStateTransition: string;
    RuntimeAnimatorState: string;
    RuntimeAnimatorStateMachine: string;
    RuntimeAnimatorControllerParameter: string;
    RuntimeAnimationLayer: string;
    RuntimeAnimatorController: string;
    Constant: string;
    Curve: string;
    TwoConstants: string;
    TwoCurves: string;
    OneColor: string;
    Gradient: string;
    TwoColors: string;
    TwoGradients: string;
    BoundBall: string;
    BoundBox: string;
  };
  export interface IComponentCtor<T extends Component> {
    readonly prototype: any;
    Deserialize?: (data: object, result: T, context: any, builtContext: any) => Nullable<T>;
    new (entity: Entity): T;
  }
  export interface IInternalCtor<T> {
    readonly prototype: any;
    Deserialize?: (data: object, result: T, context: any, builtContext: any) => Nullable<T>;
    new (...args: any[]): T;
  }
  export interface IResourceCtor {
    readonly prototype: any;
    DeserializeResource: (resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[]) => BaseResource;
    new (...args: any[]): BaseResource;
  }
  export type SerializableCtor = IComponentCtor<any> | IInternalCtor<any> | IResourceCtor;
  export const ReflectionTable: {
    [key: string]: SerializableCtor;
  };
  export const PROPERTY_KEY: string;
  export const PROPERTY_ARRAY_KEY: string;
  export const TYPE_NAME_KEY: string;
  export const VALUE_TYPE_FLAG_KEY: string;
  export const CONTEXT_KEY: string;
  export class MultiType {
    constructor(info: { [key: string]: TypeInfo });
  }
  export class EnumType {
    constructor(info: any);
  }
  type ValueOf<T> = T[keyof T];
  export type TypeInfo = ValueOf<typeof TypeNames> | [ValueOf<typeof TypeNames>];
  export interface IPropertyBaseConfig {
    deserialize?: boolean;
    serialize?: boolean;
    required?: boolean;
    default?: any;
    visible?: boolean;
    tooltips?: string;
    readonly?: boolean;
  }
  export interface IPropertyConfig extends IPropertyBaseConfig {
    type: TypeInfo | MultiType | EnumType;
    inspectorType?: string;
  }
  export interface IPropertyMultiConfig extends IPropertyBaseConfig {
    type: {
      [key: string]: TypeInfo;
    };
  }
  export interface IPropertyEnumConfig extends IPropertyBaseConfig {
    type: {
      [key: string]: string | number;
    };
  }
  export const decorators: {
    context: (aliasTable: { [key: string]: string }) => (classCtor: SerializableCtor) => void;
    serialize: (typeName: string, isValueType?: boolean) => ClassDecorator;
    property: {
      (config: IPropertyConfig): PropertyDecorator & ParameterDecorator;
      multi(config: IPropertyMultiConfig): PropertyDecorator & ParameterDecorator;
      enum(config: IPropertyEnumConfig): PropertyDecorator & ParameterDecorator;
      array(
        index: number,
        config: IPropertyConfig & {
          type: string;
        },
      ): PropertyDecorator & ParameterDecorator;
    };
  };
  export {};
}
declare module "engine/math/curve" {
  import { DeepImmutable, Nullable } from "engine/type";
  export interface IKeyFrame {
    index: number;
    inTangent: number;
    outTangent: number;
    value: number;
  }
  export enum CurveMode {
    Hermite = 0,
  }
  export class Curve {
    readonly keyFrames: IKeyFrame[];
    fps: number;
    frameCount: number;
    mode: CurveMode;
    readonly precision: number;
    constructor(keyFrames: IKeyFrame[], fps: number, frameCount: number, mode?: CurveMode, precision?: number);
    evaluate(index: number, blendForLoop?: boolean): Nullable<number>;
    get keyCount(): number;
    addKeyFraem(keyFrame: IKeyFrame): void;
  }
  export interface ITransformCurveEvaluateValue {
    tx: Nullable<number>;
    ty: Nullable<number>;
    tz: Nullable<number>;
    sx: Nullable<number>;
    sy: Nullable<number>;
    sz: Nullable<number>;
    rx: Nullable<number>;
    ry: Nullable<number>;
    rz: Nullable<number>;
    rw: Nullable<number>;
  }
  export enum TransformCurveType {
    TranslateX = 1,
    TranslateY = 2,
    TranslateZ = 3,
    ScaleX = 4,
    ScaleY = 5,
    ScaleZ = 6,
    QuaternionX = 7,
    QuaternionY = 8,
    QuaternionZ = 9,
    QuaternionW = 10,
    EulerX = 11,
    EulerY = 12,
    EulerZ = 13,
  }
  export enum TransformCurveRotationMode {
    None = 0,
    Euler = 1,
    Quaternion = 2,
  }
  export class TransformCurve {
    readonly fps: number;
    frameLength: number;
    mode: CurveMode;
    readonly precision: number;
    static TransformCurveRotationMode: typeof TransformCurveRotationMode;
    static TransformCurveType: typeof TransformCurveType;
    get rotationMode(): TransformCurveRotationMode;
    constructor(fps: number, frameLength: number, mode?: CurveMode, precision?: number);
    addKeyFrame(value: IKeyFrame, type: TransformCurveType): void;
    evaluate(frameIndex: number): DeepImmutable<ITransformCurveEvaluateValue>;
  }
}
declare module "engine/game/3D/animator/meta" {
  import { Curve } from "engine/math/curve";
  import { Nullable } from "engine/type";
  import Transform3D from "engine/game/transform3D";
  import Entity from "engine/scene/entity";
  import AnimationClip from "engine/assets/classes/animationClip";
  export class MetaAnimationModel {
    get curveCount(): number;
    constructor(ab: ArrayBuffer, frameLength: number, fps: number);
    evaluate(frameIndex: number): Array<Nullable<number>>;
  }
  export type PropertySyncFunction = (node: Transform3D, value: number) => void;
  export class MetaAnimationComponent {
    get animationClipCount(): number;
    bindInfo: Array<{
      clip: AnimationClip;
      nodes: Array<Nullable<Transform3D>>;
      frameIndex: number;
      blendWeight: number;
    }>;
    syncFunctions: {
      [key: string]: PropertySyncFunction;
    };
    constructor(entity: Entity);
    bindMetaAnimations(clips: AnimationClip[], nodeMatrices: Array<Array<Nullable<Transform3D>>>): void;
    setClipParams(index: number, frameIndex: number, blendWeight: number): void;
  }
}
declare module "engine/assets/classes/animationClip" {
  import { MetaAnimationModel } from "engine/game/3D/animator/meta";
  import { Nullable } from "engine/type";
  import { AnimationClipResourceConfig, WrapMode } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  /**
   * 动画片段资源。
   * @export
   * @class AnimationClip
   * @extends {BaseResource}
   */
  export default class AnimationClip extends BaseResource {
    /**
     * 动画片段的关键帧数。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get frameLength(): number;
    /**
     * 动画片段的帧率。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get frameRate(): number;
    /**
     * 动画片段的时长，单位秒。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get length(): number;
    /**
     * 动画片段所控制的节点路径。
     * @readonly
     * @type {string[]}
     * @memberof AnimationClip
     */
    get paths(): string[];
    /**
     * 动画片段所控制的节点路径（索引号）以及控制的属性字段。
     * @readonly
     * @type {Array<[number, string]>}
     * @memberof AnimationClip
     */
    get props(): Array<[number, string]>;
    /**
     * Genetic动画的播放模式。
     * @readonly
     * @type {WrapMode}
     * @memberof AnimationClip
     */
    get wrapMode(): WrapMode;
    /**
     * Genetic动画的播放起始位置。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get startTime(): number;
    /**
     * Genetic动画的播放终止位置。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get stopTime(): number;
    /**
     * 非Genetic动画的循环设置。
     * @readonly
     * @type {boolean}
     * @memberof AnimationClip
     */
    get loopTime(): boolean;
    /**
     * 非Genetic动画的循环偏移量。
     * @readonly
     * @type {number}
     * @memberof AnimationClip
     */
    get cycleOffset(): number;
  }
}
declare module "engine/assets/classes/prefab" {
  import Entity from "engine/scene/entity";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { PrefabResourceDescription } from "engine/assets/resource";
  import BaseResource from "engine/assets/classes/baseResource";
  import { Never } from "engine/type";
  /**
   * Prefab资源。
   * @export
   * @class Prefab
   * @extends {BaseResource}
   */
  export default class Prefab extends BaseResource {
    readonly description: PrefabResourceDescription;
    /**
     * Prefab资源的反序列化逻辑。
     * @static
     * @param {PrefabResourceDescription} resourceDescription 资源配置。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {Prefab}
     * @memberof Prefab
     */
    static DeserializeResource(resourceDescription: PrefabResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): Prefab;
    /**
     * Prefab资源的额外描述。
     * @readonly
     * @type {PrefabResourceDescription["meta"]}
     * @memberof Prefab
     */
    get meta(): PrefabResourceDescription["meta"];
    get data(): PrefabResourceDescription;
    uuidToBufferMap: {
      [uuid: string]: ArrayBuffer;
    };
    /**
     * 从资源配置中实例化Prefab资源。
     * @param {PrefabResourceDescription} description 资源配置。
     * @memberof Prefab
     */
    constructor(description: PrefabResourceDescription);
    /**
     * 实例化Prefab资源。
     * @returns {(Entity | Never)}
     * @memberof Prefab
     */
    instantiate(): Entity | Never;
  }
}
declare module "engine/assets/classes/textureCube" {
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  import { TextureCubeResourceDescription } from "engine/assets/resource";
  import Texture, { TextureFilterMode, TexturePixelFormat, TextureWrapMode } from "engine/assets/classes/texture";
  export const CUBE_ORDER_TO_FACE: string[];
  /**
   * 立方体贴图资源。
   * @export
   * @class TextureCube
   * @extends {Texture}
   */
  export default class TextureCube extends Texture {
    /**
     * 贴图的填充模式。
     * @type {TextureFilterMode}
     * @memberof TextureCube
     */
    get filterMode(): TextureFilterMode;
    /**
     * 各向异性参数，有效值为1-16。
     * @type {number}
     * @memberof TextureCube
     */
    get anisoLevel(): number;
    /**
     * 像素格式。
     * @readonly
     * @type {TexturePixelFormat}
     * @memberof TextureCube
     */
    get pixelFormat(): TexturePixelFormat;
    /**
     * 横向采样包围模式。
     * @type {TextureWrapMode}
     * @memberof TextureCube
     */
    get wrapU(): TextureWrapMode;
    /**
     * 纵向采样包围模式。
     * @type {TextureWrapMode}
     * @memberof TextureCube
     */
    get wrapV(): TextureWrapMode;
    /**
     * 采样包围模式。
     * @type {TextureWrapMode}
     * @memberof TextureCube
     */
    get wrapW(): TextureWrapMode;
    /**
     * 是否使用mipmap。
     * @type {boolean}
     * @memberof TextureCube
     */
    get useMipmap(): boolean;
    /**
     * 是否使用需要做预乘处理。
     * @type {boolean}
     * @memberof TextureCube
     */
    get needUnpackPremultiplyAlpha(): boolean;
    /**
     * 贴图高。
     * @readonly
     * @type {number}
     * @memberof TextureCube
     */
    get height(): number;
    /**
     * 贴图宽。
     * @readonly
     * @type {number}
     * @memberof TextureCube
     */
    get width(): number;
    /**
     * 是否可动态写入。
     * @readonly
     * @type {boolean}
     * @memberof TextureCube
     */
    get writeable(): boolean;
    /**
     * 贴图额外的信息。
     * @readonly
     * @type {(TextureCubeResourceDescription["desc"] | undefined)}
     * @memberof TextureCube
     */
    get meta(): TextureCubeResourceDescription["desc"] | undefined;
    /**
     * 立方体贴图资源的反序列化方法。
     * @static
     * @param {TextureCubeResourceDescription} resourceDescription 资源配置。
     * @param {BaseLoadContext} loadContext 引擎loader上下文环境。
     * @param {string[]} dependencies 依赖资源id列表。
     * @returns {TextureCube}
     * @memberof TextureCube
     */
    static DeserializeResource(resourceDescription: TextureCubeResourceDescription, loadContext: BaseLoadContext, dependencies: string[]): TextureCube;
    /**
     * 使用一段buffer和一些配置初始化。
     * @param {TexturePixelFormat} pixelFormat
     * @param {ArrayBuffer} bufferSrc
     * @param {number} width
     * @param {number} height
     * @param {number} [mipmapLevel=1]
     * @param {boolean} useMipmap
     * @returns {(Uint8Array[] | void)}
     * @memberof TextureCube
     */
    initWithArrayBuffer(pixelFormat: TexturePixelFormat, bufferSrc: ArrayBuffer, width: number, height: number, mipmapLevel: number | undefined, useMipmap: boolean): Uint8Array[] | void;
  }
}
declare module "engine/assets/buildin-asset/buildin-context" {
  /**
   * 内置资源
   *
   * 添加新的内置资源的步骤：
   * 1. 在buildInGroupFile里加一个文件路径到文件的映射，这相当于提供一系列虚拟文件
   * 2. 如果是effect，要在buildInEffectList里加一个key
   * 3. 在buildInContext类的assets属性里添加一个资源描述，资源描述的id就是外部资源引用内置资源的id
   * 4. 检查buildInContext构造函数的逻辑
   */
  import LitePromise from "lib/utils/promise";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export const buildInGroupDefinition: {
    groupConfig: {
      id: string;
      url: string;
      size: number;
    };
    resources: Array<{
      id: string;
      groupid: string;
    }>;
  };
  const _default: {
    getInstance(): BuildinContext;
    init(): void;
  };
  export default _default;
  class BuildinContext extends BaseLoadContext {
    constructor();
    getKey(): string;
    abort(): void;
    registerTask(): void;
    unregisterTask(): void;
    getResourceDefinitions(): LitePromise<void>;
    get resourceDefinitions(): IResourceDefinitions | null;
    get loaded(): boolean;
    onLoaded(): LitePromise<unknown>;
    getFile(fileID: string): any;
    getAsset(buildinAssetID: string): import("engine/assets/classes/baseResource").default;
  }
}
declare module "engine/assets/loader" {
  import LitePromise from "lib/utils/promise";
  import { ComplexJSONMap } from "engine/assets/lib/util";
  import { ILoaderFileOptions, ILoaderOptions } from "engine/assets/lib/util";
  import LoadTask from "engine/assets/load-task";
  export default class Loader {
    /**
     * 所有组件的所属组id
     *
     * @private
     * @type {{ [id: string]: IAssetInfo }}
     * @memberof Loader
     */
    assets: ComplexJSONMap<string>;
    constructor();
    /**
     *
     * 注册一个组信息，包括它的id和加载url
     * @param {IGroupConfig} info
     * @memberof Loader
     */
    registerGroup(group: IGroupConfig): void;
    /**
     *
     * 传入一个资源数组，注册资源信息，包括它的id以及所属组的id
     * @param {IAssetInfo[]} infos
     * @memberof Loader
     *
     */
    registerAsset(assets: IAssetInfo[]): void;
    registerAssets(assets: IAssetInfo[]): void;
    register(url: string, base: string): LitePromise<void>;
    /**
     *
     * @template T 资源类型
     * @param {string} assetid 资源id
     * @param {ILoaderOptions} [options={}] 加载参数
     * @returns {LoadTask<T>}
     * @memberof Loader
     */
    load<T>(assetID: string, options?: ILoaderOptions): LoadTask<T>;
    /**
     * 同步获取一个资源实例
     *
     * @template T
     * @param {string} assetID 资源ID
     * @param {string} backupAssetID 备份资源ID
     * @returns {T}
     * @memberof Loader
     */
    getAsset<T>(assetID: string, backupAssetID?: string): T;
    /**
     * 加载一个原始文件
     * 暂不支持字体
     *
     * @param {string} url
     * @param {ILoaderFileOptions} options
     * @returns {Promise<any>}
     * @memberof Loader
     */
    loadFile(url: string, options: ILoaderFileOptions): LitePromise<any>;
  }
}
declare module "engine/shared/serialize/classes/baseResource" {
  type BaseResource = import("engine/assets/classes/baseResource").default;
  export function SerializeBaseResource(this: typeof import("engine/assets/classes/baseResource").default, resource: BaseResource, context: any): string | null;
  export {};
}
declare module "engine/shared/executeMode" {
  /**
   * create by janzen
   * 只在editor运行的component,可以用来做辅助开发使用。
   */
  import BaseCamera from "engine/game/baseCamera";
  import Component from "engine/game/component";
  import Entity from "engine/scene/entity";
  export enum EditorExecuteMode {
    Game = "GAME",
    Editor = "EDITOR",
    All = "ALL",
  }
  export function getEnv(): EditorExecuteMode;
  export function executeInEditMode(): ClassDecorator;
  export function executeInGameMode(): ClassDecorator;
  export function hideInHierarchy(): ClassDecorator;
  export function mainScreenCameraInEditorMode(): ClassDecorator;
  export function setMainScreenCameraInEditorMode(cameraComp: BaseCamera, value?: boolean): void;
  export function getMainScreenCameraInEditorMode(cameraComp: BaseCamera): any;
  export function findEntityExecuteMode(entity: Entity): EditorExecuteMode;
  export function findExecuteMode(comp: Component): EditorExecuteMode;
  export function entityShowInHierarchy(entity: Entity): boolean;
  /**
   * 根据comp的属性来判断是否应该在当前环境运行
   */
  export function shouldComponentModeActivate(comp: Component): boolean;
}
declare module "engine/shared/serialize/shared" {
  import { ISerializedObject } from "engine/assets/deserialize/deserialize";
  export function Serialize(
    this: void,
    target: any,
    context?: {
      [key: string]: any;
    },
  ): ISerializedObject | ISerializedObject["data"];
}
declare module "engine/shared/serialize/classes/entity" {
  type Entity = import("engine/scene/entity").default;
  export function SerializeEntity(this: typeof import("engine/scene/entity").default, entity: Entity, context: any): object;
  export {};
}
declare module "engine/shared/serialize/classes/gradientColor" {
  type GradientColor = import("engine/game/particles/libs/gradientColor").default;
  type ISerializeData = import("engine/game/particles/libs/gradientColor").ISerializeData;
  export function SerializeGradientColor(
    target: GradientColor,
    context?: {
      [key: string]: any;
    },
  ): ISerializeData;
  export {};
}
declare module "engine/shared/serialize/classes/hermiteCurve" {
  type HermiteCurve = import("engine/game/particles/libs/hermiteCurve").default;
  type ISerializeData = import("engine/game/particles/libs/hermiteCurve").ISerializeData;
  export function SerializeHermiteCurve(
    target: HermiteCurve,
    context?: {
      [key: string]: any;
    },
  ): ISerializeData;
  export {};
}
declare module "engine/shared/serialize/classes/transform3D" {
  type Transform3D = import("engine/game/transform3D").default;
  export function SerializeTransform3D(
    this: typeof import("engine/game/transform3D").default,
    comp: Transform3D,
    context: any,
  ): {
    position: any;
    scale: any;
    rotation: undefined;
  };
  export {};
}
declare module "engine/shared/serialize/resources/effect" {
  type Effect = import("engine/assets/classes/effect").default;
  export function SerializeEffect(
    this: Effect,
    context: any,
  ): {
    content?: object;
    meta?: object;
  };
  export {};
}
declare module "engine/shared/serialize/resources/material" {
  type Material = import("engine/assets/classes/material").default;
  export function SerializeMaterial(
    this: Material,
    context: any,
  ): {
    content?: object;
    meta?: object;
  };
  export {};
}
declare module "engine/shared/serialize/resources/mesh" {
  type Mesh = import("engine/assets/classes/mesh").default;
  export function SerializeMesh(
    this: Mesh,
    context: any,
  ): {
    content?: object;
    meta?: object;
  };
  export {};
}
declare module "engine/shared/serialize/resources/spriteframe" {
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  export function SerializeSpriteframe(
    this: SpriteFrame,
    context: any,
  ): {
    content?: object;
    meta?: object;
  };
}
declare module "engine/shared/serialize/resources/texture2d" {
  type Texture2D = import("engine/assets/classes/texture2D").default;
  export function SerializeTexture2D(
    this: Texture2D,
    context: any,
  ): {
    content?: object;
    meta?: object;
  };
  export {};
}
declare module "engine/shared/serialize/resources/animatorController" {
  import AnimatorController from "engine/assets/classes/animatorController";
  import { AnimatorController as RuntimeAnimatorController } from "engine/game/3D/animator/classes";
  export function SerializeAnimatorController(
    this: AnimatorController,
    instance: RuntimeAnimatorController,
  ): {
    content?: object;
    meta?: object;
  };
}
declare module "engine/shared/serialize/classes/meshRenderer" {
  type MeshRenderer = import("engine/game/3D/meshRenderer").default;
  export function OnSerializedMeshRenderer(this: MeshRenderer, compJson: any): void;
  export {};
}
declare module "engine/shared/serialize/classes/animator" {
  type Animator = import("engine/game/3D/animator").default;
  export function OnSerializedAnimator(this: Animator, compJson: any): void;
  export {};
}
declare module "engine/shared/serialize" {
  export default function installSerializationMethods(): void;
}
declare module "engine/game/2D/UIAnchor" {
  import Vector2 from "engine/math/vector2";
  import { Entity2D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import { BoundsChangeEventType } from "engine/event";
  export enum Side {
    BottomLeft = "BottomLeft",
    Left = "Left",
    TopLeft = "TopLeft",
    Top = "Top",
    TopRight = "TopRight",
    Right = "Right",
    BottomRight = "BottomRight",
    Bottom = "Bottom",
    Center = "Center",
  }
  enum Execute {
    onEnable = 0,
    onUpdate = 1,
    onAwake = 2,
  }
  /**
   * TODO what if a entity2d is moved to another UI tree from one UI tree.
   */
  export default class UIAnchor extends Component {
    /**
     * 更新运算的时机的枚举值，对应不同的组件生命周期。
     *
     * @static
     * @type {Execute}
     * @memberof UIAnchor
     */
    static Execute: Readonly<typeof Execute>;
    /**
     * UIAnchor对齐方式的枚举类型
     *
     * @static
     * @memberof UIAnchor
     */
    static Side: Readonly<typeof Side>;
    readonly entity: Entity2D;
    readonly priority: number;
    /**
     * Side类型，相对于UICanvas的对齐位置
     *
     * @type {Side}
     * @memberof UIAnchor
     */
    get side(): Side;
    set side(val: Side);
    /**
     * 默认值为0，水平垂直方向的绝对偏移
     *
     * @type {Vector2}
     * @memberof UIAnchor
     */
    get pixelOffset(): Vector2;
    set pixelOffset(val: Vector2);
    /**
     *  默认值Vectotr2.Zero()，相对于组件所在的UICanvas大小，水平垂直方向的相对偏移，每个方向取值范围(0-1)
     *
     * @type {Vector2}
     * @memberof UIAnchor
     */
    get relativeOffset(): Vector2;
    set relativeOffset(val: Vector2);
    /**
     * Execute类型，组件属性或目标关联属性发生变化后，具体进行更新运算的时机。
     *
     * @type {Execute}
     * @memberof UIAnchor
     */
    get execute(): Execute;
    set execute(val: Execute);
    /**
     * 立即重新进行一次UIAnchor的对齐
     *
     * @memberof UIAnchor
     */
    updateUIAnchor(): void;
  }
  export {};
}
declare module "engine/game/2D/UISprite" {
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  import { Nullable } from "engine/type";
  import Renderable2D from "engine/game/2D/renderable2D";
  enum UISpriteType {
    Simple = 0,
    Sliced = 1,
    Filled = 3,
  }
  enum UISpriteFlipType {
    Nothing = 0,
    Horizontally = 1,
    Vertically = 2,
    Both = 3,
  }
  enum UISpriteFillDirectionType {
    Horizontal = 0,
    Vertical = 1,
    Radial90 = 2,
    Radial180 = 3,
    Radial360 = 4,
  }
  /**
   * 图片组件。
   * @export
   * @class UISprite
   * @extends {Renderable2D}
   */
  export default class UISprite extends Renderable2D {
    /**
     * 图片的显示类型。
     * @memberof UISprite
     */
    set type(type: UISpriteType);
    get type(): UISpriteType;
    /**
     * 图片的翻转类型。
     * @memberof UISprite
     */
    set flip(flip: UISpriteFlipType);
    get flip(): UISpriteFlipType;
    /**
     * 图片填充模式下的填充方式。
     * @type {UISpriteFillDirectionType}
     * @memberof UISprite
     */
    get fillDir(): UISpriteFillDirectionType;
    set fillDir(fillDir: UISpriteFillDirectionType);
    /**
     * 图片填充模式下的填充程度，范围0~1。
     * @type {number}
     * @memberof UISprite
     */
    get fillAmount(): number;
    set fillAmount(fillAmount: number);
    /**
     * 图片填充模式下是否反向填充。
     * @type {boolean}
     * @memberof UISprite
     */
    get invertFill(): boolean;
    set invertFill(invertFill: boolean);
    /**
     * 图片资源。
     * @type {Nullable<SpriteFrame>}
     * @memberof UISprite
     */
    get spriteFrame(): Nullable<SpriteFrame>;
    set spriteFrame(val: Nullable<SpriteFrame>);
    /**
     * 是否使用灰阶。
     * @type {boolean}
     * @memberof UISprite
     */
    get grayScale(): boolean;
    set grayScale(val: boolean);
    /**
     * 图片显示类型枚举值。
     * @static
     * @memberof UISprite
     */
    static Type: Readonly<typeof UISpriteType>;
    /**
     * 图片翻转类型枚举值。
     * @static
     * @memberof UISprite
     */
    static FlipType: Readonly<typeof UISpriteFlipType>;
    /**
     * 图片填充方式枚举值。
     * @static
     * @memberof UISprite
     */
    static FillDirectionType: Readonly<typeof UISpriteFillDirectionType>;
  }
  export {};
}
declare module "engine/game/2D/UIButton" {
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  import { TouchInputEvent } from "engine/input/touch";
  import Color from "engine/math/color";
  import { Entity2D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import { Touchable } from "engine/game/2D/input/TouchInputComponent";
  import UISprite from "engine/game/2D/UISprite";
  export enum ButtonState {
    Normal = 0,
    Pressed = 1,
    Disable = 2,
  }
  /**
   * 按钮组件。
   * @export
   * @class UIButton
   * @extends {Touchable}
   */
  export default class UIButton extends Touchable {
    /**
     * 按钮状态类型枚举值
     *
     * @static
     * @type {ButtonState}
     * @memberof UIButton
     */
    static State: typeof ButtonState;
    /**
     * 状态转移动画效果时长。
     * @type {number}
     * @memberof UIButton
     */
    transition: number;
    readonly priority: number;
    /**
     * 当前按钮的状态
     *
     * @type {ButtonState}
     * @memberof UIButton
     */
    set state(state: ButtonState);
    get state(): ButtonState;
    /**
     * 是否将UIButton设置为不可用
     *
     * @type {boolean}
     * @memberof UIButton
     */
    set disable(disable: boolean);
    get disable(): boolean;
    /**
     * disable状态下是否将按钮渲染为灰阶
     *
     * @type {boolean}
     * @memberof UIButton
     */
    set grayScaleOnDisable(grayScaleOnDisable: boolean);
    get grayScaleOnDisable(): boolean;
    /**
     * 普通状态下按钮图像混合的颜色。
     * @type {Color}
     * @memberof UIButton
     */
    set normalColor(color: Color);
    get normalColor(): Color;
    /**
     * 普通状态下按钮的图片。
     * @type {Nullable<SpriteFrame>}
     * @memberof UIButton
     */
    set normalSprite(spriteFrame: Nullable<SpriteFrame>);
    get normalSprite(): Nullable<SpriteFrame>;
    /**
     * 点击状态下按钮的图片。
     * @type {Nullable<SpriteFrame>}
     * @memberof UIButton
     */
    set pressedSprite(pressedSprite: Nullable<SpriteFrame>);
    get pressedSprite(): Nullable<SpriteFrame>;
    /**
     * 点击状态下按钮的图片。
     * @type {Nullable<SpriteFrame>}
     * @memberof UIButton
     */
    set disabledSprite(disabledSprite: Nullable<SpriteFrame>);
    get disabledSprite(): Nullable<SpriteFrame>;
    /**
     * 不可用状态下按钮的图像混合的颜色。
     * @type {Color}
     * @memberof UIButton
     */
    set pressedColor(val: Color);
    get pressedColor(): Color;
    /**
     * 不可用状态下按钮的图像混合的颜色。
     * @readonly
     * @type {Color}
     * @memberof UIButton
     */
    set disabledColor(val: Color);
    get disabledColor(): Color;
    constructor(entity: Entity2D);
    /**
     * 设置按钮状态。
     * @param {ButtonState} state 目标状态。
     * @param {boolean} [animation=true] 是否使用动画效果。
     * @param {boolean} [forceUpdate=false] 是否强制更新。
     * @returns {void}
     * @memberof UIButton
     */
    setState(state: ButtonState, animation?: boolean, forceUpdate?: boolean): void;
  }
}
declare module "engine/game/2D/UIGraphic" {
  import Renderable2D from "engine/game/2D/renderable2D";
  enum Shape {
    Rect = 0,
    Circle = 1,
  }
  export default class UIGraphic extends Renderable2D {
    static Shape: typeof Shape;
    /**
     * UIGraphic的图像类型
     *
     * @type {GraphicShape}
     * @memberof UIGraphic
     */
    get shape(): Shape;
    set shape(val: Shape);
    /**
     * 半径，仅Circle模式下有效
     *
     * @type {number}
     * @memberof UIGraphic
     */
    get radius(): number;
    set radius(val: number);
    /**
     * 圆的角度，仅Circle模式下有效
     *
     * @type {number}
     * @memberof UIGraphic
     */
    get angle(): number;
    set angle(val: number);
    /**
     * 圆的分段数，仅Circle模式下有效
     *
     * @type {number}
     * @memberof UIGraphic
     */
    get section(): number;
    set section(val: number);
  }
  export {};
}
declare module "engine/game/2D/UIGrid" {
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import { Listener } from "engine/misc/emitter";
  import TransformBase from "engine/game/transformBase";
  import { BoundsChangeEventType, ChildChangeEventType } from "engine/event";
  import { Entity2D } from "engine/scene/scene";
  export enum Arrangement {
    Horizontal = 0,
    Vertical = 1,
  }
  export default class UIGrid extends Component {
    /**
     * 列表方向枚举值
     *
     * @static
     * @memberof UIGrid
     */
    static Arrangement: Readonly<typeof Arrangement>;
    readonly entity: Entity2D;
    readonly priority: number;
    /**
     * Arrangement类型，列表布局方向。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get arrangement(): Arrangement;
    set arrangement(val: Arrangement);
    /**
     * 固定尺寸布局使用，每个cell的宽度。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get cellWidth(): number;
    set cellWidth(val: number);
    /**
     * 固定尺寸布局使用，每个cell的高度。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get cellHeight(): number;
    set cellHeight(val: number);
    /**
     * 默认值为false，是否开启动态尺寸布局，取每个行列取最大的元素，作为当前行列cell的大小进行布局。
     *
     * @type {boolean}
     * @memberof UIGrid
     */
    get autoSize(): boolean;
    set autoSize(val: boolean);
    /**
     * 当前布局方向下的列数，若为0，则以子元素数量作为列数。固定尺寸布局下，列垂直于当前主方向；动态尺寸布局，列平行于的主方向。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get columns(): number;
    set columns(val: number);
    /**
     * 动态尺寸布局使用，默认值为0.5，代表居中，取值范围(0-1)，决定每列所有单元格内部的水平方向对齐规则。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get cellAlignmentX(): number;
    set cellAlignmentX(val: number);
    /**
     * 动态尺寸布局使用，默认值为0.5，代表居中，取值范围(0-1)，决定每行所有单元格内部的垂直方向对齐规则。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get cellAlignmentY(): number;
    set cellAlignmentY(val: number);
    /**
     * 动态尺寸布局使用，默认值为0，每个cell之间的距离水平方向的距离。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get paddingX(): number;
    set paddingX(val: number);
    /**
     * 动态尺寸布局使用，默认值为0，每个cell之间的距离垂直方向的距离。
     *
     * @type {number}
     * @memberof UIGrid
     */
    get paddingY(): number;
    set paddingY(val: number);
    /**
     * 立即重新进行一次UIGrid的布局
     *
     * @memberof UIGrid
     */
    resetContext(): void;
    /**
     * 更新置脏（默认将在Update阶段更新）。
     *
     * @memberof UIGrid
     */
    setResetFlag(): void;
  }
}
declare module "lib/utils/xmlParser" {
  type XMLItemType = "root" | "tag" | "text";
  interface IXMLAttr {
    [attrName: string]: any;
  }
  interface IXMLItem {
    type: XMLItemType;
    name?: string;
    value?: string | string[];
    parent?: IXMLItem;
    child?: IXMLItem[];
  }
  export class XMLRoot implements IXMLItem {
    type: XMLItemType;
    child: IXMLItem[];
  }
  export class XMLTag implements IXMLItem {
    type: XMLItemType;
    name: string;
    attr: IXMLAttr;
    parent: IXMLItem;
    child: IXMLItem[];
    constructor(name: string);
  }
  export class XMLText implements IXMLItem {
    type: XMLItemType;
    value: string;
    parent: IXMLItem;
    constructor(value: string);
  }
  /**
   * 简单粗暴的XML解析器，支持如下格式的文本解析，主要用于UIRichText组件
   * <style|value=BasicLabel_Blue18>测试文字样式</style>
   */
  export default class XMLParser {
    parse(src: string): XMLRoot;
  }
  export {};
}
declare module "engine/game/2D/UIFrameAnimation" {
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  import UISprite from "engine/game/2D/UISprite";
  /**
   * 帧动画
   * 内部UI组件，暂未对外使用
   */
  export default class UIFrameAnimation extends UISprite {
    /**
     * 帧数组
     *
     * @type {SpriteFrame[]}
     * @memberof UIFrameAnimation
     */
    get frames(): SpriteFrame[];
    set frames(val: SpriteFrame[]);
    /**
     * 一秒几帧
     *
     * @type {number}
     * @memberof UIFrameAnimation
     */
    get rate(): number;
    set rate(val: number);
    /**
     * 是否循环播放
     *
     * @type {boolean}
     * @memberof UIFrameAnimation
     */
    get loop(): boolean;
    set loop(val: boolean);
    /**
     * 载入一批已经加载好的texture
     *
     * @param {string[]} ids
     * @memberof UIFrameAnimation
     */
    loadTextures(ids: string[]): void;
    /**
     * 载入一批已经加载好的spriteFrame
     *
     * @param {string[]} ids
     * @memberof UIFrameAnimation
     */
    loadSpriteFrames(ids: string[]): void;
    /**
     * 帧动画开始
     *
     * @memberof UIFrameAnimation
     */
    start(): void;
    /**
     * 帧动画停止
     *
     * @memberof UIFrameAnimation
     */
    stop(): void;
  }
}
declare module "engine/game/2D/UIRichText" {
  import { XMLRoot, XMLTag, XMLText } from "lib/utils/xmlParser";
  import Entity from "engine/scene/entity";
  import { Entity2D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import { overflowType } from "engine/game/2D/label/enum";
  import TextSystem from "engine/game/2D/system/text";
  import Font from "engine/assets/classes/font";
  import { Nullable } from "engine/type";
  enum RenderType {
    Text = 0,
    Image = 1,
    Animation = 2,
  }
  interface IStyle {
    font?: string;
    size?: number;
    color?: string;
    bold?: boolean;
    italic?: boolean;
    spacing?: number;
    stroke?: number;
    strokeColor?: string;
    underline?: number;
    underlineColor?: string;
    shadow?: string;
    shadowColor?: string;
  }
  interface IStyleMap {
    [styleName: string]: IStyle;
  }
  interface Metrics {
    width: number;
    height: number;
    layoutWidth: number;
    layoutHeight: number;
  }
  class RenderNode {
    x: number;
    y: number;
    width: number;
    height: number;
    type?: RenderType;
    vert?: "top" | "center" | "bottom";
    horz?: "left" | "center" | "right";
    text: string | null;
    style: Style | null;
    texture: string;
    spriteframe: string;
    loop: boolean;
    rate: number;
    linkData: any;
  }
  class RenderLayout {
    x: number;
    y: number;
    width: number;
    height: number;
    vert: "top" | "center" | "bottom";
    horz: "left" | "center" | "right";
    linespace: number;
    line: Line;
    lineItems: Array<RenderNode>;
    rowsNumber: number;
    contentWidth: number;
    contentHeight: number;
    layoutWidth: number;
    layoutHeight: number;
    childLayouts: Array<RenderLayout>;
    linkData: any;
  }
  class Style {
    id: number;
    font: string;
    size: number;
    color: string;
    bold: boolean;
    italic: boolean;
    spacing: number;
    stroke: number;
    strokeColor: string;
    underline: number;
    underlineColor: string | null;
    shadow: string | null;
    shadowColor: string | null;
    applyGradient: boolean;
    gradientTop: string;
    gradientBottom: string;
    constructor(id: number);
    set(data?: object): void;
  }
  class Line {
    x: number;
    y: number;
    width: number;
    height: number;
    horz: "left" | "center" | "right";
    vert: "top" | "center" | "bottom";
  }
  export class UIRichTextLinkEvent {
    text?: string;
    data: any;
  }
  export default class UIRichText extends Component {
    readonly entity: Entity2D;
    /**
     * 富文本越界处理方式枚举类型
     *
     * @static
     * @memberof UIRichText
     */
    static overflowType: typeof overflowType;
    readonly priority: number;
    constructor(entity: Entity2D);
    /**
     * 富文本设置的全局样式方法设置(继承并替换原有样式)
     *
     * @static
     * @param {IStyleMap} style
     * @memberof UIRichText
     */
    static setStyle(style: IStyleMap): void;
    /**
     * 强制重绘。异步操作，下一帧才会重绘。
     *
     * @memberof UIRichText
     */
    redraw(): void;
    /**
     * 富文本全局样式表切换设置(移除原有所有样式)
     *
     * @static
     * @memberof UIRichText
     */
    static set style(style: IStyleMap);
    /**
     * 获取富文本全局样式表
     *
     * @static
     * @type {IStyleMap}
     * @memberof UIRichText
     */
    static get style(): IStyleMap;
    /**
     * 富文本越界处理方式
     *
     * @type {overflowType}
     * @memberof UIRichText
     */
    set overflow(val: overflowType);
    get overflow(): overflowType;
    /**
     * 富文本的xml文本内容
     *
     * @type {string}}
     * @memberof UIRichText
     */
    get text(): string;
    set text(val: string);
    /**
     * 获取宽高等指标
     *
     * @readonly
     * @type {Metrics}
     * @memberof UIRichText
     */
    get metrics(): Metrics;
    /**
     * 获取行数
     *
     * @readonly
     * @type {number}
     * @memberof UIRichText
     */
    get rowsNumber(): number;
    /**
     * 字体
     *
     * @type {Nullable<Font>}
     * @memberof UIRichText
     */
    set font(val: Nullable<Font>);
    get font(): Nullable<Font>;
    get emoji(): boolean;
    set emoji(val: boolean);
  }
  export {};
}
declare module "engine/game/2D/UIScrollView" {
  import { TouchInputEvent } from "engine/input/touch";
  import { Delegate } from "engine/misc/delegate";
  import { Entity2D } from "engine/scene/scene";
  import Transform2D from "engine/game/transform2D";
  import TouchInputComponent, { Touchable } from "engine/game/2D/input/TouchInputComponent";
  import { Listener } from "engine/misc/emitter";
  import TransformBase from "engine/game/transformBase";
  import { BoundsChangeEventType, ChildChangeEventType } from "engine/event";
  enum Movement {
    Horizontal = 0,
    Vertical = 1,
  }
  export default class UIScrollView extends Touchable {
    readonly entity: Entity2D;
    /**
     * UIScrollView具有的滑动方向类型枚举值
     *
     * @static
     * @type {Movement}
     * @memberof UIScrollView
     */
    static Movement: Readonly<typeof Movement>;
    /** @deprecated */
    static MovementType: Readonly<typeof Movement>;
    readonly priority: number;
    /**
     * Movement类型，UIScrollView的滑动方向。
     *
     * @type {Movement}
     * @memberof UIScrollView
     */
    get movement(): Movement;
    set movement(val: Movement);
    /**
     * 默认值true，内容区域尺寸小于滑动区域(对应Transform2D大小)时，是否禁止滑动。
     *
     * @type {boolean}
     * @memberof UIScrollView
     */
    get disableDragIfFits(): boolean;
    set disableDragIfFits(val: boolean);
    /**
     * 默认值为0，在autoFix情况下，内容区域位于滑动区域(对应Transform2D大小)水平方向的相对位置，取值范围(0-1)。
     *
     * @type {number}
     * @memberof UIScrollView
     */
    get cellAlignmentX(): number;
    set cellAlignmentX(val: number);
    /**
     * 默认值为1，在autoFix情况下，内容区域位于滑动区域(对应Transform2D大小)垂直方向的相对位置，取值范围(0-1)。
     *
     * @type {number}
     * @memberof UIScrollView
     */
    get cellAlignmentY(): number;
    set cellAlignmentY(val: number);
    /**
     * 只读属性，相对于滑动起点，正向的已滑动的距离。
     *
     * @type {number}
     * @memberof UIScrollView
     */
    get moveDistance(): number;
    /**
     * 相对于滑动起点的，最小滑动距离，若设定，则UIScrollView自动计算最小滑动距离逻辑失效，最小值固定取该值。
     *
     * @type {number}
     * @memberof UIScrollView
     */
    get minContextMove(): number;
    set minContextMove(val: number);
    /**
     * 相对于滑动起点的，最大滑动距离，若设定，则UIScrollView自动计算最大滑动距离逻辑失效，最大值固定取该值。
     *
     * @type {number}
     * @memberof UIScrollView
     */
    get maxContextMove(): number;
    set maxContextMove(val: number);
    /**
     * 默认值为false，是否开启组件根据内容区域大小与滑动区域大小(对应Transform2D大小)，将内容区域移动到相对于当前组件的对齐位置，内容区域只会根据UIScrollView第一层子元素大小进行位置适配。
     *
     * @type {boolean}
     * @memberof UIScrollView
     */
    get autoFix(): boolean;
    set autoFix(val: boolean);
    /**
     * 默认值为false，滑动到顶后(小于minContentMove)，是否允许继续滑动
     *
     * @type {boolean}
     * @memberof UIScrollView
     */
    get snapToStart(): boolean;
    set snapToStart(val: boolean);
    /**
     * 默认值为false，滑动到底后(大于maxContentMove)，是否允许继续滑动
     *
     * @type {boolean}
     * @memberof UIScrollView
     */
    get snapToEnd(): boolean;
    set snapToEnd(val: boolean);
    /**
     * 返回UIScrollView到顶行为的Delegate，通过add方法添加事件。
     *
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof UIScrollView
     */
    get onReachStart(): Delegate<this, TouchInputEvent>;
    /**
     * Delegate<this, TouchInputEvent> | 返回UIScrollView到底行为的Delegate，通过add方法添加事件。
     *
     * @readonly
     * @type {Delegate<this, TouchInputEvent>}
     * @memberof UIScrollView
     */
    get onReachEnd(): Delegate<this, TouchInputEvent>;
    constructor(entity: Entity2D);
    /**
     * 设置设定的最大最小滑动距离，若设定则优先使用这两个值。
     *
     * @param {number} min
     * @param {number} max
     * @memberof UIScrollView
     */
    setMinMax(min: number, max: number): void;
    /**
     * 清理设定的最大最小，取消后会恢复使用自动生成最大最小距离逻辑。
     *
     * @memberof UIScrollView
     */
    clearMinMax(): void;
    /**
     * 组件滑动到，pos对应的滑动距离
     *
     * @param {number} pos
     * @memberof UIScrollView
     */
    scrollTo(pos: number): void;
    /**
     * 清空当前滑动了的距离，并重新初始化
     *
     * @memberof UIScrollView
     */
    refreshMove(): void;
    /**
     * 停止UIScrollView滑动
     *
     * @memberof UIScrollView
     */
    disableScroll(): void;
    /**
     * 开启UIScrollView滑动
     *
     * @memberof UIScrollView
     */
    enableScroll(): void;
    on(): void;
    off(): void;
  }
  export {};
}
declare module "engine/game/2D/UITextInput" {
  import Color from "engine/math/color";
  import { Entity2D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import { Touchable } from "engine/game/2D/input/TouchInputComponent";
  import UILabel from "engine/game/2D/label/UILabel";
  import { TextAlign } from "engine/game/2D/label/enum";
  import { Delegate } from "engine/misc/delegate";
  export enum TextInputType {
    Default = 0,
    Text = 1,
    Password = 2,
    number = 3,
    email = 4,
    url = 5,
  }
  export default class UITextInput extends Touchable {
    readonly entity: Entity2D;
    readonly priority: number;
    get label(): Nullable<UILabel>;
    set label(value: Nullable<UILabel>);
    get type(): TextInputType;
    set type(val: TextInputType);
    get prompt(): string;
    set prompt(val: string);
    get promptColor(): Color;
    set promptColor(val: Color);
    get maxChar(): number;
    set maxChar(val: number);
    get multiline(): boolean;
    set multiline(val: boolean);
    get align(): TextAlign;
    set align(val: TextAlign);
    get text(): string;
    set text(value: string);
    onTextChange: Delegate<
      UITextInput,
      {
        text: string;
      }
    >;
    editable: boolean;
    constructor(entity: Entity2D);
  }
}
declare module "engine/game/2D/UIToggleGroup" {
  import { Entity2D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import TransformBase from "engine/game/transformBase";
  import UIToggle from "engine/game/2D/UIToggle";
  import { Listener } from "engine/misc/emitter";
  import { ChildChangeEventType } from "engine/event";
  /**
   * TODO chidren acttive change need observe !!!
   */
  export default class UIToggleGroup extends Component {
    readonly entity: Entity2D;
    readonly priority: number;
    /**
     * 默认值为false，UIToggleGroup下属的UIToggle是否允许取消激活态。
     *
     * @type {boolean}
     * @memberof UIToggleGroup
     */
    get allowSwitchOff(): boolean;
    set allowSwitchOff(val: boolean);
    /**
     * UIToggleGroup控制的UIToggle数组
     *
     * @readonly
     * @type {Array<UIToggle>}
     * @memberof UIToggleGroup
     */
    get toggleList(): Array<UIToggle>;
    /**
     * 默认值为undefined，UIToggleGroup中默认处于激活态的UIToggle。
     *
     * @type {UIToggle}
     * @memberof UIToggleGroup
     */
    get deafaultActiveToggle(): UIToggle | undefined;
    set deafaultActiveToggle(val: UIToggle | undefined);
    constructor(entity: Entity2D);
    /**
     * 添加UIToggle进入UIToggleGroup
     *
     * @param {UIToggle} toggle
     * @memberof UIToggleGroup
     */
    addToggle(toggle: UIToggle): void;
    /**
     * 删除UIToggleGroup中的UIToggle
     *
     * @param {UIToggle} toggle
     * @memberof UIToggleGroup
     */
    removeToggle(toggle: UIToggle): void;
    /**
     * 返回当前ToggleGroup激活状态的Toggle
     *
     * @returns {(UIToggle | null)}
     * @memberof UIToggleGroup
     */
    getActiveToggle(): UIToggle | null;
    /**
     * 根据index，激活ToggleGroup里面Toggle，返回是否成功激活
     *
     * @param {number} index
     * @returns {boolean}
     * @memberof UIToggleGroup
     */
    setIndex(index: number): boolean;
    /**
     * 取消激活ToggleGroup中除toggle外的其他Toggle
     *
     * @param {UIToggle} toggle
     * @memberof UIToggleGroup
     */
    checkedChange(toggle: UIToggle): void;
  }
}
declare module "engine/game/2D/UIToggle" {
  import { TouchInputEvent } from "engine/input/touch";
  import { Entity2D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import { Touchable } from "engine/game/2D/input/TouchInputComponent";
  import Renderable2D from "engine/game/2D/renderable2D";
  import ToggleGroup from "engine/game/2D/UIToggleGroup";
  enum ToggleState {
    UnChecked = 0,
    Checked = 1,
  }
  export default class UIToggle extends Touchable {
    readonly entity: Entity2D;
    /**
     * UIToggle的状态枚举值
     *
     * @static
     * @memberof UIToggle
     */
    static ToggleState: Readonly<typeof ToggleState>;
    readonly priority: number;
    /**
     * 默认值为undefined，UIToggle关联的UIToggleGroup
     *
     * @type {ToggleGroup | undefined}
     * @memberof UIToggle
     */
    toggleGroup?: ToggleGroup;
    /**
     * 是否允许取消激活态
     *
     * @type {boolean}
     * @memberof UIToggle
     */
    get allowSwitchOff(): boolean;
    set allowSwitchOff(val: boolean);
    /**
     * 位于ToggleGroup的index，若无对应ToggleGroup则为-1
     *
     * @type {number}
     * @memberof UIToggle
     */
    get index(): number;
    set index(val: number);
    /**
     * 是否处于激活态
     *
     * @type {boolean}
     * @memberof UIToggle
     */
    get isChecked(): boolean;
    set isChecked(val: boolean);
    /**
     * UIToggle激活态影响的渲染组件
     *
     * @readonly
     * @type {(Renderable2D | undefined)}
     * @memberof UIToggle
     */
    get target(): Renderable2D | undefined;
    set target(val: Renderable2D | undefined);
    constructor(entity: Entity2D);
    /**
     * 返回当前UIToggle状态
     *
     * @returns {ToggleState}
     * @memberof UIToggle
     */
    getState(): ToggleState;
    /**
     * 设置UIToggle状态
     *
     * @param {ToggleState} state
     * @returns {void}
     * @memberof UIToggle
     */
    setState(state: ToggleState): void;
  }
  export {};
}
declare module "engine/game/2D/UIWidget" {
  import Vector2 from "engine/math/vector2";
  import { Entity2D } from "engine/scene/scene";
  import Component from "engine/game/component";
  import Transform2D from "engine/game/transform2D";
  import TransformBase from "engine/game/transformBase";
  import { Listener } from "engine/misc/emitter";
  import { SmartArray } from "engine/misc/array";
  import { BoundsChangeEventType } from "engine/event";
  enum Execute {
    onEnable = 0,
    onUpdate = 1,
    onAwake = 2,
  }
  export default class UIWidget extends Component {
    readonly entity: Entity2D;
    /**
     * 更新运算的时机的枚举值，对应不同的组件生命周期。
     *
     * @static
     * @type {Execute}
     * @memberof UIWidget
     */
    static Execute: Readonly<typeof Execute>;
    readonly priority: number;
    /**
     * 默认值为undefined，左目标内容包围盒的锚点，作为左方向对齐起点位置（取值范围(0-1)）
     *
     * @type {number}
     * @memberof UIWidget
     */
    get leftAnchor(): number | undefined;
    set leftAnchor(val: number | undefined);
    /**
     * 默认值为0，根据左方向目标Anchor对齐运算后，再叠加的偏移量
     *
     * @type {number}
     * @memberof UIWidget
     */
    get leftOffset(): number;
    set leftOffset(val: number);
    /**
     * Transform2D类型，默认值为undefined，左方向对齐目标。
     *
     * @type {Transform2D}
     * @memberof UIWidget
     */
    get leftAnchorTarget(): Transform2D | undefined;
    set leftAnchorTarget(val: Transform2D | undefined);
    /**
     * 默认值为undefined，右目标内容包围盒的锚点，作为右方向对齐起点位置（取值范围(0-1)）
     *
     * @type {number}
     * @memberof UIWidget
     */
    get rightAnchor(): number | undefined;
    set rightAnchor(val: number | undefined);
    /**
     *  默认值为0，根据右方向目标Anchor对齐运算后，再叠加的偏移量
     *
     * @type {number}
     * @memberof UIWidget
     */
    get rightOffset(): number;
    set rightOffset(val: number);
    /**
     * Transform2D类型，默认值为undefined，右方向对齐目标。
     *
     * @type {Transform2D}
     * @memberof UIWidget
     */
    get rightAnchorTarget(): Transform2D | undefined;
    set rightAnchorTarget(val: Transform2D | undefined);
    /**
     * 默认值为undefined，下目标内容包围盒的锚点，作为下方向对齐起点位置（取值范围(0-1)）
     *
     * @type {number}
     * @memberof UIWidget
     */
    get bottomAnchor(): number | undefined;
    set bottomAnchor(val: number | undefined);
    /**
     * 默认值为0，根据下方向目标Anchor对齐运算后，再叠加的偏移量
     *
     * @type {number}
     * @memberof UIWidget
     */
    get bottomOffset(): number;
    set bottomOffset(val: number);
    /**
     * Transform2D类型，默认值为undefined，下方向对齐目标。
     *
     * @type {Transform2D}
     * @memberof UIWidget
     */
    get bottomAnchorTarget(): Transform2D | undefined;
    set bottomAnchorTarget(val: Transform2D | undefined);
    /**
     * 默认值为undefined，上目标内容包围盒的锚点，作为上方向对齐起点位置（取值范围(0-1)）
     *
     * @type {number}
     * @memberof UIWidget
     */
    get topAnchor(): number | undefined;
    set topAnchor(val: number | undefined);
    /**
     * 默认值为0，根据上方向目标Anchor对齐运算后，再叠加的偏移量
     *
     * @type {number}
     * @memberof UIWidget
     */
    get topOffset(): number;
    set topOffset(val: number);
    /**
     * Transform2D类型，默认值为undefined，上方向对齐目标。
     *
     * @type {Transform2D}
     * @memberof UIWidget
     */
    get topAnchorTarget(): Transform2D | undefined;
    set topAnchorTarget(val: Transform2D | undefined);
    /**
     * Execute类型，组件属性或目标关联属性发生变化后，具体进行更新运算的时机。
     *
     * @type {Execute}
     * @memberof UIWidget
     */
    get execute(): Execute;
    set execute(val: Execute);
    constructor(entity: Entity2D);
  }
  export {};
}
declare module "engine/game/3D/animation" {
  import { Entity3D } from "engine/scene/scene";
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import AnimationSystem from "engine/system/animation";
  import { SmartArray } from "engine/misc/array";
  import { WrapMode } from "engine/assets/resource";
  type Transform3D = import("engine/game/transform3D").default;
  type AnimationClip = import("engine/assets/classes/animationClip").default;
  export default class Animation extends Component {
    readonly entity: Entity3D;
    get time(): number;
    get isPlaying(): boolean;
    get mode(): WrapMode;
    get playingClip(): Nullable<string>;
    get clip(): Nullable<string>;
    static WrapMode: Readonly<typeof WrapMode>;
    autoPlay: boolean;
    speed: number;
    priority: number;
    clips: {
      [key: string]: Nullable<AnimationClip>;
    };
    constructor(entity: Entity3D);
    onDeserialized(
      data: any,
      context: {
        [key: string]: any[];
      },
      builtContext: {
        [key: string]: SmartArray<any>;
      },
    ): void;
    rebind(): void;
    play(name?: string, time?: number, mode?: WrapMode): void;
    pause(): void;
    resume(): void;
    stop(): void;
    getClip(name: string): Nullable<AnimationClip>;
    addClip(name: string, clip: AnimationClip): void;
    removeClip(name: string): void;
  }
  export {};
}
declare module "engine/game/script" {
  import { Nullable } from "engine/type";
  import Component from "engine/game/component";
  import Entity from "engine/scene/entity";
  export default class Script extends Component {
    constructor(entity: Entity);
    onAwake?(): void;
    onStart?(): void;
    onEnable?(): void;
    onUpdate?(dt?: number): void;
    onLateUpdate?(dt?: number): void;
    onDisable?(): void;
    onDestroy?(): void;
    getComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
    getComponents<T extends Component>(ctor: typeof Component): T[];
    addComponent<T extends Component>(ctor: typeof Component): Nullable<T>;
    removeComponent(comp: Component): void;
  }
}
declare module "engine/game/rawResourceCollection" {
  import RawResource from "engine/assets/classes/raw";
  import Script from "engine/game/script";
  export default class RawResourceCollection extends Script {
    resources: RawResource[];
    ResourcePaths: RawResource[];
  }
}
declare module "engine/game/raycaster" {
  /**
   * create by janzen
   */
  import Vector3 from "engine/math/vector3";
  import Entity from "engine/scene/entity";
  import Camera from "engine/game/3D/camera";
  class Intersect {
    entity: Entity;
    distance: number;
    closetIntersectPoint: Vector3;
    constructor(entity: Entity, distance: number, closetIntersectPoint: Vector3);
  }
  export default class Raycaster {
    get direction(): Vector3;
    get origin(): Vector3;
    constructor(origin?: Vector3, direction?: Vector3);
    /**
     * 通过相机与齐次裁剪坐标来生成射线
     * @param {Vector3} clipPos 归一化的位置 -1到1，上方向为正 , 近平面z轴为-1
     * @param {Camera}  camera 相机
     */
    setFromCameraAndClipPos(clipPos: Vector3, camera: Camera): void;
    intersectEntitySimple(entity: Entity, recursive?: boolean): boolean;
    /**
     * 是否与物体相交
     * @param entity 需要被检测的物体
     * @param recursive 是否递归判断
     * @param result 结果的数组 （结果会放进去 主要为了递归用）
     * @returns 返回相交的entity
     */
    intersectEntity(entity: Entity, recursive?: boolean, result?: Intersect[]): Intersect[];
    /**
     * 是否与多个物体相交
     * @param entities 需要被检测的多个物体
     * @param recursive 是否递归判断
     * @param result 结果的数组 （结果会放进去 主要为了递归用）
     * @returns 返回相交的entity,按照包围球的近点到相机的距离排序
     */
    intersectEntities(entities: Entity[], recursive?: boolean, result?: Intersect[]): Intersect[];
  }
  export {};
}
declare module "engine/math/gradient" {
  import Color from "engine/math/color";
  const interpolate: (start: Color, end: Color, offset?: number) => Color;
  class Gradient {}
  class LinearGradient {
    constructor(top: Color, bottom: Color);
    equals(g: LinearGradient): boolean;
  }
  export { LinearGradient, Gradient, interpolate };
}
declare module "engine/misc/timer" {
  export default class Timer {
    constructor(stepTime: number);
    /**
     * 模拟客户端
     *
     * @param {Function} callback
     * @param {number} time
     * @returns {number}
     * @memberof Timer
     */
    setTimeout(callback: (...args: any[]) => any, time: number): number;
    setInterval(callback: (...args: any[]) => any, time: number): number;
    clearTimeout(id: number): void;
    clearInterval(id: number): void;
  }
}
declare module "engine/engine" {
  import { NativeBufferReader } from "lib/utils/nativeBuffer";
  import Adaptation from "engine/adaptation";
  import AnimationClip from "engine/assets/classes/animationClip";
  import AnimatorController from "engine/assets/classes/animatorController";
  import Avatar from "engine/assets/classes/avatar";
  import BaseResource from "engine/assets/classes/baseResource";
  import BitmapFont from "engine/assets/classes/bitmapFont";
  import Effect from "engine/assets/classes/effect";
  import Font from "engine/assets/classes/font";
  import Material from "engine/assets/classes/material";
  import Mesh from "engine/assets/classes/mesh";
  import Prefab from "engine/assets/classes/prefab";
  import RawResource from "engine/assets/classes/raw";
  import RenderTexture from "engine/assets/classes/renderTexture";
  import Scene from "engine/assets/classes/scene";
  import SpriteFrame from "engine/assets/classes/spriteFrame";
  import Texture2D from "engine/assets/classes/texture2D";
  import TextureCube from "engine/assets/classes/textureCube";
  import Loader from "engine/assets/loader";
  import { AmbientMode as AmbientModeEnum, FogMode as FogModeEnum, WrapMode as WrapModeEnum } from "engine/assets/resource";
  import { SerializeHelper } from "engine/assets/deserialize/deserialize";
  import { decorators, TypeNames } from "engine/assets/deserialize/decorators";
  import * as Debug from "engine/debug";
  import KeyboardInputComponent from "engine/game/2D/input/KeyboardInputComponent";
  import TouchInputComponent, { Touchable } from "engine/game/2D/input/TouchInputComponent";
  import { TextAlign, TextRenderMode, TextVAlign } from "engine/game/2D/label/enum";
  import UILabel from "engine/game/2D/label/UILabel";
  import UIAnchor from "engine/game/2D/UIAnchor";
  import UIButton from "engine/game/2D/UIButton";
  import UICamera from "engine/game/2D/UICamera";
  import UICanvas from "engine/game/2D/UICanvas";
  import UIGraphic from "engine/game/2D/UIGraphic";
  import UIGrid from "engine/game/2D/UIGrid";
  import UIMask from "engine/game/2D/UIMask";
  import UIRichText from "engine/game/2D/UIRichText";
  import UIScrollView from "engine/game/2D/UIScrollView";
  import UISprite from "engine/game/2D/UISprite";
  import UITextInput from "engine/game/2D/UITextInput";
  import UIToggle from "engine/game/2D/UIToggle";
  import UIToggleGroup from "engine/game/2D/UIToggleGroup";
  import UIWidget from "engine/game/2D/UIWidget";
  import UILayer from "engine/game/2D/UILayer";
  import Animation from "engine/game/3D/animation";
  import Animator from "engine/game/3D/animator";
  import Camera from "engine/game/3D/camera";
  import DirectionalLight from "engine/game/3D/directionalLight";
  import LineRenderer from "engine/game/3D/lineRenderer";
  import MeshRenderer from "engine/game/3D/meshRenderer";
  import SkinnedMeshRenderer from "engine/game/3D/skinnedMeshRenderer";
  import TrailRenderer from "engine/game/3D/trailRenderer";
  import Component from "engine/game/component";
  import Game from "engine/game/game";
  import Particle from "engine/game/particles/particle";
  import RawResourceCollection from "engine/game/rawResourceCollection";
  import Raycaster from "engine/game/raycaster";
  import Script from "engine/game/script";
  import Transform2D from "engine/game/transform2D";
  import Transform3D from "engine/game/transform3D";
  import TransformBase from "engine/game/transformBase";
  import PostProcessComponent from "engine/game/postProcess";
  import { default as InternalGctx } from "engine/globalContext";
  import { default as InternalDynamicBuffer } from "engine/graphicResource/dynamicBuffer";
  import Color, { BlendType } from "engine/math/color";
  import HermiteCurve from "engine/game/particles/libs/hermiteCurve";
  import GradientColor from "engine/game/particles/libs/gradientColor";
  import { LinearGradient } from "engine/math/gradient";
  import Matrix3 from "engine/math/matrix3";
  import Matrix4 from "engine/math/matrix4";
  import Quaternion from "engine/math/quaternion";
  import Rect from "engine/math/rect";
  import Vector2 from "engine/math/vector2";
  import Vector3 from "engine/math/vector3";
  import Vector4 from "engine/math/vector4";
  import { Delegate } from "engine/misc/delegate";
  import Timer from "engine/misc/timer";
  import Device, { Environment as EnvironmentEnum, GroupPlatform as GroupPlatformEnum, Platform as PlatformEnum } from "engine/platform/device";
  import { buildin2DVertexLayout, buildInVertexLayoutFactory3D } from "engine/render/buildinVertexLayout";
  import Renderer from "engine/render/renderer";
  import { default as InternalUniformBlockValue } from "engine/render/uniformBlockValue";
  import { default as InternalVertexLayout, EnumVertexLayoutUsage as InternalEnumVertexLayoutUsage } from "engine/render/vertexLayout";
  import Entity from "engine/scene/entity";
  import Settings from "engine/settings";
  import { FrameSystem, FrameSystemMode } from "engine/game/FrameSystem";
  import { CacheManager } from "engine/assets/cache";
  import { NumberJSONMap, ComplexJSONMap } from "engine/assets/lib/util";
  import {
    MaterialEventType,
    MeshEventType,
    BoundsChangeEventType,
    ChildChangeEventType,
    DirectionalLightEventType,
    Renderable2DEventType,
    MeshRendererEventType,
    PipeLineEventType,
  } from "engine/event";
  import LitePromise from "lib/utils/promise";
  import EngineWorker from "engine/worker/worker";
  import WorkerJob from "engine/worker/job";
  const version: string;
  const workerVersion = "1.0";
  const createNativeUUMap: () => wxGA.NativeMap<number>;
  const createNativeSUMap: () => wxGA.NativeMap<string>;
  const createNativeULUMap: () => wxGA.LongIntToIntMap;
  export {
    version,
    workerVersion,
    Animation,
    AnimationClip,
    RawResourceCollection,
    Animator,
    AnimatorController,
    Avatar,
    BaseResource,
    Camera,
    UICamera,
    Color,
    LinearGradient,
    Component,
    DirectionalLight,
    Debug,
    Effect,
    Entity,
    FrameSystem,
    FrameSystemMode,
    Game,
    GradientColor,
    HermiteCurve,
    KeyboardInputComponent,
    Material,
    Matrix3,
    Matrix4,
    Mesh,
    MeshRenderer,
    NativeBufferReader,
    Particle,
    Prefab,
    Quaternion,
    Raycaster,
    Rect,
    RenderTexture,
    Scene,
    Script,
    SerializeHelper,
    SkinnedMeshRenderer,
    LineRenderer,
    TrailRenderer,
    SpriteFrame,
    Texture2D,
    TextureCube,
    Font,
    BitmapFont,
    RawResource,
    TouchInputComponent,
    Transform2D,
    Transform3D,
    TransformBase,
    PostProcessComponent,
    BlendType,
    UIAnchor,
    UIButton,
    UICanvas,
    UIGraphic,
    UIGrid,
    UILabel,
    TextAlign,
    TextVAlign,
    TextRenderMode,
    TypeNames,
    UIMask,
    UIRichText,
    UIScrollView,
    UISprite,
    UITextInput,
    UIToggle,
    UIToggleGroup,
    UIWidget,
    UILayer,
    Vector2,
    Vector3,
    Vector4,
    buildin2DVertexLayout,
    buildInVertexLayoutFactory3D,
    decorators,
    Touchable,
    Delegate,
    ComplexJSONMap,
    NumberJSONMap,
    createNativeUUMap,
    createNativeSUMap,
    createNativeULUMap,
    MaterialEventType,
    MeshEventType,
    BoundsChangeEventType,
    ChildChangeEventType,
    DirectionalLightEventType,
    Renderable2DEventType,
    MeshRendererEventType,
    PipeLineEventType,
    EngineWorker as Worker,
    WorkerJob,
    LitePromise,
  };
  export let canvas: HTMLCanvasElement;
  export let renderer: Renderer;
  export let loader: Loader;
  export let device: Device;
  export let adaptation: Adaptation;
  export let settings: Settings;
  export let timer: Timer;
  export let cache: CacheManager;
  export const Environment: typeof EnvironmentEnum;
  export const Platform: typeof PlatformEnum;
  export const GroupPlatform: typeof GroupPlatformEnum;
  export const AmbientMode: typeof AmbientModeEnum;
  export const FogMode: typeof FogModeEnum;
  export const WrapMode: typeof WrapModeEnum;
  export let game: Game;
  export let UniformBlockValue: typeof InternalUniformBlockValue | undefined;
  export let DynamicBuffer: typeof InternalDynamicBuffer | undefined;
  export let VertexLayout: typeof InternalVertexLayout | undefined;
  export let gctx: typeof InternalGctx | undefined;
  export let EnumVertexLayoutUsage: typeof InternalEnumVertexLayoutUsage | undefined;
  export let EnumVertexFormat: typeof wgfx.EnumVertexFormat | undefined;
  export let EnumUniformType: typeof wgfx.EnumUniformType | undefined;
  export function init(this: void, canvas: HTMLCanvasElement, settings?: any): void;
}
declare module "engine" {
  import "wgfx";
  import * as engine from "engine/engine";
  export default engine;
}
declare module "engine/adaptation" {
  import { Nullable } from "engine/type";
  export enum AdaptationType {
    Auto = 0,
    FillWidth = 1,
    FillHeight = 2,
  }
  export default class Adaptation {
    canvas: Nullable<HTMLCanvasElement>;
    fillType: AdaptationType;
    frameWidth: number;
    frameHeight: number;
    designWidth: number;
    designHeight: number;
    aspect: number;
    uiScale: number;
    constructor();
    setDesignSize(width: number, height: number): void;
    setRenderSize(width: number, height: number): void;
  }
}
declare module "engine/compile" {
  export {};
}
/**
 * 资源组的信息
 *
 * @interface IGroupConfig
 */
declare interface IGroupConfig extends ILoaderGroupConfig {
  /**
   * 资源组 id
   *
   * @type {string}
   * @memberof IGroupConfig
   */
  id: string;
}
declare interface ILoaderGroupConfig {
  /**
   * 资源组的下载 url
   *
   * @type {string}
   * @memberof IGroupConfig
   */
  url: string;
  // 资源组的大小，单位字节
  size: number;

  version?: string;

  dep_groups?: string[];
}

/**
 * 资源的信息
 *
 * @interface IAssetInfo
 */
declare interface IAssetInfo extends ILoaderAssetInfo {
  /**
   * 资源id
   *
   * @type {string}
   * @memberof IAssetInfo
   */
  id: string;
}
/**
 * 存储于loader的资源的信息
 *
 * @interface IAssetInfo
 */
declare interface ILoaderAssetInfo {
  /**
   * 资源所属组id
   *
   * @type {string}
   * @memberof IAssetInfo
   */
  groupid: string;
}

/**
 * 文件描述符
 *
 * @interface IFileDescription
 * @internal
 */
declare interface IFileDescription {
  path: string;
  index?: number; // 如果是一个大文件，这里表示起始位置
  length?: number; // 如果是一个大文件且是arraybuffer和text，这里表示长度
}
declare interface IResourceDefinition {
  dependencies: string[];
  type: string;
  descriptionFileID: string;
}
declare interface IResourceDefinitions {
  [id: string]: IResourceDefinition;
}
declare interface IGroupManifest {
  files: Array<{ filetype: string; path: string; size?: number /* size 在 group version === binconcat，这个文件是 arraybuffer 的情况下是可能不准的 */ }>;
  fileDescriptions: { [id: string]: IFileDescription };
  resourceDefinitions: IResourceDefinitions;
  // group version === binconcat 的情况下 size 不再准，而且 register.json 里也已经有了，所以统一不用了
  size: number; // 数值不准，忽略
  md5: string;
  entries?: { [id: string]: string };
}

/**
 * loader Context 声明
 */
declare interface ILoaderContext {
  schema: string;
  performance: {
    loadStart: number;
    loadEnd: number;
    queueStart: number;
    queueEnd: number;
    initStart: number;
    initEnd: number;
    initLoadGroup: number;
    endLoadGroup: number;
  };
  dependence: ILoaderContext[];
  size: number;
  loadEnd();
}
declare module "engine/assets/serialize" {
  import { Nullable } from "engine/type";
  import BaseResource from "engine/assets/classes/baseResource";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export interface IComponentCtor<T> {
    readonly prototype: any;
    Deserialize?: (data: object, result: T, context: any, builtContext: any) => Nullable<T>;
    new (...args: any[]): T;
  }
  export interface IResourceCtor {
    readonly prototype: any;
    DeserializeResource: (resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[]) => Nullable<BaseResource>;
    new (...args: any[]): BaseResource;
  }
  export type SerializableCtor = IComponentCtor<any> | IResourceCtor;
  export const SerializableObjectMap: {
    [key: string]: SerializableCtor;
  };
  export const PROPERTY_KEY: string;
  export const PROPERTY_ARRAY_KEY: string;
  export const TYPE_NAME_KEY: string;
  export const CONTEXT_KEY: string;
  export class MultiType {
    constructor(info: { [key: string]: TypeInfo });
  }
  export class EnumType {
    constructor(info: any);
  }
  export function GetClass(className: string): Nullable<SerializableCtor>;
  export type TypeInfo = SerializableCtor | string | [SerializableCtor] | [string];
  /**
   * 序列化属性信息
   */
  export interface IPropertyBaseConfig {
    deserialize?: boolean;
    serialize?: boolean;
    required?: boolean;
    default?: any;
    visible?: boolean;
    tooltips?: string;
  }
  /**
   * 序列化属性信息
   */
  export interface IPropertyConfig extends IPropertyBaseConfig {
    /**
     * 类型信息，可以是一个类的构造函数，也可以是"string"， "number"， "boolean"这些字符串中的任意一个。
     * 类型信息也可以是一个长度为1的数组，这时候表示该属性是一个数组，数组中的每一个元素的序列化信息都是一致的。
     */
    type: TypeInfo | MultiType | EnumType;
  }
  export interface IPropertyMultiConfig extends IPropertyBaseConfig {
    type: {
      [key: string]: TypeInfo;
    };
  }
  export interface IPropertyEnumConfig extends IPropertyBaseConfig {
    type: any;
  }
  export const decorators: {
    /**
     * 仅供内部使用
     */
    context: (refMap: Map<SerializableCtor, string>) => (classCtor: SerializableCtor) => void;
    /**
     * 类修饰器，注册一个类，使得它的实例可以被序列化。
     * @param {string} typeName 类的名字，全局唯一。
     */
    serialize: (typeName: string) => ClassDecorator;
    property: {
      (config: IPropertyConfig): PropertyDecorator & ParameterDecorator;
      multi(config: IPropertyMultiConfig): PropertyDecorator & ParameterDecorator;
      enum(config: IPropertyEnumConfig): PropertyDecorator & ParameterDecorator;
      /**
       * 属性修饰器，和property不同的是，有些类的实例序列化的结果并不是一个对象而是一个数组，比如Color等。可继承。
       * 这些类的属性上面应该使用这个修饰器。
       * @param {number} index 序列化后该属性在最终的数组中的索引。
       * @param {IPropertyConfig} config 属性序列化时需要的类型信息。
       */
      array(index: number, config: IPropertyConfig): PropertyDecorator & ParameterDecorator;
    };
  };
  export interface ISerializedObject {
    type: string;
    data: any;
  }
  export class SerializeHelper {
    static Context: any;
    static ContextMap: Nullable<Map<SerializableCtor, string>>;
    static BuiltContext: any;
    /**
     * 反序列化一个对象。
     * @param {any} fileData 被序列化的对象的数据
     * @optional @param {any} target 是否已经有反序列化的实例对象，某些情况比如Component需要首先调用Entity.protoptype.addComponent的方法产生实例后才能给这个实例的每个属性赋值，这时候就用的到这个参数。
     */
    static Deserialize(fileData: any, target?: any): any;
    /**
     * 实例化一个资源
     * @param type 资源类型
     * @param resourceDescription 主描述文件
     * @param loadContext
     */
    static DeserializeResource(type: string, resourceDescription: any, loadContext: BaseLoadContext, dependencies?: string[]): Nullable<BaseResource>;
    static EnterContext(context: any, contextMap: any): void;
    static LeaveContext(): void;
  }
}
declare module "engine/assets/deserialize/compiled.editor" {
  export const DeserializeFailFlag: any;
  export default function Deserialize(json: any, result: any, context: any, builtContext: any): any;
}
declare module "engine/assets/lib/load-from-ide" {
  export function loadContent(filePath: string, fileType: string, iframe: boolean): Promise<any>;
  export function loadMeta(
    resourceID: string,
    iframe: boolean,
  ): Promise<{
    uuid: string;
    fileType: string;
    filePath: string;
    [key: string]: any;
  }>;
}
declare module "engine/assets/load-contexts/load-context-browser" {
  import LitePromise from "lib/utils/promise";
  import { LoadTargetGroup } from "engine/assets/load-contexts/load-context";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export default class LoadContextBrowser extends BaseLoadContext {
    get loaded(): boolean;
    get error(): Error | null;
    get groupManifest(): IGroupManifest | null;
    set groupManifest(groupManifest: IGroupManifest | null);
    constructor(target: LoadTargetGroup);
    getKey(): string;
    registerTask(): void;
    unregisterTask(): void;
    getAsset(assetID: string): any;
    getFile<T>(fileDescriptionID: string): T;
    /**
     * 等待manifest加载
     */
    getResourceDefinitions(): LitePromise<void>;
    get resourceDefinitions(): IResourceDefinitions | null;
  }
}
declare module "engine/assets/load-contexts/load-context-ide" {
  import LitePromise from "lib/utils/promise";
  import { BaseLoadContext } from "engine/assets/load-contexts/load-context-definition";
  export default class LoadContextIDE extends BaseLoadContext {
    get loaded(): boolean;
    get error(): Error | null;
    get progress(): {
      total: number;
      current: number;
    };
    constructor(assetid: string, iframe: boolean);
    getKey(): any;
    getResourceDefinitions(): LitePromise<void>;
    get resourceDefinitions(): IResourceDefinitions | null;
    getFile<T>(descriptionFileID: any): T;
    getAsset(): any;
    registerTask(): void;
    unregisterTask(): void;
  }
}
declare module "engine/game/particles/libs/bezierCurve" {
  import { SmartArray } from "engine/misc/array";
  interface IPoint {
    x: number;
    y: number;
  }
  /**
   * 贝塞尔曲线
   */
  export default class BezierCurve {
    /**
     * @param data data: number[], x1,y1,x2,y2,...
     */
    static Deserialize(
      list: number[],
      curve: BezierCurve,
      context: {
        [key: string]: any[];
      },
      builtContext: {
        [key: string]: SmartArray<any>;
      },
    ): BezierCurve;
    static factorial(num: number): number;
    points: IPoint[];
    setPoints(points: IPoint[]): void;
    addPoint(point: IPoint): void;
    get(t: number): IPoint;
  }
  export {};
}
interface IBuffer {
  byteSize: number;
}

interface IImage {}
type TextureSource = HTMLCanvasElement | HTMLImageElement | ArrayBufferView;
declare module "engine/misc/list" {
  export interface ILinkedListNode<T> {
    element: T;
    next: ILinkedListNode<T> | null;
  }
  /**
   * Function signature for comparing
   * <0 means a is smaller
   * = 0 means they are equal
   * >0 means a is larger
   */
  export interface ICompareFunction<T> {
    (a: T, b: T): number;
  }
  /**
   * Function signature for checking equality
   */
  export interface IEqualsFunction<T> {
    (a: T, b: T): boolean;
  }
  /**
   * Function signature for Iterations. Return false to break from loop
   */
  export interface ILoopFunction<T> {
    (a: T): boolean | void;
  }
  /**
   * Default function to compare element order.
   * @function
   */
  export function defaultCompare<T>(a: T, b: T): number;
  /**
   * Default function to test equality.
   * @function
   */
  export function defaultEquals<T>(a: T, b: T): boolean;
  export class LinkedList<T> {
    /**
     * First node in the list
     * @type {Object}
     * @private
     */
    firstNode: ILinkedListNode<T> | null;
    /**
     * Creates an empty Linked List.
     * @class A linked list is a data structure consisting of a group of nodes
     * which together represent a sequence.
     * @constructor
     */
    constructor();
    /**
     * Adds an element to this list.
     * @param {Object} item element to be added.
     * @param {number=} index optional index to add the element. If no index is specified
     * the element is added to the end of this list.
     * @return {boolean} true if the element was added or false if the index is invalid
     * or if the element is undefined.
     */
    add(item: T, index?: number): boolean;
    /**
     * Returns the first element in this list.
     * @return {*} the first element of the list or undefined if the list is
     * empty.
     */
    first(): T | undefined;
    /**
     * Returns the last element in this list.
     * @return {*} the last element in the list or undefined if the list is
     * empty.
     */
    last(): T | undefined;
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index desired index.
     * @return {*} the element at the given index or undefined if the index is
     * out of bounds.
     */
    elementAtIndex(index: number): T | undefined;
    /**
     * Returns the index in this list of the first occurrence of the
     * specified element, or -1 if the List does not contain this element.
     * <p>If the elements inside this list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {number} the index in this list of the first occurrence
     * of the specified element, or -1 if this list does not contain the
     * element.
     */
    indexOf(item: T, equalsFunction?: IEqualsFunction<T>): number;
    /**
     * Returns true if this list contains the specified element.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to search for.
     * @param {function(Object,Object):boolean=} equalsFunction Optional
     * function used to check if two elements are equal.
     * @return {boolean} true if this list contains the specified element, false
     * otherwise.
     */
    contains(item: T, equalsFunction?: IEqualsFunction<T>): boolean;
    /**
     * Removes the first occurrence of the specified element in this list.
     * <p>If the elements inside the list are
     * not comparable with the === operator a custom equals function should be
     * provided to perform searches, the function must receive two arguments and
     * return true if they are equal, false otherwise. Example:</p>
     *
     * <pre>
     * const petsAreEqualByName = function(pet1, pet2) {
     *  return pet1.name === pet2.name;
     * }
     * </pre>
     * @param {Object} item element to be removed from this list, if present.
     * @return {boolean} true if the list contained the specified element.
     */
    remove(item: T, equalsFunction?: IEqualsFunction<T>): boolean;
    /**
     * Removes all of the elements from this list.
     */
    clear(): void;
    /**
     * Returns true if this list is equal to the given list.
     * Two lists are equal if they have the same elements in the same order.
     * @param {LinkedList} other the other list.
     * @param {function(Object,Object):boolean=} equalsFunction optional
     * function used to check if two elements are equal. If the elements in the lists
     * are custom objects you should provide a function, otherwise
     * the === operator is used to check equality between elements.
     * @return {boolean} true if this list is equal to the given list.
     */
    equals(other: any, equalsFunction?: IEqualsFunction<T>): boolean;
    /**
     * Removes the element at the specified position in this list.
     * @param {number} index given index.
     * @return {*} removed element or undefined if the index is out of bounds.
     */
    removeElementAtIndex(index: number): T | undefined;
    /**
     * Executes the provided function once for each element present in this list in order.
     * @param {function(Object):*} callback function to execute, it is
     * invoked with one argument: the element value, to break the iteration you can
     * optionally return false.
     */
    forEach(callback: ILoopFunction<T>): void;
    /**
     * Reverses the order of the elements in this linked list (makes the last
     * element first, and the first element last).
     */
    reverse(): void;
    /**
     * Returns an array containing all of the elements in this list in proper
     * sequence.
     * @return {Array.<*>} an array containing all of the elements in this list,
     * in proper sequence.
     */
    toArray(): T[];
    /**
     * Returns the number of elements in this list.
     * @return {number} the number of elements in this list.
     */
    size(): number;
    /**
     * Returns true if this list contains no elements.
     * @return {boolean} true if this list contains no elements.
     */
    isEmpty(): boolean;
  }
}
declare module "lib/utils/bufferAllocator" {
  export default class BufferAllocator {
    get buffer(): ArrayBuffer;
    constructor(buffer: ArrayBuffer);
    allocate(
      acLength: number,
    ): {
      offset: number;
      bufferName: string;
    } | null;
    dispose(offset: number, acLength: number): true | null;
  }
}
declare module "lib/utils/thunk" {
  type Callback<T> = (error: Error | null, res: T | null) => any;
  type ThunkFunction<T> = (callback: Callback<T>) => void;
  export interface Thunk<T> extends ThunkFunction<T> {
    toPromise(): Promise<T>;
  }
  /**
   * 一个带状态机功能的Thunk
   * @param behavior
   */
  export function ThunkFactory<T>(behavior: (resolve: any, reject: any) => void): Thunk<T>;
  export namespace ThunkFactory {
    var resolve: (arg?: any) => Thunk<unknown>;
    var reject: (err?: Error | undefined) => Thunk<unknown>;
    var all: (thunks: any) => Thunk<unknown>;
  }
  export {};
}
interface Window {
  WeakRef?: new (arg: any) => any;
  // tslint:disable-next-line: ban-types
  FinalizationGroup?: new (arg: Function) => any;
  IDE_ENGINEIDE_LOCATION?: string;
}

// typescript 不支持 mixin
interface Global {
  WeakRef?: new (arg: any) => any;
  // tslint:disable-next-line: ban-types
  FinalizationGroup?: new (arg: Function) => any;
  IDE_ENGINEIDE_LOCATION?: string;
  engine?: typeof import("engine").default & { default?: typeof import("engine").default };
  wgfx?: typeof wgfx;
}

declare function requireScript(path: string): any;
declare const engine: typeof import("engine").default & { default?: typeof import("engine").default };
declare module pluginEnv {
  class XLogManager {
    log: (message?: any, ...optionalParams: any[]) => void;
    info: (message?: any, ...optionalParams: any[]) => void;
    warn: (message?: any, ...optionalParams: any[]) => void;
    error: (message?: any, ...optionalParams: any[]) => void;
  }
  function getXLogManager(): XLogManager;
} /* eslint-disable @typescript-eslint/member-ordering */

declare namespace wgfx {
  export enum EnumFeature {
    INSTANCING = 0,
    TEXTURE_COMPRESSION_DXT = 1,
    TEXTURE_COMPRESSION_PVRTC = 2,
    TEXTURE_COMPRESSION_ATC = 3,
    TEXTURE_COMPRESSION_ETC2 = 4,
    TEXTURE_FLOAT = 5,
    TEXTURE_HALF_FLOAT = 6,
    ORIGIN_BOTTOM_LEFT = 7,
    ORIGIN_TOP_LEFT = 8,
    MSAA_RENDER_TARGETS = 9,
    PACKED_VERTEX_FORMAT_10_2 = 10,
    MULTIPLE_RENDER_TARGET = 11,
    IMAGETYPE_3D = 12,
    IMAGETYPE_ARRAY = 13,
    TEXTURE_COMPRESSION_ETC1 = 14,
    TEXTURE_COMPRESSION_ASTC_8x8 = 15,
  }
  // sg_usage
  export enum EnumUsage {
    IMMUTABLE = 1,
    DYNAMIC = 2,
    STREAM = 3,
  }

  // sg_buffer_type
  export enum EnumBufferType {
    VERTEXBUFFER = 1,
    INDEXBUFFER = 2,
  }
  // sg_index_type
  export enum EnumIndexType {
    NONE = 1,
    UINT16 = 2,
    UINT32 = 3,
  }
  // sg_image_type
  export enum EnumImageType {
    IMAGETYPE_2D = 1,
    IMAGETYPE_CUBE = 2,
    IMAGETYPE_3D = 3,
    IMAGETYPE_ARRAY = 4,
  }
  // sg_cube_face
  export enum EnumCubeFace {
    POS_X = 0,
    NEG_X = 1,
    POS_Y = 2,
    NEG_Y = 3,
    POS_Z = 4,
    NEG_Z = 5,
    NUM = 6,
  }
  // sg_shader_stage
  export enum EnumShaderStage {
    VS = 0,
    FS = 1,
  }

  // sg_pixel_format
  export enum EnumPixelFormat {
    NONE = 1,
    RGBA8 = 2,
    RGB8 = 3,
    RGBA4 = 4,
    R5G6B5 = 5,
    R5G5B5A1 = 6,
    R10G10B10A2 = 7,
    RGBA32F = 8,
    RGBA16F = 9,
    R32F = 10,
    R16F = 11,
    L8 = 12,
    DXT1 = 13,
    DXT3 = 14,
    DXT5 = 15,
    DEPTH = 16,
    DEPTHSTENCIL = 17,
    PVRTC2_RGB = 18,
    PVRTC4_RGB = 19,
    PVRTC2_RGBA = 20,
    PVRTC4_RGBA = 21,
    ETC2_RGB8 = 22,
    ETC2_SRGB8 = 23,
    ETC1_RGB8 = 24,
    PIXELFORMAT_PVR_CCZ = 25,
    PIXELFORMAT_PVR_GZ = 26,
    PIXELFORMAT_ETC2_RGBA8 = 27,
    ASTC = 28,
  }
  // sg_primitive_type
  export enum EnumPrimitiveType {
    POINTS = 1,
    LINES = 2,
    LINE_STRIP = 3,
    TRIANGLES = 4,
    TRIANGLE_STRIP = 5,
  }
  // sg_filter
  export enum EnumFilter {
    NEAREST = 1,
    LINEAR = 2,
    NEAREST_MIPMAP_NEAREST = 3,
    NEAREST_MIPMAP_LINEAR = 4,
    LINEAR_MIPMAP_NEAREST = 5,
    LINEAR_MIPMAP_LINEAR = 6,
  }
  // sg_wrap
  export enum EnumWrap {
    REPEAT = 1,
    CLAMP_TO_EDGE = 2,
    MIRRORED_REPEAT = 3,
  }
  // sg_vertex_format
  export enum EnumVertexFormat {
    INVALID = 0,
    FLOAT = 1,
    FLOAT2 = 2,
    FLOAT3 = 3,
    FLOAT4 = 4,
    BYTE4 = 5,
    BYTE4N = 6,
    UBYTE4 = 7,
    UBYTE4N = 8,
    SHORT2 = 9,
    SHORT2N = 10,
    SHORT4 = 11,
    SHORT4N = 12,
    UINT10_N2 = 13,
  }
  // sg_vertex_step
  export enum EnumVertexStep {
    PER_VERTEX = 1,
    PER_INSTANCE = 2,
  }
  // sg_uniform_type
  export enum EnumUniformType {
    INVALID = 0,
    FLOAT = 1,
    FLOAT2 = 2,
    FLOAT3 = 3,
    FLOAT4 = 4,
    MAT4 = 5,
  }
  // sg_cull_mode
  export enum EnumCullMode {
    NONE = 1,
    FRONT = 2,
    BACK = 3,
  }
  // sg_face_winding
  export enum EnumFaceWinding {
    CCW = 1,
    CW = 2,
  }
  // sg_compare_func
  export enum EnumCompareFunc {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
  }
  // sg_stencil_op
  export enum EnumStencilOp {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCR_CLAMP = 4,
    DECR_CLAMP = 5,
    INVERT = 6,
    INCR_WRAP = 7,
    DECR_WRAP = 8,
  }
  // sg_blend_factor
  export enum EnumBlendFactor {
    ZERO = 1,
    ONE = 2,
    SRC_COLOR = 3,
    ONE_MINUS_SRC_COLOR = 4,
    SRC_ALPHA = 5,
    ONE_MINUS_SRC_ALPHA = 6,
    DST_COLOR = 7,
    ONE_MINUS_DST_COLOR = 8,
    DST_ALPHA = 9,
    ONE_MINUS_DST_ALPHA = 10,
    SRC_ALPHA_SATURATED = 11,
    BLEND_COLOR = 12,
    ONE_MINUS_BLEND_COLOR = 13,
    BLEND_ALPHA = 14,
    ONE_MINUS_BLEND_ALPHA = 15,
  }
  // sg_blend_op
  export enum EnumBlendOp {
    ADD = 1,
    SUBTRACT = 2,
    REVERSE_SUBTRACT = 3,
  }
  // sg_color_mask
  export enum EnumColorMask {
    NONE = 0x10 /* special value for 'all channels disabled */,
    R = 1 << 0,
    G = 1 << 1,
    B = 1 << 2,
    A = 1 << 3,
    RGB = 0x7,
    RGBA = 0xf,
  }

  // sg_action
  export enum EnumAction {
    CLEAR = 1,
    LOAD = 2,
    DONTCARE = 3,
  }

  export enum EnumPixelType {
    UNSIGNED_BYTE = 0x1401,
    FLOAT = 0x1406,
    UNSIGNED_SHORT_5_6_5 = 0x8363,
    UNSIGNED_SHORT_4_4_4_4 = 0x8033,
    UNSIGNED_SHORT_5_5_5_1 = 0x8034,
  }

  export enum EnumResourceState {
    INITIAL = 0,
    ALLOC = 1,
    VALID = 2,
    FAILED = 3,
    INVALID = 4,
  }

  /*
	    Buffer
	  */
  interface BufferDesc {
    type: EnumBufferType;
    content?: ArrayBufferView;
    usage?: EnumUsage;
    size?: number;
  }

  /*
	    PassAction
	  */
  interface ColorAttachmentAction {
    action: EnumAction;
    val: number[] /* float[4]*/;
  }
  interface DepthAttachmentAction {
    action: EnumAction;
    val: number /* float*/;
  }
  interface StencilAttachmentAction {
    action: EnumAction;
    val: number /* uint8*/;
  }
  interface PassActionDesc {
    colors?: ColorAttachmentAction[];
    depth?: DepthAttachmentAction;
    stencil?: StencilAttachmentAction;
  }

  /*
	    Pass
	  */
  interface AttachmentDesc {
    image: Image;
  }
  interface PassDesc {
    color_attachments: AttachmentDesc[];
    depth_stencil_attachment: AttachmentDesc;
  }
  /*
	    Image
	  */

  interface ImageUpdateDesc {
    content: {
      subimage: (HTMLCanvasElement | HTMLImageElement | ArrayBufferView) /* CUBEFACE_NUM*/[] /* MAX_MIPMAPS*/[];
    };
    x?: number;
    y?: number;
    width?: number;
    height?: number;
    // add additional
    unpack_premultiply_alpha?: boolean;
  }
  interface ImageDesc {
    type?: EnumImageType;
    render_target?: boolean;
    width?: number;
    height?: number;
    num_mipmaps?: number;
    usage?: EnumUsage;
    pixel_format?: EnumPixelFormat;
    sample_count?: number;
    min_filter?: EnumFilter;
    mag_filter?: EnumFilter;
    wrap_u?: EnumWrap;
    wrap_v?: EnumWrap;
    wrap_w?: EnumWrap;
    max_anisotropy?: number;
    min_lod?: number;
    max_lod?: number;
    content?: {
      subimage: (HTMLImageElement | HTMLCanvasElement | ArrayBufferView) /* CUBEFACE_NUM*/[] /* MAX_MIPMAPS*/[];
    };
    // add additional
    unpack_premultiply_alpha?: boolean;
    generate_mipmaps?: boolean;
  }

  /*
	    Shader
	  */
  interface ShaderImageDesc {
    name: string;
    type: EnumImageType;
  }
  interface ShaderUniformDesc {
    name: string;
    type: EnumUniformType;
    array_count?: number;
  }
  interface ShaderUniformBlockDesc {
    size: number;
    uniforms: ShaderUniformDesc[];
  }
  interface ShaderStageDesc {
    uniform_blocks?: ShaderUniformBlockDesc[];
    source: string;
    images?: ShaderImageDesc[];
  }
  interface ShaderDesc {
    binary?: GfxNativeBuffer;
    vs: ShaderStageDesc;
    fs: ShaderStageDesc;
  }
  type PipelineDesc = any;
  type BindingsDesc = any;
  interface GfxNativeBuffer {
    data: ArrayBuffer;
    id: number;
  }

  interface FontTextureInfo {
    image: Image;
    w: number;
    h: number;
    tx: number;
    ty: number;
    tw: number;
    th: number;
  }

  class RenderingContext {
    createNativeBuffer(sizeOrContent: number | ArrayBufferView): GfxNativeBuffer;
    makeBuffer(desc: BufferDesc): Buffer;
    makePassAction(desc: PassActionDesc): PassAction;
    makePass(desc: PassDesc): Pass;
    makeImage(desc: ImageDesc): Image;
    makeShader(desc: ShaderDesc): Shader;
    makePipeline(desc: PipelineDesc): Pipeline;
    makeBindings(desc: BindingsDesc): Bindings;

    // 这里和sokol_gfx原来的接口比有改动，为实现局部更新Buffer和Image
    updateBuffer(buffer: Buffer, dstOffset: number, content: ArrayBufferView | GfxNativeBuffer, srcOffset?: number, srcLength?: number): void;
    updateImage(image: Image, desc: ImageUpdateDesc): void;

    beginPass(pass: Pass, action: PassAction): void;
    beginDefaultPass(action: PassAction, width: number, height: number): void;
    applyPipeline(pipeline: Pipeline): void;
    applyBindings(bindings: Bindings): void;
    applyUniforms(shaderStage: EnumShaderStage, index: number, data: any): void;
    draw(baseElement: number, numElements: number, numInstances: number): void;
    endPass(): void;
    commit(): void;
    getPixels(x: number, y: number, width: number, height: number, format: EnumPixelFormat.RGBA8, type: EnumPixelType.UNSIGNED_BYTE): ArrayBuffer;
    queryGlyphBitmapInfo?(text: string, font: string): FontTextureInfo | Array<FontTextureInfo>;
    decodeImage?(image: string | ArrayBuffer, callback: (result: ArrayBuffer | number | undefined) => void, resultArrayBuffer?: ArrayBuffer);
    queryFeature(feature: number): number;

    queryPassState(pass: Pass): EnumResourceState;
    queryBufferState(buffer: Buffer): EnumResourceState;
    queryImageState(image: Image): EnumResourceState;
    queryShaderState(shader: Shader): EnumResourceState;
    queryPipelineState(pipeline: Pipeline): EnumResourceState;
    queryShaderBinary?(shader: Shader): GfxNativeBuffer;
  }
  function setup(canvas: HTMLCanvasElement): void;
  /*
	  bufferPoolSize?:number,
	  shaderPoolSize?:number,
	  imagePoolSize?:number,
	  pipelinePoolSize?:number,
	  passPoolSize?:number
	  */
  class Pass {
    id: number;
    destroy(): void;
  }
  class PassAction {}
  class Pipeline {
    id: number;
    destroy(): void;
  }
  class Buffer {
    id: number;
    destroy(): void;
  }
  class Shader {
    id: number;
    destroy(): void;
  }
  class Image {
    id: number;
    destroy(): void;
  }
  class Bindings {}
}
declare module engineWX {
  class Image extends HTMLImageElement {
    premultiplyAlpha: boolean;
  }
  class Stats {
    mode: string;
    size: number;
    lastAccessedTime: number;
    lastModifiedTime: number;
    isDirectory(): boolean;
    isFile(): boolean;
  }
  class XLogManager {
    log: (message?: any, ...optionalParams: any[]) => void;
    info: (message?: any, ...optionalParams: any[]) => void;
    warn: (message?: any, ...optionalParams: any[]) => void;
    error: (message?: any, ...optionalParams: any[]) => void;
  }
  class DownloadTask {
    onProgressUpdate(callback: (res: { progress: number; totalBytesWritten: number; totalBytesExpectedToWrite: number }) => void);
    offProgressUpdate(callback: (res: { progress: number; totalBytesWritten: number; totalBytesExpectedToWrite: number }) => void);
    abort(): void;
  }

  type StatsArray = { path: string; stats: Stats }[];
  type PlainCallback = (response: { errMsg: string }) => void;
  type FileSystemManager = {
    mkdir(argument: { dirPath: string; recursive?: boolean; success?: PlainCallback; fail?: PlainCallback; complete?: PlainCallback }): void;
    rmdir(argument: { dirPath: string; recursive?: boolean; success?: PlainCallback; fail?: PlainCallback; complete?: PlainCallback }): void;
    saveFile(argument: { tempFilePath: string; filePath: string; success?: (response: { savedFilePath: string }) => void; fail?: PlainCallback; complete?: PlainCallback }): void;
    copyFile(argument: { srcPath: string; destPath: string; success?: PlainCallback; fail?: PlainCallback; complete?: PlainCallback }): void;
    readFile(argument: {
      filePath: string;
      encoding?: "binary" | "utf-8";
      position?: number;
      length?: number;
      success?: (response: { data: string | ArrayBuffer }) => void;
      fail?: PlainCallback;
      complete?: PlainCallback;
    }): void;
    writeFile(argument: { filePath: string; data: string | ArrayBuffer; encoding?: "binary" | "utf-8"; success?: PlainCallback; fail?: PlainCallback; complete?: PlainCallback }): void;
    unlink(argument: { filePath: string; success?: PlainCallback; fail?: PlainCallback; complete?: PlainCallback }): void;
    stat(argument: { path: string; recursive?: boolean; success?: (response: { stats: Stats | StatsArray }) => void; fail?: PlainCallback; complete?: PlainCallback }): void;
  };

  type KeyboardEvent = {
    value: string;
  };

  type ShowKeyboardArgument = {
    defaultValue: string;
    maxLength: number;
    multiple: boolean;
    confirmHold: boolean;
    confirmType: "done" | "next" | "search" | "go" | "send";
    success?: PlainCallback;
    fail?: PlainCallback;
    complete?: PlainCallback;
  };

  type UpdateKeyboardArgument = {
    value: string;
    success?: PlainCallback;
    fail?: PlainCallback;
    complete?: PlainCallback;
  };

  type HideKeyboardArgument = {
    success?: PlainCallback;
    fail?: PlainCallback;
    complete?: PlainCallback;
  };

  type Worker = {
    postMessage: (message: any) => void;
    onMessage: (callback: (message: any) => void) => void;
    terminate();
  };

  type SharedArrayBuffer = {
    buffer: ArrayBuffer;
    sab_id: number;
    lock(callback: () => void): void;
    unlock(): void;
  };

  class WX {
    env: {
      USER_DATA_PATH: string;
    };

    getFileSystemManager(): FileSystemManager;
    getSystemInfoSync(): {
      platform: "ios" | "android" | "devtools" | "windows";
      screenWidth: number;
      screenHeight: number;
      pixelRatio: number;
      system: string;
    };
    loadFont(path: string): string | null;
    encode(argument: { data: string; format: "utf-8" | "gbk" }): ArrayBuffer;
    decode(argument: { data: ArrayBuffer; format: "utf-8" | "gbk" }): string;
    createImage(): Image;
    createCanvas(): HTMLCanvasElement;
    createOffScreenCanvas(): HTMLCanvasElement;
    getXLogManager(): XLogManager;
    downloadFile(argument: {
      url: string;
      filePath?: string;
      enableHttp2?: boolean;
      success?: (res: { dataLength?: number; errMsg: string; header: { [key: string]: string }; statusCode: number; tempFilePath?: string; filePath?: string }) => void;
      fail?: PlainCallback;
      complete?: PlainCallback;
    }): DownloadTask;
    setPreferredFramesPerSecond(fps: number): void;

    showKeyboard(argument: ShowKeyboardArgument): void;
    updateKeyboard(argument: UpdateKeyboardArgument): void;
    hideKeyboard(argument?: HideKeyboardArgument): void;
    onKeyboardInput(callback: (response: KeyboardEvent) => void): void;
    onKeyboardConfirm(callback: (response: KeyboardEvent) => void): void;
    onKeyboardComplete(callback: (response: KeyboardEvent) => void): void;

    onTouchStart(callback: (event: TouchEvent) => void);
    onTouchMove(callback: (event: TouchEvent) => void);
    onTouchEnd(callback: (event: TouchEvent) => void);
    onTouchCancel(callback: (event: TouchEvent) => void);

    onRemoteDebug(event: string, callback: (res: { command: string; data: any }) => void): void;
    sendRemoteDebug(debugMessage: { category: string; command: string; data: any }): void;

    createWorker(path: string): Worker;

    createSharedArrayBuffer(size: number): SharedArrayBuffer;
  }
}

declare const _wx: engineWX.WX; /* eslint-disable @typescript-eslint/member-ordering */
declare namespace wxGA {
  /*
	    Render Accelerator
	  */
  export interface TypeVertexInputFormat {
    name: string;
    buffer_index: number;
    offset: number;
    format: wgfx.EnumVertexFormat;
  }
  export interface TypeVertexBufferFormat {
    stride: number;
  }
  export interface VertexLayoutProtocol {
    layout: {
      attrs: TypeVertexInputFormat[];
      buffers?: TypeVertexBufferFormat[];
    };
  }

  class NativeValue {
    readonly data: ArrayBuffer;
  }
  class CommandBuffer {
    putRenderDraw(renderDraw: RenderDraw): void;
    batchPutRenderDraw(renderDraws: RenderDraw[], length?: number): void;
    putSubCommandBuffer(commandBuffer: CommandBuffer): void;
    reset(): void;
    execute(): void;
  }
  class RenderDraw {
    renderView: RenderView;
    shader: wgfx.Shader;
    vertexLayout: VertexLayout;
    /*
	    blend: number;
	    rgba: number;
	    stencilOpTest: number;
	    stencilDepth: number;
	    raster: number;
	    */
    indexBuffer: wgfx.Buffer;
    vertexBuffers: wgfx.Buffer[];
    nativeValues: NativeValue[];
    images: wgfx.Image[];
    baseElement: number;
    numElements: number;
    applyUpdate(): void;
    setBlendOn(on: boolean): void;
    setBlendMode(src: wgfx.EnumBlendFactor, dst: wgfx.EnumBlendFactor, func: wgfx.EnumBlendOp): void;
    setBlendModeSeparate(
      srcRGB: wgfx.EnumBlendFactor,
      srcAlpha: wgfx.EnumBlendFactor,
      dstRGB: wgfx.EnumBlendFactor,
      dstAlpha: wgfx.EnumBlendFactor,
      funcRGB: wgfx.EnumBlendOp,
      funcAlpha: wgfx.EnumBlendOp,
    ): void;
    setDepthWriteOn(on: boolean): void;
    setDepthTest(func: wgfx.EnumCompareFunc): void;
    setStencilTestOn(on: boolean): void;
    setStencilWriteMask(mask: number): void;
    setStencilReadMask(mask: number): void;
    setStencilRef(ref: number): void;
    setStencilTestMode(func: wgfx.EnumCompareFunc, fail: wgfx.EnumStencilOp, zfail: wgfx.EnumStencilOp, pass: wgfx.EnumStencilOp): void;
    setStencilTestModeSeparate(
      funcFront: wgfx.EnumCompareFunc,
      failFront: wgfx.EnumStencilOp,
      zfailFront: wgfx.EnumStencilOp,
      passFront: wgfx.EnumStencilOp,
      funcBack: wgfx.EnumCompareFunc,
      failBack: wgfx.EnumStencilOp,
      zfailBack: wgfx.EnumStencilOp,
      passBack: wgfx.EnumStencilOp,
    ): void;
    setCullMode(mode: wgfx.EnumCullMode): void;
    setFaceWinding(type: wgfx.EnumFaceWinding): void;
    setPrimitiveType(type: wgfx.EnumPrimitiveType): void;
    setIndexType(type: wgfx.EnumIndexType): void;
    setPassDepthFormat(pixelFormat: wgfx.EnumPixelFormat): void;
    setPassColorFormat(pixelFormat: wgfx.EnumPixelFormat, attachmentCount: number): void;
    setUnBatchable(): void;
    setBatchable(vertexBuffer: BatchableVertexBuffer, indexBuffer: BatchableIndexBuffer, worldTransform: NativeValue): void;
    setBatchableRenderDataDirty(): void;
  }
  class RenderView {}
  class Rect {}
  class VertexLayout {}
  class BatchableVertexBuffer {
    data: ArrayBuffer;
  }
  class BatchableIndexBuffer {
    data: ArrayBuffer;
  }

  class Renderer {
    createCommandBuffer(defaultRenderDrawCount?: number, defaultSubCommandBufferCount?: number): CommandBuffer;
    createRect(x: number, y: number, width: number, height: number): Rect;
    createRenderDraw(): RenderDraw;
    createVertexLayout(config: VertexLayoutProtocol): VertexLayout;
    createRenderView(pass: wgfx.Pass | { id: 0 }, passAction: wgfx.PassAction, viewport: Rect, scissor: Rect): RenderView;
    createBatchableVertexBuffer(count: number, vertexLayout: VertexLayout): BatchableVertexBuffer;
    createBatchableIndexBuffer(count: number): BatchableIndexBuffer;
  }

  /*
	    Logic Accelerator
	  */

  export enum enumComponentType {
    Cullable,
    Animator,
    SkinnedSkeleton,
  }
  export enum enumModelType {
    AnimationClipModel,
    SkeletonBoneInverseModel,
  }
  class PoolObject {
    readonly id: number;
    readonly float32View: Float32Array;
    readonly nativeId: number;
    readonly poolId: number;
    readonly poolIndex: number;
    setRawBuffer(buffer: Float32Array): void;
  }
  class Entity3D extends PoolObject {
    readonly localEulerOffset: number;
    readonly localQuaternionOffset: number;
    readonly localPositionOffset: number;
    readonly localScaleOffset: number;
    readonly worldMatrixOffset: number;

    readonly localPositionView: Float32Array;
    readonly localEulerView: Float32Array;
    readonly localQuaternionView: Float32Array;
    readonly localScaleView: Float32Array;
    readonly worldMatrixView: Float32Array;

    setUsingEuler(on: boolean): void;
    isUsingEuler(): boolean;
    /*
	    cloneLocalPosition(): Float32Array;
	    cloneLocalEuler(): Float32Array;
	    cloneLocalQuaternion(): Float32Array;
	    cloneLocalScale(): Float32Array;
	    getWorldMatrix(): Float32Array;
	    setLocalPosition(val: Float32Array);
	    setLocalEuler(val: Float32Array);
	    setLocalQuaternion(val: Float32Array);
	    setLocalScale(val: Float32Array);
	    isUsingEuler(): boolean;
	    */
  }
  class Entity2D extends PoolObject {
    readonly localRotationOffset: number;
    readonly localPositionOffset: number;
    readonly localScaleOffset: number;
    readonly worldMatrixOffset: number;

    readonly localPositionView: Float32Array;
    readonly localRotationView: Float32Array;
    readonly localScaleView: Float32Array;
    readonly worldMatrixView: Float32Array;
    /*
	    cloneLocalPosition(): Float32Array;
	    cloneLocalRotation(): number;
	    cloneLocalScale(): Float32Array;
	    getWorldMatrix(): Float32Array;
	    setLocalPosition(val: Float32Array);
	    setLocalRotation(val: number);
	    setLocalScale(val: Float32Array);
	    */
  }
  class CullableComponent extends PoolObject {
    bindEntity(entity: Entity3D): void;
    unbindEntity(): void;
    getActive(): boolean;
    setActive(val: boolean): void;
    getCullMask(): number;
    getBoundingBallRadius(): number;
    getBoundingBallCenter(): Float32Array;
    setCullMask(val: number): void;
    setBoundingBallRadius(val: number): void;
    setBoundingBallCenter(val: Float32Array, offset?: number): void;
  }
  class NativeObject {
    readonly id: number;
    active: boolean;
    setRawBuffer(buffer: Float32Array): void;
  }
  class AnimatorComponent extends NativeObject {
    bindAnimations(animationClipModels: AnimationClipModel[], entitys: Array<Array<Entity3D | null>>, rootEntity?: Entity3D): void;
    setClipParams(index: number, frameIndex: number, blendWeight: number): void;
  }
  class SkinnedSkeletonComponent extends NativeObject {
    getBoneOffsetMatrices(): Float32Array | undefined;
    getBoneNum(): number;
    setBoneMatrix(boneInverseModel: SkeletonBoneInverseModel, boneNum: number, boneIndices: number[], boneEntities: Entity3D[]): void;
  }

  class DataModel {
    readonly id: number;
  }
  class DataBuffer extends NativeObject {
    readonly dataLength: number;
    readonly byteOffset: number;
    readonly arrayBuffer: ArrayBuffer;
  }
  class SkeletonBoneInverseModel extends DataModel {
    setBoneInverseMatrix(matrices: Float32Array): void;
  }
  class AnimationClipModel extends DataModel {
    setAnimationClip(ab: ArrayBuffer): void;
  }
  class LogicAccelerator {
    frameStart(): void;
    /*
     * Create function
     */
    createEntity3D(): Entity3D;
    createEntity2D(): Entity2D;
    createComponent(type: enumComponentType): CullableComponent | AnimatorComponent | SkinnedSkeletonComponent | null;
    createDataModel(type: enumModelType): DataModel;
    createDataBuffer(byteLength: number): DataBuffer;
    /*
     * Entity function
     */
    entityAddChild(entity: Entity2D | Entity3D, child: Entity2D | Entity3D): void;
    entityAddChildAtIndex(entity: Entity2D | Entity3D, child: Entity2D | Entity3D, index: number): void;
    entityRemoveFromParent(entity: Entity2D | Entity3D): void;
    entityDestroy(entity: Entity2D | Entity3D): void;
    entityClear(entity: Entity2D | Entity3D): void;
    entitySetActive(entity: Entity2D | Entity3D, active: boolean): void;
    entitySetLocalMatrixDirty(entity: Entity2D | Entity3D): void;

    componentBindEntity(component: CullableComponent, entity: Entity2D | Entity3D): void;
    componentUnbindEntity(component: CullableComponent): void;

    setRootEntity(entity: Entity2D | Entity3D): void;
    refreshWorldTransform(): void;
    cullWithCameraPerspective(
      cullMask: number,
      eyeX: number,
      eyeY: number,
      eyeZ: number,
      centerX: number,
      centerY: number,
      centerZ: number,
      upX: number,
      upY: number,
      upZ: number,
      fovy: number,
      aspect: number,
      zNear: number,
      zFar: number,
    ): { objects: Uint32Array; hash: number; distances: Float32Array };
    cullWithCameraOrthographic(
      cullMask: number,
      eyeX: number,
      eyeY: number,
      eyeZ: number,
      centerX: number,
      centerY: number,
      centerZ: number,
      upX: number,
      upY: number,
      upZ: number,
      xMin: number,
      xwMax: number,
      ywMin: number,
      ywMax: number,
      zwNear: number,
      zwFar: number,
    ): { objects: Uint32Array; hash: number; distances: Float32Array };
    initCullingArrayBuffer(): {
      u32View: Uint32Array;
      f32View: Float32Array;
    };
    cullWithCameraPerspectiveByArrayBuffer(
      cullMask: number,
      eyeX: number,
      eyeY: number,
      eyeZ: number,
      centerX: number,
      centerY: number,
      centerZ: number,
      upX: number,
      upY: number,
      upZ: number,
      fovy: number,
      aspect: number,
      zNear: number,
      zFar: number,
    ): boolean;
    cullWithCameraOrthographicByArrayBuffer(
      cullMask: number,
      eyeX: number,
      eyeY: number,
      eyeZ: number,
      centerX: number,
      centerY: number,
      centerZ: number,
      upX: number,
      upY: number,
      upZ: number,
      xMin: number,
      xwMax: number,
      ywMin: number,
      ywMax: number,
      zwNear: number,
      zwFar: number,
    ): boolean;
    updateAnimator(comp: AnimatorComponent): void;
    updateAnimators: (comps: Array<AnimatorComponent>, length: number) => void;
    updateSkinningMatrix(comp: SkinnedSkeletonComponent): void;
    updateSkinningMatrices: (comps: Array<SkinnedSkeletonComponent>, length: number) => void;
    bindEntitiesToBones: (entitis: Array<Entity2D | Entity3D>, boneEntitis: Array<Entity2D | Entity3D>) => void;
    unbindEntitiesFromBones: (entitis: Array<Entity2D | Entity3D>) => void;
    composeRawBufferEntity2D: (rotation: number, position: ArrayLike<number>, scale: ArrayLike<number>) => Float32Array;
    composeRawBufferEntity3D: (useEuler: boolean, rotation: ArrayLike<number>, position: ArrayLike<number>, scale: ArrayLike<number>) => Float32Array;
  }
  class LongIntToIntMap {
    public set(key1: number, key2: number, value: number): void;
    public get(key1: number, key2: number): number | undefined;
    public del(key1: number, key2: number): void;
  }
  class NativeMap<T> {
    public set(key: T, value: number): void;
    public get(key: T): number | undefined;
    public del(key: T): void;
  }

  /*
	    context
	  */
  const hasNewWeakRef: boolean;
  function createNativeValue(byteSize: number): NativeValue;
  function createNativeValueFromArrayBuffer(sourceArrayBuffer: ArrayBuffer, offset: number, byteSize: number): NativeValue;
  function getRenderer(context: wgfx.RenderingContext): Renderer;
  function getEngine(): LogicAccelerator;
  function createWeakRef<T>(wrapper: T): { deref: () => T };
  function createAutoRef<T>(wrapper: T): { makeRef: () => T };
  function createNewWeakRef<T>(wrapper: T): { deref: () => T };
  function createNewWeakRefSentry<T>();
  function getNativeGlobalProfileResult(): { retainingObjects: { [gfxObj: string]: number } };

  function createNativeUUMap(): NativeMap<number>;
  function createNativeSUMap(): NativeMap<string>;
  function createNativeULUMap(): LongIntToIntMap;
}
